<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Notes | Cassius0924 的博客</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://blog.cassdev.com/tags/notes/><link crossorigin=anonymous href=/assets/css/stylesheet.4f5249ac184c033613d94c5267209e90161d3a93365c2feb0ad3960a4bbb6393.css integrity="sha256-T1JJrBhMAzYT2UxSZyCekBYdOpM2XC/rCtOWCku7Y5M=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.cassdev.com/tags/notes/index.xml><link rel=alternate hreflang=zh href=https://blog.cassdev.com/tags/notes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/tags/notes/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="Notes"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Notes"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title="Cassius0924 的博客"><span>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://blog.cassdev.com/>首页</a>&nbsp;»&nbsp;<a href=https://blog.cassdev.com/tags/>Tags</a></div><h1>Notes
<a href=/tags/notes/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Socket 编程之 IO 多路复用学习笔记</h2></header><div class=entry-content><p>什么是 IO 多路复用？阻塞 IO 与 非阻塞 IO我们先了解一下阻塞 IO，阻塞 IO 是指应用程序在读写数据时，如果没有数据可读或者写，应用程序会一直 阻塞在那里 ，直到有数据可读或者写。
与它相反的是非阻塞 IO，是指应用程序在读写数据时，无论是否有数据可读写，都 立即返回 ，若没有数据可读写将会返回一个错误码，通过不断轮询来检查是否有数据可读或者写。
IO 多路复用由于 Scoket 默认是阻塞 IO，所以很多初学者在处理多个连接时，会为每个连接创建一个线程来处理，但这样做会引起 CPU 的上下文切换，降低系统的性能。
有一种更“优雅”的方式，那就是 IO 多路复用，也称为事件驱动模型（Event-driven IO）。IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 事件已经就绪，就通知该进程。IO 多路复用模型中，只需要一个线程就可以同时处理多个连接。
通俗易懂的说，IO 多路复用就是将多个 IO 事件交给内核，内核帮我们监听这些 IO 事件，当有 IO 事件就绪时，内核会通知我们，我们只需要处理就绪的 IO 事件即可。
IO 多路复用的优点 一个线程可以同时处理多个连接，减少线程的创建和销毁
降低了系统开销，提高了系统的并发性能
IO 多路复用的实现方式 select
poll
epoll (Linux)
kqueue (FreeBSD)
IOCP（Windows）
其中 epoll 是 Linux 下的 IO 多路复用机制，kqueue 是 FreeBSD（macOS 就属于 FreeBSD）下的 IO 多路复用机制。
下面的伪代码是 IO 多路复用的最基本实现方式：
...</p></div><footer class=entry-footer><span title='2024-06-24 21:36:55 +0800 +0800'>2024年06月24日</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Socket 编程之 IO 多路复用学习笔记" href=https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>YOLO 目标检测算法学习笔记（二）</h2></header><div class=entry-content><p>可以说，YOLO各代升级的改进点都是提升检测效果mAP和速度FPS。
Precision精度与Recall召回率要计算精度与召回率（查全率），我们需要先了解四个值：
TP（True Positives） FP（False Positives） FN（False Negatives） TN（True Negatives） 相关（Relevant），正类 无关（NonRelevant），负类 被检索到（Retrieved） TP，正类判定为正类。 FP，负类判定为正类 未被检索到（Not Retrieved） FN，正类判定为负类 TN，负类判断为负类 记忆方法我们只需要记住这里面的四个单词的中文意思方可推断出四个值的含义。True 正确的、False 错误的、Positives 正类以及 Negatives 负类。
True Positives（➕➕）——正确的判断为正类，即将正类判定为正类。
False Positives（➖➕）——错误的判定为正类，即将负类判定为正类。
False Negatives（➕➖）——错误的判定为负类，即将正类判定为正类。
True Negatives（➖➖）——正确的判定为负类，即将负类判定为负类。
计算公式$$ Precision = \frac{TP}{TP+FP} $$
$$ Recall = \frac{TP}{TP + FN} $$
为了方便理解，我画了一个草图，以格子为单位。其中蓝色框代表实际值，橙色框代表预测值。
真正的正类（蓝色框内）共20个格子，真正的负类（蓝色框外）共10个格子。判定的正类（橙色框内），判定的负类（橙色框外）
TP值（正确的判断为正类），真正的正类与判定的正类的交集，即涂黄色的格子，共9个格子。
FP值（错误的判定为正类），真正的负类与判定的正类的交集，即涂绿色的格子，共6个格子。
FN值（错误的判定为负类），真正的正类与判定的负类的交集，即涂蓝色的格子，共11个格子。
TN值（正确的判定为负类），真正的负类与判定的负类的交集，即涂红色的格子，共4个格子。
例子已知条件：班级总人数100人，其中男生80人，女生20人。 目标：找出所有的女生。 结果：从班级中选择了50人，其中20人是女生，还错误的把30名男生挑选出来了。
TP = 20; FP = 30; FN = 0; TN = 50
mAP指标目标检测不可单看精度（Precision）或召回率（Recall），因为两者为此消彼长的关系。所以需要一个新的指标用于综合的衡量目标检测的效果。
mAP（mean Average Precision）指标，又名全类平均精度，用于综合衡量目标检测的效果。
...</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to YOLO 目标检测算法学习笔记（二）" href=https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>YOLO 目标检测算法学习笔记（三）</h2></header><div class=entry-content><p>YOLO-V1YOLO，全称 You Only Look Once。名字已经说明了一切！
YOLO 这是一个经典的 one-stage 方法，把检测问题转换为回归问题，一个CNN就可以搞定。
YOLO 相比于 Faster R-CNN 虽然在 mAP 值上略逊一筹，但其 FPS 值是远远高于 Faster R-CNN 的，因此2016年的时，YOLO爆火。
核心思想
将输入图像分割成 SxS 个网格（如7x7），每个网格负责检测本身区域是否含有物体。
每个网格会预测 B 个边界框（在YOLO-V1中，B值等于2），边界框由四个变量表示 x、y、w、h，以及每个边界框的置信度，置信度用 c 表示。置信度表示边界框包含物体的概率。
过滤掉置信度低的边界框。
由于整个检测只需要一个前向传播，没有区域提议生成候选框的过程，所以速度非常快。
网络架构
将输入图像（在YOLO-V1中限制了输入图像的大小）进行通过卷积神经网络进行特征提取，获得 7x7x1024 的特征图，再进入全连接层，得到 1470 个特征，随后 Reshape 成 7x7x30 的特征图。
下面解释一下 7x7x30 的含义。
7x7 表示输入图像最后分割的网格大小。
30 分为 5+5+20，其中前两个5代表两个边界框的 x、y、w、h和c；最后的20表示当前格子属于数据集中的各个类别的概率。
注意，这里三个值都不是固定不变的，会由于YOLO版本的更新和训练数据集的变化而改变。
总结一下 ，如上图所示，输入图像最后会被分割成许多个网格，每个网格都包含了若干值。
S：网格边长；B：预测边界框数量；C：数据集中的类别个数。 $$ (S * S) * (B * 5 + C) $$
...</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to YOLO 目标检测算法学习笔记（三）" href=https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>YOLO 目标检测算法学习笔记（四）</h2></header><div class=entry-content><p>YOLO-V2下图为YOLO-V2相较于YOLO-V1的改进点，以及改进后 mAP 值的变化。
Batch NormalizationV2 版本舍弃了 Dropout，不再有全连接层（Fully connected layers，FC）。每次卷积后都加入 Batch Normalization，对网络的每一层的输入都进行归一化，使收敛更容易。
经过 Batch Normalization 处理后的网络会提升2%的mAP值。
从现在的角度来看，Batch Normatlization 已经称为卷积神经网络处理必备处理了。
High Resolution ClassifierHigh Resolution Classifier，即高分辨率分类器，高分辨率分类器。
在 V1 版本，训练时用的是224*224分辨率的图片，测试时又使用448*448分辨率的图片，这会导致模型“水土不服”。
针对这一问题，V2 版本在模型训练时额外进行了10次448*448的微调。经过微调后，V2 版本的 mAP 值提升了约4%。
Convolutional</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to YOLO 目标检测算法学习笔记（四）" href=https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>YOLO 目标检测算法学习笔记（一）</h2></header><div class=entry-content><p>深度学习经典检测方法 one-stage（单阶段）：YOLO系列
two-stage（双阶段）：Faster-Rcnn、Mask-Rcnn系列
Faster-Rcnn：物体检测开山之作。
one-stage 单阶段检测优势：速度快，适合做实时检测任务。
缺点：效果不佳。
目标检测的两个主要指标：mAP和FPS。
mAP：检测效果的综合指标。（mAP值越大效果越好）
two-stage 双阶段检测优势：效果较好。
缺点：速度较慢、不适合用于视频流的实时检测。
Mask-Rcnn是一个非常实用的通用框架（建议了解）。</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to YOLO 目标检测算法学习笔记（一）" href=https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.cassdev.com/tags/notes/>«&nbsp;« 上一页&nbsp;1/2</a></nav></footer></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>