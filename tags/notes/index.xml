<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Notes on Cassius0924 的博客</title>
    <link>https://blog.cassdev.com/tags/notes/</link>
    <description>Recent content in Notes on Cassius0924 的博客</description>
    <generator>Hugo -- 0.148.2</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2025-2025 Cassius0924. All rights reserved.</copyright>
    <lastBuildDate>Sun, 30 Jun 2024 15:31:40 +0800</lastBuildDate>
    <atom:link href="https://blog.cassdev.com/tags/notes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Socket 编程之 epoll 源码分析学习笔记</title>
      <link>https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-epoll-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 30 Jun 2024 15:31:40 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-epoll-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;本文基于 Linux 6.9 内核源码进行分析。&lt;/p&gt;
&lt;h2 id=&#34;几个数据结构&#34;&gt;几个数据结构&lt;/h2&gt;&lt;p&gt;&lt;img alt=&#34;数据结构&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2024/06/30/fPingVOd2YcEFUX.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;eventpoll&#34;&gt;eventpoll&lt;/h3&gt;&lt;p&gt;这是 epoll 的主要数据结构，它用于存储 epoll 的相关信息，包括等待队列、就绪队列、红黑树等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventpoll&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;wait_queue_head_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// epoll 的等待队列：用于存储等待的进程/线程，指向等待队列头
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;wait_queue_head_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;poll_wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 这个 poll_wait 等待队列只有在 epoll 嵌套的情况下才会用到
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list_head&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rdllist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 就绪队列：用于存储就绪的 fd，指向就绪队列头
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb_root_cached&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rbr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 红黑树：用于存储所有的 fd，指向红黑树根节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wakeup_source&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ws&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 一个唤醒源，用于唤醒进程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;epitem&#34;&gt;epitem&lt;/h3&gt;&lt;p&gt;epitem 的作用是将 fd、就绪队列、红黑树节点等信息封装在一起。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epitem&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;union&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rb_node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rbn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// 红黑树节点，用于存储 fd，指向红黑树节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rcu_head&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rcu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 用于释放 epitem
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list_head&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rdllink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 就绪队列节点，用于存储就绪的 fd，指向就绪队列节点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventpoll&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// 指向 eventpoll
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epoll_filefd&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ffd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// epoll 文件描述符
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wakeup_source&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ws&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 一个唤醒源，用于唤醒进程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epoll_event&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 监听的事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;ep_pqueue&#34;&gt;ep_pqueue&lt;/h3&gt;&lt;p&gt;给 poll 队列封装的结构体，用于存储 poll_table 和 epitem。&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; 内存模型学习笔记</title>
      <link>https://blog.cassdev.com/posts/c&#43;&#43;-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 29 Jun 2024 16:44:14 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/c&#43;&#43;-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;C++ 内存模型从上（高地址）到下（低地址）可以分为以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;栈区&lt;/strong&gt;：由编译器自动分配释放，存放函数的参数值、局部变量的值等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;堆区&lt;/strong&gt;：由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全局/静态区&lt;/strong&gt;：分为 .data 段（全局初始化区）和 .bss 段（全局未初始化区），.data 段存放 &lt;strong&gt;已初始化&lt;/strong&gt; 了的全局变量和静态变量，.bss 段存放 &lt;strong&gt;未初始化&lt;/strong&gt; 的变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常量区&lt;/strong&gt;：就是 .rodata 段，存放常量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码区&lt;/strong&gt;：存放函数体的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2024/06/29/kHdqTj5Y2Fh7Ea4.jpg&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>哈希冲突解决方法学习笔记</title>
      <link>https://blog.cassdev.com/posts/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 29 Jun 2024 10:16:12 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;链地址法&#34;&gt;链地址法&lt;/h2&gt;&lt;p&gt;链地址法也叫做拉链法，它的基本思想是，将哈希表中的每个槽位都指向一个链表，当发生哈希冲突时，将数据插入到链表中。&lt;/p&gt;
&lt;p&gt;很好理解，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2024/06/29/DUupYdFkvxbCscP.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;开放定址法&#34;&gt;开放定址法&lt;/h2&gt;&lt;p&gt;开放定址法是一种解决哈希冲突的方法，它的基本思想是，当发生哈希冲突时，不是将数据直接插入到哈希表中，而是寻找哈希表中的空槽位，将数据插入到空槽位中。&lt;/p&gt;
&lt;h3 id=&#34;线性探测&#34;&gt;线性探测&lt;/h3&gt;&lt;p&gt;线性探测采用固定步长的线性搜索来进行探测。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 1），直至找到空桶，将元素插入其中。&lt;/li&gt;
&lt;li&gt;查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 value 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 None 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，我们不能在开放寻址哈希表中直接删除元素。因为删除元素会在数组内产生一个空桶 None ，当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2024/06/29/qEIPUWjZ2HNwBbp.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了解决该问题，我们可以采用懒删除（ &lt;em&gt;lazy deletion&lt;/em&gt; ）机制，不直接从哈希表中移除元素，而是利用一个常量 &lt;strong&gt;TOMBSTONE&lt;/strong&gt; 来标记这个桶。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;None&lt;/strong&gt; 和 &lt;strong&gt;TOMBSTONE&lt;/strong&gt; 都代表空桶，都可以放置键值对。线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。在线性探测中记录遇到的首个 TOMBSTONE 的索引，并将搜索到的目标元素与该 TOMBSTONE 交换位置，这样可以优化效率。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2024/06/29/gxJ6SFeRzVZwG25.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;线性探测容易产生 &lt;strong&gt;聚集现象&lt;/strong&gt;，为了缓解这个问题，就有了平方探测和双重散列。&lt;/p&gt;
&lt;h3 id=&#34;平方探测&#34;&gt;平方探测&lt;/h3&gt;&lt;p&gt;平方探测思想与线性探测类似，不同之处在于探测的步长是平方级别的。即当发生哈希冲突时，探测的步长为 &lt;code&gt;1&lt;/code&gt;，&lt;code&gt;4&lt;/code&gt;，&lt;code&gt;9&lt;/code&gt;，&amp;hellip;步。&lt;/p&gt;
&lt;p&gt;平方探测可以缓解线性探测的聚集现象，但不能彻底解决。&lt;/p&gt;
&lt;h3 id=&#34;多次哈希&#34;&gt;多次哈希&lt;/h3&gt;&lt;p&gt;多次哈希的基本思想是，当发生哈希冲突时，尝试其他的哈希函数，直到找到空槽位。&lt;/p&gt;
&lt;p&gt;与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。&lt;/p&gt;

            &lt;link rel=&#34;stylesheet&#34; href=&#34;https://blog.cassdev.com/css/vendors/admonitions.4fd9a0b8ec8899f2ca952048d255a569f433f77dfb3f52f5bc87e7d65cdce449.css&#34; integrity=&#34;sha256-T9mguOyImfLKlSBI0lWlafQz9337P1L1vIfn1lzc5Ek=&#34; crossorigin=&#34;anonymous&#34;&gt;
    &lt;div class=&#34;admonition warning&#34;&gt;
      &lt;div class=&#34;admonition-header&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;0 0 512 512&#34;&gt;&lt;path d=&#34;M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480L40 480c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24l0 112c0 13.3 10.7 24 24 24s24-10.7 24-24l0-112c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z&#34;/&gt;&lt;/svg&gt;
        &lt;span&gt;警告&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&#34;admonition-content&#34;&gt;
        &lt;p&gt;以上三种方法，线性探测、平方探测和多次哈希哈希表都存在 &lt;strong&gt;不能直接删除元素&lt;/strong&gt; 的问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; STL 常用容器和迭代器学习笔记</title>
      <link>https://blog.cassdev.com/posts/c&#43;&#43;-stl-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 28 Jun 2024 19:50:50 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/c&#43;&#43;-stl-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;常用容器&#34;&gt;常用容器&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;序列容器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;: 动态数组，随机插入/删除 &lt;code&gt;O(n)&lt;/code&gt;，随机访问 &lt;code&gt;O(1)&lt;/code&gt;，尾插 &lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;array&lt;/code&gt;: 静态数组，不支持插入/删除，随机访问 &lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;deque&lt;/code&gt;: 双端队列，头尾插入/删除 &lt;code&gt;O(1)&lt;/code&gt;，随机访问 &lt;code&gt;O(1)&lt;/code&gt;，中间插入/删除 &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;: 双向链表，插入/删除 &lt;code&gt;O(1)&lt;/code&gt;，不支持随机访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;forward_list&lt;/code&gt;: 单向链表，插入/删除 &lt;code&gt;O(1)&lt;/code&gt;，不支持随机访问&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关联容器（底层实现为 &lt;strong&gt;红黑树&lt;/strong&gt; ）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;set&lt;/code&gt;: 有序集合，插入/删除/查找 &lt;code&gt;O(logn)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;: 有序映射，插入/删除/查找 &lt;code&gt;O(logn)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;multiset&lt;/code&gt;: 有序多重集合，插入/删除/查找 &lt;code&gt;O(logn)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;multimap&lt;/code&gt;: 有序多重映射，插入/删除/查找 &lt;code&gt;O(logn)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无序容器（底层实现为 &lt;strong&gt;哈希表&lt;/strong&gt; ）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unordered_set&lt;/code&gt;: 无序集合，插入/删除/查找 &lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unordered_map&lt;/code&gt;: 无序映射，插入/删除/查找 &lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unordered_multiset&lt;/code&gt;: 无序多重集合，插入/删除/查找 &lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unordered_multimap&lt;/code&gt;: 无序多重映射，插入/删除/查找 &lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器适配器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stack&lt;/code&gt;: 栈，后进先出，只能在栈顶插入/删除元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;queue&lt;/code&gt;: 队列，先进先出，只能在队尾插入，在队头删除元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;priority_queue&lt;/code&gt;: 优先队列，元素按照一定规则排序，每次取出的是最大/最小元素，底层实现为堆&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;vector&#34;&gt;vector&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// vector使用示例
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 尾部插入元素：复杂度为O(1)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 尾部删除元素：复杂度为O(1)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pop_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 随机插入和删除元素：复杂度为O(n)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;erase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// vector的大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 获取vector的容量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;capacity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 判断vector是否为空
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 获取vector的第一个元素和最后一个元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;front&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 访问指定位置的元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;at&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// at函数会检查索引是否越界，更安全
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vec2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;swap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vec2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 交换两个vector的元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 清空vector
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;clear&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;vector 常用的成员函数：&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; 对象和指针的区别学习笔记</title>
      <link>https://blog.cassdev.com/posts/c&#43;&#43;-%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 28 Jun 2024 10:26:35 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/c&#43;&#43;-%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;对象&#34;&gt;对象&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;MyClass&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fun&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对象是类的实例，占据实际的内存空间，可以调用类的成员函数和访问类的成员变量。&lt;/p&gt;
&lt;p&gt;对象大小 = 成员变量大小 + 对齐填充&lt;/p&gt;
&lt;h2 id=&#34;指针&#34;&gt;指针&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;MyClass&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MyClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fun&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;指针是一个变量，存储对象的地址，可以通过指针访问对象的成员函数和成员变量。&lt;/p&gt;
&lt;p&gt;指针大小 = 4 字节（32 位系统）或 8 字节（64 位系统）&lt;/p&gt;
&lt;h2 id=&#34;对象和指针的区别&#34;&gt;对象和指针的区别&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;内存管理
&lt;ul&gt;
&lt;li&gt;对象：内存分配和释放通常是自动的（除非使用动态分配）。&lt;/li&gt;
&lt;li&gt;指针：指向的内存需要手动管理，尤其是动态分配的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;访问方式：
&lt;ul&gt;
&lt;li&gt;对象：直接访问成员。&lt;/li&gt;
&lt;li&gt;指针：通过解引用访问成员（使用 -&amp;gt; 操作符）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生命周期：
&lt;ul&gt;
&lt;li&gt;对象：由作用域决定，局部对象在离开作用域时自动销毁。&lt;/li&gt;
&lt;li&gt;指针：生命周期由程序员控制，指针可以指向任何作用域的变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; 多态学习笔记</title>
      <link>https://blog.cassdev.com/posts/c&#43;&#43;-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 27 Jun 2024 22:52:10 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/c&#43;&#43;-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。&lt;/p&gt;
&lt;p&gt;C++ 的多态性主要有两种实现方式：静态多态和动态多态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;静态多态：通过函数重载和模板实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态多态：通过虚函数实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;静态多态&#34;&gt;静态多态&lt;/h2&gt;&lt;h3 id=&#34;函数重载&#34;&gt;函数重载&lt;/h3&gt;&lt;p&gt;函数重载是指在同一个作用域内，可以定义 &lt;strong&gt;多个名称相同&lt;/strong&gt; 但 &lt;strong&gt;参数列表不同&lt;/strong&gt; 的函数。注意，不能用 &lt;strong&gt;返回值类型&lt;/strong&gt; 来区分重载函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
            &lt;link rel=&#34;stylesheet&#34; href=&#34;https://blog.cassdev.com/css/vendors/admonitions.4fd9a0b8ec8899f2ca952048d255a569f433f77dfb3f52f5bc87e7d65cdce449.css&#34; integrity=&#34;sha256-T9mguOyImfLKlSBI0lWlafQz9337P1L1vIfn1lzc5Ek=&#34; crossorigin=&#34;anonymous&#34;&gt;
    &lt;div class=&#34;admonition note&#34;&gt;
      &lt;div class=&#34;admonition-header&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;0 0 576 512&#34;&gt;&lt;path d=&#34;M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 125.7-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9 0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6 0zM311.9 417L441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z&#34;/&gt;&lt;/svg&gt;
        &lt;span&gt;笔记&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&#34;admonition-content&#34;&gt;
        &lt;p&gt;&lt;strong&gt;编译过程&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>TCP 的常见拥塞控制算法学习笔记</title>
      <link>https://blog.cassdev.com/posts/tcp-%E7%9A%84%E5%B8%B8%E8%A7%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 27 Jun 2024 13:54:31 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/tcp-%E7%9A%84%E5%B8%B8%E8%A7%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;TCP 的拥塞控制算法有几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Tahoe&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reno&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NewReno&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SACK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BIC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CUBIC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BBR&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

            &lt;link rel=&#34;stylesheet&#34; href=&#34;https://blog.cassdev.com/css/vendors/admonitions.4fd9a0b8ec8899f2ca952048d255a569f433f77dfb3f52f5bc87e7d65cdce449.css&#34; integrity=&#34;sha256-T9mguOyImfLKlSBI0lWlafQz9337P1L1vIfn1lzc5Ek=&#34; crossorigin=&#34;anonymous&#34;&gt;
    &lt;div class=&#34;admonition note&#34;&gt;
      &lt;div class=&#34;admonition-header&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;0 0 576 512&#34;&gt;&lt;path d=&#34;M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 125.7-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9 0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6 0zM311.9 417L441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z&#34;/&gt;&lt;/svg&gt;
        &lt;span&gt;笔记&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&#34;admonition-content&#34;&gt;
        &lt;p&gt;MSS: Maximum Segment Size，最大分段大小。&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; 智能指针学习笔记</title>
      <link>https://blog.cassdev.com/posts/c&#43;&#43;-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 26 Jun 2024 17:24:42 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/c&#43;&#43;-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;智能指针简介&#34;&gt;智能指针简介&lt;/h2&gt;&lt;p&gt;智能指针是一种 RAII（Resource Acquisition Is Initialization）技术，用于管理动态分配的内存。智能指针的优点是可以自动释放内存，避免内存泄漏。&lt;/p&gt;
&lt;p&gt;C++11 标准引入了三种智能指针：&lt;code&gt;std::unique_ptr&lt;/code&gt;、&lt;code&gt;std::shared_ptr&lt;/code&gt; 和 &lt;code&gt;std::weak_ptr&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;它们都定义在头文件 &lt;code&gt;&amp;lt;memory&amp;gt;&lt;/code&gt; 中。&lt;/p&gt;
&lt;h2 id=&#34;unique_ptr&#34;&gt;unique_ptr&lt;/h2&gt;&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt; 是一种独占所有权的智能指针，它保证同一时间只有一个指针可以指向对象。&lt;/p&gt;
&lt;h3 id=&#34;unique_ptr-的创建&#34;&gt;unique_ptr 的创建&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;memory&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 使用 new 创建 unique_ptr
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unique_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;up1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;up1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 使用裸指针创建 unique_ptr
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unique_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;up2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;up2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 使用 make_unique 创建 unique_ptr
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;up2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;make_unique&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;up2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;unique_ptr-的拷贝和赋值&#34;&gt;unique_ptr 的拷贝和赋值&lt;/h3&gt;&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt; 不能拷贝，但可以移动。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unique_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;up1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unique_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;up2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;up1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;up2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;unique_ptr-的释放&#34;&gt;unique_ptr 的释放&lt;/h3&gt;&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt; 会在离开作用域时自动释放内存。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unique_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;up1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;up1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;unique_ptr-的自定义删除器&#34;&gt;unique_ptr 的自定义删除器&lt;/h3&gt;&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt; 支持自定义删除器，可以用于释放动态分配的内存。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis 为什么采用单线程，为什么性能好</title>
      <link>https://blog.cassdev.com/posts/redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E5%A5%BD/</link>
      <pubDate>Wed, 26 Jun 2024 15:40:01 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E5%A5%BD/</guid>
      <description>&lt;p&gt;Redis 采用单线程的原因是因为在 &lt;strong&gt;内存中&lt;/strong&gt; 进行读写操作，&lt;strong&gt;CPU不是Redis的性能瓶颈&lt;/strong&gt;，而是内存和带宽，所以采用单线程可以避免 &lt;strong&gt;线程切换和锁的开销&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;redis-是什么&#34;&gt;Redis 是什么？&lt;/h2&gt;&lt;p&gt;Redis 是一个开源的内存数据库，它可以存储键值对，支持多种数据结构，如字符串（string）、哈希（hash）、列表（list）、集合（set）、有序集合（zset）等。&lt;/p&gt;
&lt;h2 id=&#34;redis-是不是单线程&#34;&gt;Redis 是不是单线程？&lt;/h2&gt;&lt;p&gt;实际上，Redis 是多线程的，其内部有以下几个线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;redis-server&lt;/code&gt;：主线程，负责接收客户端的连接，读取请求，发送响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bio-close-file&lt;/code&gt;：负责异步关闭大文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bio-aof-fsync&lt;/code&gt;：负责将 AOF 文件异步刷到磁盘。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bio-lasy-free&lt;/code&gt;：负责异步释放大内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;jemalloc-bg-thread&lt;/code&gt;：负责内存碎片整理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;io-thread&lt;/code&gt;：IO 线程，负责 read/write，decode/encode。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

            &lt;link rel=&#34;stylesheet&#34; href=&#34;https://blog.cassdev.com/css/vendors/admonitions.4fd9a0b8ec8899f2ca952048d255a569f433f77dfb3f52f5bc87e7d65cdce449.css&#34; integrity=&#34;sha256-T9mguOyImfLKlSBI0lWlafQz9337P1L1vIfn1lzc5Ek=&#34; crossorigin=&#34;anonymous&#34;&gt;
    &lt;div class=&#34;admonition note&#34;&gt;
      &lt;div class=&#34;admonition-header&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;0 0 576 512&#34;&gt;&lt;path d=&#34;M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 125.7-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9 0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6 0zM311.9 417L441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z&#34;/&gt;&lt;/svg&gt;
        &lt;span&gt;笔记&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&#34;admonition-content&#34;&gt;
        &lt;p&gt;&lt;strong&gt;AOF（Append Only File）&lt;/strong&gt; 是 Redis 的一种持久化方式，将所有写操作追加到文件末尾，重启时重新执行 AOF 文件中的命令即可恢复数据。实时硬盘操作，不会丢失数据，但是会影响性能。&lt;/p&gt;</description>
    </item>
    <item>
      <title>堆排序学习笔记</title>
      <link>https://blog.cassdev.com/posts/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 26 Jun 2024 10:20:13 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;在学习堆排序之前，我们先来了解一下堆这种数据结构。&lt;/p&gt;
&lt;h2 id=&#34;堆的概念&#34;&gt;堆的概念&lt;/h2&gt;&lt;p&gt;堆是一种特殊的树形数据结构，它满足以下性质：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;堆必须是一个 &lt;strong&gt;完全二叉树&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;堆序性：堆中任意节点的值总是不大于或不小于其子节点的值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据堆序性，我们可以将堆分为两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;大顶堆&lt;/strong&gt;：每个节点的值都大于或等于其子节点的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;小顶堆&lt;/strong&gt;：每个节点的值都小于或等于其子节点的值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;堆&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2024/06/26/8UaE23iJSzV91Rd.png&#34;&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;所以，如果一个完全二叉树的一个节点即大于其父节点，又大于其子节点，那么这个树就不是一个堆。小于同理。&lt;/p&gt;

            &lt;link rel=&#34;stylesheet&#34; href=&#34;https://blog.cassdev.com/css/vendors/admonitions.4fd9a0b8ec8899f2ca952048d255a569f433f77dfb3f52f5bc87e7d65cdce449.css&#34; integrity=&#34;sha256-T9mguOyImfLKlSBI0lWlafQz9337P1L1vIfn1lzc5Ek=&#34; crossorigin=&#34;anonymous&#34;&gt;
    &lt;div class=&#34;admonition note&#34;&gt;
      &lt;div class=&#34;admonition-header&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;0 0 576 512&#34;&gt;&lt;path d=&#34;M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 125.7-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9 0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6 0zM311.9 417L441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z&#34;/&gt;&lt;/svg&gt;
        &lt;span&gt;笔记&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&#34;admonition-content&#34;&gt;
        &lt;p&gt;&lt;strong&gt;完全二叉树的性质&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Socket 编程之 IO 多路复用学习笔记</title>
      <link>https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 24 Jun 2024 21:36:55 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;什么是-io-多路复用&#34;&gt;什么是 IO 多路复用？&lt;/h2&gt;&lt;h3 id=&#34;阻塞-io-与-非阻塞-io&#34;&gt;阻塞 IO 与 非阻塞 IO&lt;/h3&gt;&lt;p&gt;我们先了解一下阻塞 IO，阻塞 IO 是指应用程序在读写数据时，如果没有数据可读或者写，应用程序会一直 &lt;strong&gt;阻塞在那里&lt;/strong&gt; ，直到有数据可读或者写。&lt;/p&gt;
&lt;p&gt;与它相反的是非阻塞 IO，是指应用程序在读写数据时，无论是否有数据可读写，都 &lt;strong&gt;立即返回&lt;/strong&gt; ，若没有数据可读写将会返回一个错误码，通过不断轮询来检查是否有数据可读或者写。&lt;/p&gt;
&lt;h3 id=&#34;io-多路复用&#34;&gt;IO 多路复用&lt;/h3&gt;&lt;p&gt;由于 Scoket 默认是阻塞 IO，所以很多初学者在处理多个连接时，会为每个连接创建一个线程来处理，但这样做会引起 CPU 的上下文切换，降低系统的性能。&lt;/p&gt;
&lt;p&gt;有一种更“优雅”的方式，那就是 IO 多路复用，也称为事件驱动模型（Event-driven IO）。IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 事件已经就绪，就通知该进程。IO 多路复用模型中，只需要一个线程就可以同时处理多个连接。&lt;/p&gt;
&lt;p&gt;通俗易懂的说，IO 多路复用就是将多个 IO 事件交给内核，内核帮我们监听这些 IO 事件，当有 IO 事件就绪时，内核会通知我们，我们只需要处理就绪的 IO 事件即可。&lt;/p&gt;
&lt;h2 id=&#34;io-多路复用的优点&#34;&gt;IO 多路复用的优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个线程可以同时处理多个连接，减少线程的创建和销毁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降低了系统开销，提高了系统的并发性能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;io-多路复用的实现方式&#34;&gt;IO 多路复用的实现方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;select&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;poll&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;epoll (Linux)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;kqueue (FreeBSD)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IOCP（Windows）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 epoll 是 Linux 下的 IO 多路复用机制，kqueue 是 FreeBSD（macOS 就属于 FreeBSD）下的 IO 多路复用机制。&lt;/p&gt;
&lt;p&gt;下面的伪代码是 IO 多路复用的最基本实现方式：&lt;/p&gt;</description>
    </item>
    <item>
      <title>YOLO 目标检测算法学习笔记（二）</title>
      <link>https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
      <pubDate>Sun, 16 Jun 2024 11:20:31 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
      <description>&lt;p&gt;可以说，YOLO各代升级的改进点都是提升检测效果mAP和速度FPS。&lt;/p&gt;
&lt;h2 id=&#34;precision精度与recall召回率&#34;&gt;Precision精度与Recall召回率&lt;/h2&gt;&lt;p&gt;要计算精度与召回率（查全率），我们需要先了解四个值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TP（True Positives）&lt;/li&gt;
&lt;li&gt;FP（False Positives）&lt;/li&gt;
&lt;li&gt;FN（False Negatives）&lt;/li&gt;
&lt;li&gt;TN（True Negatives）&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;相关（Relevant），正类&lt;/th&gt;
          &lt;th&gt;无关（NonRelevant），负类&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;被检索到（Retrieved）&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;TP，正类判定为正类。&lt;/td&gt;
          &lt;td&gt;FP，负类判定为正类&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;未被检索到（Not Retrieved）&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;FN，正类判定为负类&lt;/td&gt;
          &lt;td&gt;TN，负类判断为负类&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;记忆方法&#34;&gt;记忆方法&lt;/h3&gt;&lt;p&gt;我们只需要记住这里面的四个单词的中文意思方可推断出四个值的含义。True 正确的、False 错误的、Positives 正类以及 Negatives 负类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;True Positives（&amp;#x2795;&amp;#x2795;）——正确的判断为正类，即将正类判定为正类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;False Positives（&amp;#x2796;&amp;#x2795;）——错误的判定为正类，即将负类判定为正类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;False Negatives（&amp;#x2795;&amp;#x2796;）——错误的判定为负类，即将正类判定为正类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;True Negatives（&amp;#x2796;&amp;#x2796;）——正确的判定为负类，即将负类判定为负类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;计算公式&#34;&gt;计算公式&lt;/h3&gt;&lt;p&gt;$$
Precision = \frac{TP}{TP+FP}
$$&lt;/p&gt;
&lt;p&gt;$$
Recall = \frac{TP}{TP + FN}
$$&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;IMG_4784&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2023/08/28/DLUk8I91clvCbwd.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了方便理解，我画了一个草图，以格子为单位。其中蓝色框代表实际值，橙色框代表预测值。&lt;/p&gt;
&lt;p&gt;真正的正类（蓝色框内）共20个格子，真正的负类（蓝色框外）共10个格子。判定的正类（橙色框内），判定的负类（橙色框外）&lt;/p&gt;
&lt;p&gt;TP值（正确的判断为正类），真正的正类与判定的正类的交集，即涂黄色的格子，共9个格子。&lt;/p&gt;
&lt;p&gt;FP值（错误的判定为正类），真正的负类与判定的正类的交集，即涂绿色的格子，共6个格子。&lt;/p&gt;
&lt;p&gt;FN值（错误的判定为负类），真正的正类与判定的负类的交集，即涂蓝色的格子，共11个格子。&lt;/p&gt;
&lt;p&gt;TN值（正确的判定为负类），真正的负类与判定的负类的交集，即涂红色的格子，共4个格子。&lt;/p&gt;
&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;&lt;p&gt;已知条件：班级总人数100人，其中男生80人，女生20人。
目标：找出所有的女生。
结果：从班级中选择了50人，其中20人是女生，还错误的把30名男生挑选出来了。&lt;/p&gt;
&lt;p&gt;TP = 20; FP = 30; FN = 0; TN = 50&lt;/p&gt;
&lt;h2 id=&#34;map指标&#34;&gt;mAP指标&lt;/h2&gt;&lt;p&gt;目标检测不可单看精度（Precision）或召回率（Recall），因为两者为此消彼长的关系。所以需要一个新的指标用于综合的衡量目标检测的效果。&lt;/p&gt;
&lt;p&gt;mAP（mean Average Precision）指标，又名全类平均精度，用于综合衡量目标检测的效果。&lt;/p&gt;</description>
    </item>
    <item>
      <title>YOLO 目标检测算法学习笔记（三）</title>
      <link>https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</link>
      <pubDate>Sun, 16 Jun 2024 11:20:31 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</guid>
      <description>&lt;h2 id=&#34;yolo-v1&#34;&gt;YOLO-V1&lt;/h2&gt;&lt;p&gt;YOLO，全称 You Only Look Once。名字已经说明了一切！&lt;/p&gt;
&lt;p&gt;YOLO 这是一个经典的 one-stage 方法，把检测问题转换为回归问题，一个CNN就可以搞定。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;YOLO-V1 mAP&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2023/08/30/UHC9IP5gSdZfolr.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;YOLO 相比于 Faster R-CNN 虽然在 mAP 值上略逊一筹，但其 FPS 值是远远高于 Faster R-CNN 的，因此2016年的时，YOLO爆火。&lt;/p&gt;
&lt;h2 id=&#34;核心思想&#34;&gt;核心思想&lt;/h2&gt;&lt;p&gt;&lt;img alt=&#34;YOLO 核心思想&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将输入图像分割成 SxS 个网格（如7x7），每个网格负责检测本身区域是否含有物体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个网格会预测 B 个边界框（在YOLO-V1中，B值等于2），边界框由四个变量表示 x、y、w、h，以及每个边界框的置信度，置信度用 c 表示。置信度表示边界框包含物体的概率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过滤掉置信度低的边界框。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于整个检测只需要一个前向传播，没有区域提议生成候选框的过程，所以速度非常快。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络架构&#34;&gt;网络架构&lt;/h2&gt;&lt;p&gt;&lt;img alt=&#34;YOLO 网络架构&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;将输入图像（在YOLO-V1中限制了输入图像的大小）进行通过卷积神经网络进行特征提取，获得 7x7x1024 的特征图，再进入全连接层，得到 1470 个特征，随后 Reshape 成 7x7x30 的特征图。&lt;/p&gt;
&lt;p&gt;下面解释一下 7x7x30 的含义。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;7x7  表示输入图像最后分割的网格大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;30 分为 5+5+20，其中前两个5代表两个边界框的 x、y、w、h和c；最后的20表示当前格子属于数据集中的各个类别的概率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，这里三个值都不是固定不变的，会由于YOLO版本的更新和训练数据集的变化而改变。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;YOLO 网络架构简化&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2023/08/30/3iVITLdxk4RA5Hf.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;总结一下 ，如上图所示，输入图像最后会被分割成许多个网格，每个网格都包含了若干值。&lt;/p&gt;
&lt;p&gt;S：网格边长；B：预测边界框数量；C：数据集中的类别个数。
$$
(S * S) * (B * 5 + C)
$$&lt;/p&gt;</description>
    </item>
    <item>
      <title>YOLO 目标检测算法学习笔记（四）</title>
      <link>https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</link>
      <pubDate>Sun, 16 Jun 2024 11:20:31 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</guid>
      <description>&lt;h2 id=&#34;yolo-v2&#34;&gt;YOLO-V2&lt;/h2&gt;&lt;p&gt;下图为YOLO-V2相较于YOLO-V1的改进点，以及改进后 mAP 值的变化。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;YOLO-V2&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2023/08/30/CmvK9W1bdpauPtR.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;batch-normalization&#34;&gt;Batch Normalization&lt;/h2&gt;&lt;p&gt;V2 版本舍弃了 Dropout，不再有全连接层（Fully connected layers，FC）。每次卷积后都加入 Batch Normalization，对网络的每一层的输入都进行归一化，使收敛更容易。&lt;/p&gt;
&lt;p&gt;经过 Batch Normalization 处理后的网络会提升2%的mAP值。&lt;/p&gt;
&lt;p&gt;从现在的角度来看，Batch Normatlization 已经称为卷积神经网络处理必备处理了。&lt;/p&gt;
&lt;h2 id=&#34;high-resolution-classifier&#34;&gt;High Resolution Classifier&lt;/h2&gt;&lt;p&gt;High Resolution Classifier，即高分辨率分类器，高分辨率分类器。&lt;/p&gt;
&lt;p&gt;在 V1 版本，训练时用的是224*224分辨率的图片，测试时又使用448*448分辨率的图片，这会导致模型“水土不服”。&lt;/p&gt;
&lt;p&gt;针对这一问题，V2 版本在模型训练时额外进行了10次448*448的微调。经过微调后，V2 版本的 mAP 值提升了约4%。&lt;/p&gt;
&lt;h2 id=&#34;convolutional&#34;&gt;Convolutional&lt;/h2&gt;</description>
    </item>
    <item>
      <title>YOLO 目标检测算法学习笔记（一）</title>
      <link>https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
      <pubDate>Sun, 16 Jun 2024 11:20:31 +0800</pubDate>
      <guid>https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
      <description>&lt;h2 id=&#34;深度学习经典检测方法&#34;&gt;深度学习经典检测方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;one-stage（单阶段）：YOLO系列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;two-stage（双阶段）：Faster-Rcnn、Mask-Rcnn系列&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;深度学习经典检测方法&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2023/08/28/mX5t61TwqAR3nHB.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Faster-Rcnn：物体检测开山之作。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;one-stage-单阶段检测&#34;&gt;one-stage 单阶段检测&lt;/h2&gt;&lt;p&gt;优势：速度快，适合做实时检测任务。&lt;/p&gt;
&lt;p&gt;缺点：效果不佳。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;one-stage 单阶段检测&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2023/08/28/rFkyvMngZcAJPDo.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;目标检测的两个主要指标：mAP和FPS。&lt;/p&gt;
&lt;p&gt;mAP：检测效果的综合指标。（mAP值越大效果越好）&lt;/p&gt;
&lt;h2 id=&#34;two-stage-双阶段检测&#34;&gt;two-stage 双阶段检测&lt;/h2&gt;&lt;p&gt;优势：效果较好。&lt;/p&gt;
&lt;p&gt;缺点：速度较慢、不适合用于视频流的实时检测。&lt;/p&gt;
&lt;p&gt;Mask-Rcnn是一个非常实用的通用框架（建议了解）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;two-stage 双阶段检测&#34; loading=&#34;lazy&#34; src=&#34;https://s2.loli.net/2023/08/28/qcefLK8pBjFnsMa.png&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
