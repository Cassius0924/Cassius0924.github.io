<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cassius0924 的博客</title><meta name=keywords content><meta name=description content="语法高亮是指在IDE或编辑器中，对文本进行分词，即将文本拆解为 Token（标记），每个 Token 都有对应的名称（作用域）进行标记。再配合主题样式规则，对不同名称的 Token 的进行主题化，以提高代码的可读性。

程序员离不开语法高亮，就像作家离不开标点符号一样。（你可以代入一下使用 txt 文本编辑器写代码的场景）
语法高亮由两个部分组成：

分词（Tokenization）：将文本拆解为一系列 Token。
主题化（Theming）：对 Token 进行样式渲染，如字体颜色、背景色、加粗等。

我们以 JSON 的语法为例，简单介绍一下语法高亮的过程。
首先分词引擎会对 JSON 文本进行分词，下图是将 JSON 文本进行分词后的结果，其中每个矩形所包括的文本都是一个 Token，每个 Token 都有一个作用域名称，例如 null 对应的是 constant.language.json 作用域。

然后主题化引擎会根据 Token 的作用域名称，对 Token 进行样式渲染，例如将 constant.language.json 作用域映射为蓝色不加粗字体。那么 null 就会被渲染为蓝色不加粗字体。

2. 分词的实现方式目前主流的分词实现方式大致有有以下三种：

基于正则表达式的分词：Textmate
基于词法分析的分词：Highlight.js
基于语法树的分词：Tree-sitter
(如果有其他，欢迎补充)

本文只讨论 Textmate 的语法高亮规则编写。
Textmate 原是 MacOS 下的一款文本编辑器，其语法高亮规则是基于正则表达式的，但由于其规则简单易懂，且支持多种语言，因此被广泛应用于各种编辑器和IDE中，如 VSCode、Sublime Text 等。JetBrains 的 IDE 也集成了 Textmate Bundle 插件，可以直接导入 Textmate 的语法高亮规则。
"><meta name=author content><link rel=canonical href=https://blog.cassdev.com/posts/%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/><link crossorigin=anonymous href=/assets/css/stylesheet.4f5249ac184c033613d94c5267209e90161d3a93365c2feb0ad3960a4bbb6393.css integrity="sha256-T1JJrBhMAzYT2UxSZyCekBYdOpM2XC/rCtOWCku7Y5M=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.cassdev.com/posts/%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/posts/%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="Cassius0924 的博客"><meta property="og:description" content="语法高亮是指在IDE或编辑器中，对文本进行分词，即将文本拆解为 Token（标记），每个 Token 都有对应的名称（作用域）进行标记。再配合主题样式规则，对不同名称的 Token 的进行主题化，以提高代码的可读性。
程序员离不开语法高亮，就像作家离不开标点符号一样。（你可以代入一下使用 txt 文本编辑器写代码的场景）
语法高亮由两个部分组成：
分词（Tokenization）：将文本拆解为一系列 Token。 主题化（Theming）：对 Token 进行样式渲染，如字体颜色、背景色、加粗等。 我们以 JSON 的语法为例，简单介绍一下语法高亮的过程。
首先分词引擎会对 JSON 文本进行分词，下图是将 JSON 文本进行分词后的结果，其中每个矩形所包括的文本都是一个 Token，每个 Token 都有一个作用域名称，例如 null 对应的是 constant.language.json 作用域。
然后主题化引擎会根据 Token 的作用域名称，对 Token 进行样式渲染，例如将 constant.language.json 作用域映射为蓝色不加粗字体。那么 null 就会被渲染为蓝色不加粗字体。
2. 分词的实现方式目前主流的分词实现方式大致有有以下三种：
基于正则表达式的分词：Textmate 基于词法分析的分词：Highlight.js 基于语法树的分词：Tree-sitter (如果有其他，欢迎补充) 本文只讨论 Textmate 的语法高亮规则编写。
Textmate 原是 MacOS 下的一款文本编辑器，其语法高亮规则是基于正则表达式的，但由于其规则简单易懂，且支持多种语言，因此被广泛应用于各种编辑器和IDE中，如 VSCode、Sublime Text 等。JetBrains 的 IDE 也集成了 Textmate Bundle 插件，可以直接导入 Textmate 的语法高亮规则。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="语法高亮是指在IDE或编辑器中，对文本进行分词，即将文本拆解为 Token（标记），每个 Token 都有对应的名称（作用域）进行标记。再配合主题样式规则，对不同名称的 Token 的进行主题化，以提高代码的可读性。

程序员离不开语法高亮，就像作家离不开标点符号一样。（你可以代入一下使用 txt 文本编辑器写代码的场景）
语法高亮由两个部分组成：

分词（Tokenization）：将文本拆解为一系列 Token。
主题化（Theming）：对 Token 进行样式渲染，如字体颜色、背景色、加粗等。

我们以 JSON 的语法为例，简单介绍一下语法高亮的过程。
首先分词引擎会对 JSON 文本进行分词，下图是将 JSON 文本进行分词后的结果，其中每个矩形所包括的文本都是一个 Token，每个 Token 都有一个作用域名称，例如 null 对应的是 constant.language.json 作用域。

然后主题化引擎会根据 Token 的作用域名称，对 Token 进行样式渲染，例如将 constant.language.json 作用域映射为蓝色不加粗字体。那么 null 就会被渲染为蓝色不加粗字体。

2. 分词的实现方式目前主流的分词实现方式大致有有以下三种：

基于正则表达式的分词：Textmate
基于词法分析的分词：Highlight.js
基于语法树的分词：Tree-sitter
(如果有其他，欢迎补充)

本文只讨论 Textmate 的语法高亮规则编写。
Textmate 原是 MacOS 下的一款文本编辑器，其语法高亮规则是基于正则表达式的，但由于其规则简单易懂，且支持多种语言，因此被广泛应用于各种编辑器和IDE中，如 VSCode、Sublime Text 等。JetBrains 的 IDE 也集成了 Textmate Bundle 插件，可以直接导入 Textmate 的语法高亮规则。
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.cassdev.com/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://blog.cassdev.com/posts/%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"语法高亮是指在IDE或编辑器中，对文本进行分词，即将文本拆解为 Token（标记），每个 Token 都有对应的名称（作用域）进行标记。再配合主题样式规则，对不同名称的 Token 的进行主题化，以提高代码的可读性。\n程序员离不开语法高亮，就像作家离不开标点符号一样。（你可以代入一下使用 txt 文本编辑器写代码的场景）\n语法高亮由两个部分组成：\n分词（Tokenization）：将文本拆解为一系列 Token。 主题化（Theming）：对 Token 进行样式渲染，如字体颜色、背景色、加粗等。 我们以 JSON 的语法为例，简单介绍一下语法高亮的过程。\n首先分词引擎会对 JSON 文本进行分词，下图是将 JSON 文本进行分词后的结果，其中每个矩形所包括的文本都是一个 Token，每个 Token 都有一个作用域名称，例如 null 对应的是 constant.language.json 作用域。\n然后主题化引擎会根据 Token 的作用域名称，对 Token 进行样式渲染，例如将 constant.language.json 作用域映射为蓝色不加粗字体。那么 null 就会被渲染为蓝色不加粗字体。\n2. 分词的实现方式目前主流的分词实现方式大致有有以下三种：\n基于正则表达式的分词：Textmate 基于词法分析的分词：Highlight.js 基于语法树的分词：Tree-sitter (如果有其他，欢迎补充) 本文只讨论 Textmate 的语法高亮规则编写。\nTextmate 原是 MacOS 下的一款文本编辑器，其语法高亮规则是基于正则表达式的，但由于其规则简单易懂，且支持多种语言，因此被广泛应用于各种编辑器和IDE中，如 VSCode、Sublime Text 等。JetBrains 的 IDE 也集成了 Textmate Bundle 插件，可以直接导入 Textmate 的语法高亮规则。\n","keywords":[],"articleBody":"语法高亮是指在IDE或编辑器中，对文本进行分词，即将文本拆解为 Token（标记），每个 Token 都有对应的名称（作用域）进行标记。再配合主题样式规则，对不同名称的 Token 的进行主题化，以提高代码的可读性。\n程序员离不开语法高亮，就像作家离不开标点符号一样。（你可以代入一下使用 txt 文本编辑器写代码的场景）\n语法高亮由两个部分组成：\n分词（Tokenization）：将文本拆解为一系列 Token。 主题化（Theming）：对 Token 进行样式渲染，如字体颜色、背景色、加粗等。 我们以 JSON 的语法为例，简单介绍一下语法高亮的过程。\n首先分词引擎会对 JSON 文本进行分词，下图是将 JSON 文本进行分词后的结果，其中每个矩形所包括的文本都是一个 Token，每个 Token 都有一个作用域名称，例如 null 对应的是 constant.language.json 作用域。\n然后主题化引擎会根据 Token 的作用域名称，对 Token 进行样式渲染，例如将 constant.language.json 作用域映射为蓝色不加粗字体。那么 null 就会被渲染为蓝色不加粗字体。\n2. 分词的实现方式目前主流的分词实现方式大致有有以下三种：\n基于正则表达式的分词：Textmate 基于词法分析的分词：Highlight.js 基于语法树的分词：Tree-sitter (如果有其他，欢迎补充) 本文只讨论 Textmate 的语法高亮规则编写。\nTextmate 原是 MacOS 下的一款文本编辑器，其语法高亮规则是基于正则表达式的，但由于其规则简单易懂，且支持多种语言，因此被广泛应用于各种编辑器和IDE中，如 VSCode、Sublime Text 等。JetBrains 的 IDE 也集成了 Textmate Bundle 插件，可以直接导入 Textmate 的语法高亮规则。\n3. 语法高亮规则的编写VSCode 官方有一套关于编写 Textmate 语法高亮规则的文档，包含分词和主题化，详见：Syntax Highlight Guide。\n本文不会介绍如何编写 Textmate 分词规则，只会浅析其工作原理。\n4. Textmate 的分词规则运行机制Textmate 的语法高亮规则是基于正则表达式的，Textmate 的语法高亮引擎会根据我们定义好的语法高亮规则对文本进行分词。分词的过程是从文本的开头开始，逐个字符地匹配规则，直到匹配到一个规则为止，然后将匹配到的字符标记为某种语法类型，然后继续匹配下一个字符，直到匹配到文本的末尾。\n以下面的语法高亮规则为例：\n{ \"patterns\": [ { \"match\": \"\\\\bhello\\\\b\", \"name\": \"keyword.hello.jtgo\" }, { \"match\": \"\\\\w+\", \"name\": \"string.word.jtgo\" }, { \"begin\": \"{{\", \"beginCaptures\": { \"0\": { \"name\": \"expression.begin.jtgo\" } }, \"end\": \"}}\", \"endCaptures\": { \"0\": { \"name\": \"expression.end.jtgo\" } }, \"name\": \"expression.jtgo\", \"patterns\": [ { \"match\": \"\\\\b(len|panic|print|println|min|max)\\\\b(?=\\\\()\", \"name\": \"keyword.builtin-function.name.jtgo\" } ] } ] } patterns 列表中的每一个 item 都是一个规则，在 Textmate 中被称为 Rule Key。\n当 Textmate 引擎匹配到 hello 时，会将其标记为 keyword.hello 作用域。 当 Textmate 引擎匹配到 \\\\w+，也就是任意单词字符时，会将其标记为 string.word.jtgo 作用域。 当 Textmate 引擎匹配到 {{ 时，接着会继续匹配直到匹配到 }}，并且将 {{ 和 }} 之间的内容使用子规则（嵌套规则）进行匹配。这个规则的作用域映射如下： {{ -\u003e expression.begin.jtgo }} -\u003e expression.end.jtgo {{ print(\"OK\") }} -\u003e expression.jtgo print -\u003e keyword.builtin-function.name.jtgo 对于 {{ 和 }} 之间的内容，当 Textmate 引擎匹配到 \\\\b(len|panic|print|println|min|max)\\\\b(?=\\\\() 时，也就是 ( 之前的 len、panic、print、println、min 或 max 时，会将其标记为 keyword.builtin-function.name.jtgo 作用域。 例如下面的文本，经过 Textmate 引擎的分词后，会被标记为如下的 Token：\n# hello world! {{ print(\"OK\") }} 4.1 JSON 的分词规则直接进阶到 JSON 的分词规则，详细规则内容以 VSCode 的内置 JSON 分词规则为例：\n整个文件内容默认会被最外层的 scopeName 匹配，既所有的内容都会被标记上 source.json 作用域。 整个 JSON 文件的作用域是 source.json\n引擎会将第一个字符从最外层的 patterns 数组开始匹配，从上至下按顺序匹配每一个规则，直到匹配到一个规则为止。 JSON 的最外层 patterns 只有一个规则 value 规则，第一个字符会使用 value 的规则进行匹配。\n对于每个规则，如果规则中未包含 match 或 begin 和 end，则会直接递归匹配 patterns 中的规则。反之分为两种情况： 只有 match 字段，会尝试匹配当前规则的 match 字段，如果匹配成功，则将匹配到的字符标记为 name 字段和 captures 字段中的作用域，并继续匹配下一个字符。若匹配失败，则会跳出规则，回到 patterns 中继续匹配下一个规则。 只有 begin 和 end 字段，会尝试匹配 begin 规则，匹配成功时会继续将匹配到字符标记为 beginCaptures 字段中的作用域（end 字段同理），如果规则中包含 patterns 字段，则下一个字符会使用 patterns 中的规则进行匹配，直到匹配到 end 规则为止。如果规则中未包含 patterns 字段，则会直接匹配 end 字段。匹配到 end 字段后，会将当前规则匹配到所有的字符都标记上 name 作用域，begin 所匹配字符和 end 所匹配字符之间的内容会额外标记上 contentName 作用域。最后会跳出当前递归规则，回到上一层规则继续匹配。 JSON 的 value 规则内只有一个 patterns 字段，则会直接递归匹配 patterns 中的规则。\nJSON 文件的第一个字符是 {，引擎会尝试匹配 constant 规则，其中只有一个 match 规则，但匹配失败，所以会跳出 constant 规则，回到 value 的 patterns 规则中继续匹配下一个规则。\n以此类推，number、string 和 array 规则都会匹配失败。\n接着会匹配 object 规则， { 字符会匹配成功其 begin 字段规则，接着下一个字符会使用 object 规则中的 patterns 规则进行匹配。\n若未匹配到 patterns 中的任何规则，则会继续匹配下一个字符。 下面是 Textmate 解析 JSON 内容过程一步步拆解后的示意图：\n5. 附录 正则表达式温习\n","wordCount":"325","inLanguage":"zh","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.cassdev.com/posts/%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"},"publisher":{"@type":"Organization","name":"Cassius0924 的博客","logo":{"@type":"ImageObject","url":"https://blog.cassdev.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title="Cassius0924 的博客"><span>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/gallery/ title=图库><span>图库</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.cassdev.com/>主页</a>&nbsp;»&nbsp;<a href=https://blog.cassdev.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>2 分钟</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#2-%e5%88%86%e8%af%8d%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f aria-label="2. 分词的实现方式">2. 分词的实现方式</a></li><li><a href=#3-%e8%af%ad%e6%b3%95%e9%ab%98%e4%ba%ae%e8%a7%84%e5%88%99%e7%9a%84%e7%bc%96%e5%86%99 aria-label="3. 语法高亮规则的编写">3. 语法高亮规则的编写</a></li><li><a href=#4-textmate-%e7%9a%84%e5%88%86%e8%af%8d%e8%a7%84%e5%88%99%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6 aria-label="4. Textmate 的分词规则运行机制">4. Textmate 的分词规则运行机制</a><ul><li><a href=#41-json-%e7%9a%84%e5%88%86%e8%af%8d%e8%a7%84%e5%88%99 aria-label="4.1 JSON 的分词规则">4.1 JSON 的分词规则</a></li></ul></li><li><a href=#5-%e9%99%84%e5%bd%95 aria-label="5. 附录">5. 附录</a></li></ul></div></details></div><div class=post-content><p>语法高亮是指在IDE或编辑器中，对文本进行<strong>分词</strong>，即将文本拆解为 Token（标记），每个 Token 都有对应的名称（作用域）进行标记。再配合主题样式规则，对不同名称的 Token 的进行<strong>主题化</strong>，以提高代码的可读性。</p><blockquote><p>程序员离不开语法高亮，就像作家离不开标点符号一样。（你可以代入一下使用 txt 文本编辑器写代码的场景）</p></blockquote><p>语法高亮由两个部分组成：</p><ul><li>分词（Tokenization）：将文本拆解为一系列 Token。</li><li>主题化（Theming）：对 Token 进行样式渲染，如字体颜色、背景色、加粗等。</li></ul><p>我们以 JSON 的语法为例，简单介绍一下语法高亮的过程。</p><p>首先分词引擎会对 JSON 文本进行分词，下图是将 JSON 文本进行分词后的结果，其中每个矩形所包括的文本都是一个 Token，每个 Token 都有一个作用域名称，例如 <code>null</code> 对应的是 <code>constant.language.json</code> 作用域。</p><p><img alt="alt text" loading=lazy src=https://s2.loli.net/2025/03/16/mQydfgXDYCuKPLo.png></p><p>然后主题化引擎会根据 Token 的作用域名称，对 Token 进行样式渲染，例如将 <code>constant.language.json</code> 作用域映射为蓝色不加粗字体。那么 <code>null</code> 就会被渲染为蓝色不加粗字体。</p><p><img alt="alt text" loading=lazy src=https://s2.loli.net/2025/03/16/cho7NWLtem1Evgf.png></p><h2 id=2-分词的实现方式>2. 分词的实现方式<a hidden class=anchor aria-hidden=true href=#2-分词的实现方式>#</a></h2><p>目前主流的分词实现方式大致有有以下三种：</p><ul><li>基于<strong>正则表达式</strong>的分词：Textmate</li><li>基于<strong>词法分析</strong>的分词：Highlight.js</li><li>基于<strong>语法树</strong>的分词：Tree-sitter</li><li>(如果有其他，欢迎补充)</li></ul><p>本文只讨论 Textmate 的语法高亮规则编写。</p><p>Textmate 原是 MacOS 下的一款文本编辑器，其语法高亮规则是基于正则表达式的，但由于其规则简单易懂，且支持多种语言，因此被广泛应用于各种编辑器和IDE中，如 VSCode、Sublime Text 等。JetBrains 的 IDE 也集成了 Textmate Bundle 插件，可以直接导入 Textmate 的语法高亮规则。</p><p><img alt="alt text" loading=lazy src=CleanShot%202025-03-12%20at%2017.23.49@2x.png></p><h2 id=3-语法高亮规则的编写>3. 语法高亮规则的编写<a hidden class=anchor aria-hidden=true href=#3-语法高亮规则的编写>#</a></h2><p>VSCode 官方有一套关于编写 Textmate 语法高亮规则的文档，包含分词和主题化，详见：<a href=https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide>Syntax Highlight Guide</a>。</p><p>本文不会介绍如何编写 Textmate 分词规则，只会浅析其工作原理。</p><h2 id=4-textmate-的分词规则运行机制>4. Textmate 的分词规则运行机制<a hidden class=anchor aria-hidden=true href=#4-textmate-的分词规则运行机制>#</a></h2><p>Textmate 的语法高亮规则是基于正则表达式的，Textmate 的语法高亮引擎会根据我们定义好的语法高亮规则对文本进行分词。分词的过程是从文本的开头开始，逐个字符地匹配规则，直到匹配到一个规则为止，然后将匹配到的字符标记为某种语法类型，然后继续匹配下一个字符，直到匹配到文本的末尾。</p><p>以下面的语法高亮规则为例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;patterns&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;match&#34;</span><span class=p>:</span> <span class=s2>&#34;\\bhello\\b&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;keyword.hello.jtgo&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;match&#34;</span><span class=p>:</span> <span class=s2>&#34;\\w+&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;string.word.jtgo&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;begin&#34;</span><span class=p>:</span> <span class=s2>&#34;{{&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;beginCaptures&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;0&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;expression.begin.jtgo&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;end&#34;</span><span class=p>:</span> <span class=s2>&#34;}}&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;endCaptures&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;0&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;expression.end.jtgo&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;expression.jtgo&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;patterns&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;match&#34;</span><span class=p>:</span> <span class=s2>&#34;\\b(len|panic|print|println|min|max)\\b(?=\\()&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;keyword.builtin-function.name.jtgo&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>patterns</code> 列表中的每一个 item 都是一个规则，在 Textmate 中被称为 <code>Rule Key</code>。</p><ul><li>当 Textmate 引擎匹配到 <code>hello</code> 时，会将其标记为 <code>keyword.hello</code> 作用域。</li><li>当 Textmate 引擎匹配到 <code>\\w+</code>，也就是任意单词字符时，会将其标记为 <code>string.word.jtgo</code> 作用域。</li><li>当 Textmate 引擎匹配到 <code>{{</code> 时，接着会继续匹配直到匹配到 <code>}}</code>，并且将 <code>{{</code> 和 <code>}}</code> 之间的内容使用子规则（嵌套规则）进行匹配。这个规则的作用域映射如下：<ul><li><code>{{</code> -> <code>expression.begin.jtgo</code></li><li><code>}}</code> -> <code>expression.end.jtgo</code></li><li><code>{{ print("OK") }}</code> -> <code>expression.jtgo</code></li><li><code>print</code> -> <code>keyword.builtin-function.name.jtgo</code></li></ul></li><li>对于 <code>{{</code> 和 <code>}}</code> 之间的内容，当 Textmate 引擎匹配到 <code>\\b(len|panic|print|println|min|max)\\b(?=\\()</code> 时，也就是 <code>(</code> 之前的 <code>len</code>、<code>panic</code>、<code>print</code>、<code>println</code>、<code>min</code> 或 <code>max</code> 时，会将其标记为 <code>keyword.builtin-function.name.jtgo</code> 作用域。</li></ul><p>例如下面的文本，经过 Textmate 引擎的分词后，会被标记为如下的 Token：</p><pre tabindex=0><code># hello world! {{ print(&#34;OK&#34;) }}
</code></pre><p><img alt="alt text" loading=lazy src=https://s2.loli.net/2025/03/16/2cLsUR8WnorwI19.png></p><h3 id=41-json-的分词规则>4.1 JSON 的分词规则<a hidden class=anchor aria-hidden=true href=#41-json-的分词规则>#</a></h3><p>直接进阶到 JSON 的分词规则，详细规则内容以 <a href=https://github.com/microsoft/vscode/blob/main/extensions/json/syntaxes/JSON.tmLanguage.json>VSCode 的内置 JSON 分词规则</a>为例：</p><ul><li>整个文件内容默认会被最外层的 <code>scopeName</code> 匹配，既所有的内容都会被标记上 <code>source.json</code> 作用域。</li></ul><blockquote><p>整个 JSON 文件的作用域是 <code>source.json</code></p></blockquote><ul><li>引擎会将第一个字符从最外层的 <code>patterns</code> 数组开始匹配，从上至下按顺序匹配每一个规则，直到匹配到一个规则为止。</li></ul><blockquote><p>JSON 的最外层 <code>patterns</code> 只有一个规则 <code>value</code> 规则，第一个字符会使用 <code>value</code> 的规则进行匹配。</p></blockquote><ul><li>对于每个规则，如果规则中未包含 <code>match</code> 或 <code>begin</code> 和 <code>end</code>，则会直接递归匹配 <code>patterns</code> 中的规则。反之分为两种情况：<ul><li>只有 <code>match</code> 字段，会尝试匹配当前规则的 <code>match</code> 字段，如果匹配成功，则将匹配到的字符标记为 <code>name</code> 字段和 <code>captures</code> 字段中的作用域，并继续匹配下一个字符。若匹配失败，则会跳出规则，回到 <code>patterns</code> 中继续匹配下一个规则。</li><li>只有 <code>begin</code> 和 <code>end</code> 字段，会尝试匹配 <code>begin</code> 规则，匹配成功时会继续将匹配到字符标记为 <code>beginCaptures</code> 字段中的作用域（<code>end</code> 字段同理），如果规则中包含 <code>patterns</code> 字段，则下一个字符会使用 <code>patterns</code> 中的规则进行匹配，直到匹配到 <code>end</code> 规则为止。如果规则中未包含 <code>patterns</code> 字段，则会直接匹配 <code>end</code> 字段。匹配到 <code>end</code> 字段后，会将当前规则匹配到所有的字符都标记上 <code>name</code> 作用域，<code>begin</code> 所匹配字符和 <code>end</code> 所匹配字符之间的内容会额外标记上 <code>contentName</code> 作用域。最后会跳出当前递归规则，回到上一层规则继续匹配。</li></ul></li></ul><blockquote><p>JSON 的 <code>value</code> 规则内只有一个 <code>patterns</code> 字段，则会直接递归匹配 <code>patterns</code> 中的规则。</p><p>JSON 文件的第一个字符是 <code>{</code>，引擎会尝试匹配 <code>constant</code> 规则，其中只有一个 <code>match</code> 规则，但匹配失败，所以会跳出 <code>constant</code> 规则，回到 <code>value</code> 的 <code>patterns</code> 规则中继续匹配下一个规则。</p><p>以此类推，<code>number</code>、<code>string</code> 和 <code>array</code> 规则都会匹配失败。</p><p>接着会匹配 <code>object</code> 规则， <code>{</code> 字符会匹配成功其 <code>begin</code> 字段规则，接着下一个字符会使用 <code>object</code> 规则中的 <code>patterns</code> 规则进行匹配。</p></blockquote><ul><li>若未匹配到 <code>patterns</code> 中的任何规则，则会继续匹配下一个字符。</li></ul><p>下面是 Textmate 解析 JSON 内容过程一步步拆解后的示意图：</p><p><img alt="alt text" loading=lazy src=https://s2.loli.net/2025/03/16/If5ad4oylSNgQBO.png></p><h2 id=5-附录>5. 附录<a hidden class=anchor aria-hidden=true href=#5-附录>#</a></h2><blockquote><p><strong>正则表达式温习</strong></p><p><img alt="alt text" loading=lazy src=https://s2.loli.net/2025/03/16/BO7wjhvunEAQbJe.png></p></blockquote></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>