<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ 多态学习笔记 | Cassius0924 的博客</title><meta name=keywords content="C++,Polymorphism,OOP,Notes"><meta name=description content="C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。
C++ 的多态性主要有两种实现方式：静态多态和动态多态。


静态多态：通过函数重载和模板实现。


动态多态：通过虚函数实现。


静态多态函数重载函数重载是指在同一个作用域内，可以定义 多个名称相同 但 参数列表不同 的函数。注意，不能用 返回值类型 来区分重载函数。
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

double add(double a, double b, double c) {
    return a + b + c;
}

            
    
      
        笔记
      
      
        编译过程"><meta name=author content="Cassius0924"><link rel=canonical href=https://blog.cassdev.com/posts/c++-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.4f5249ac184c033613d94c5267209e90161d3a93365c2feb0ad3960a4bbb6393.css integrity="sha256-T1JJrBhMAzYT2UxSZyCekBYdOpM2XC/rCtOWCku7Y5M=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.cassdev.com/posts/c++-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/posts/c++-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="C++ 多态学习笔记"><meta property="og:description" content="C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。
C++ 的多态性主要有两种实现方式：静态多态和动态多态。
静态多态：通过函数重载和模板实现。
动态多态：通过虚函数实现。
静态多态函数重载函数重载是指在同一个作用域内，可以定义 多个名称相同 但 参数列表不同 的函数。注意，不能用 返回值类型 来区分重载函数。
int add(int a, int b) { return a + b; } double add(double a, double b) { return a + b; } double add(double a, double b, double c) { return a + b + c; } 笔记 编译过程"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-27T22:52:10+08:00"><meta property="article:modified_time" content="2024-06-27T22:52:10+08:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Polymorphism"><meta property="article:tag" content="OOP"><meta property="article:tag" content="Notes"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ 多态学习笔记"><meta name=twitter:description content="C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。
C++ 的多态性主要有两种实现方式：静态多态和动态多态。


静态多态：通过函数重载和模板实现。


动态多态：通过虚函数实现。


静态多态函数重载函数重载是指在同一个作用域内，可以定义 多个名称相同 但 参数列表不同 的函数。注意，不能用 返回值类型 来区分重载函数。
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

double add(double a, double b, double c) {
    return a + b + c;
}

            
    
      
        笔记
      
      
        编译过程"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.cassdev.com/posts/"},{"@type":"ListItem","position":2,"name":"C++ 多态学习笔记","item":"https://blog.cassdev.com/posts/c++-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 多态学习笔记","name":"C\u002b\u002b 多态学习笔记","description":"C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。\nC++ 的多态性主要有两种实现方式：静态多态和动态多态。\n静态多态：通过函数重载和模板实现。\n动态多态：通过虚函数实现。\n静态多态函数重载函数重载是指在同一个作用域内，可以定义 多个名称相同 但 参数列表不同 的函数。注意，不能用 返回值类型 来区分重载函数。\nint add(int a, int b) { return a + b; } double add(double a, double b) { return a + b; } double add(double a, double b, double c) { return a + b + c; } 笔记 编译过程\n","keywords":["C++","Polymorphism","OOP","Notes"],"articleBody":"C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。\nC++ 的多态性主要有两种实现方式：静态多态和动态多态。\n静态多态：通过函数重载和模板实现。\n动态多态：通过虚函数实现。\n静态多态函数重载函数重载是指在同一个作用域内，可以定义 多个名称相同 但 参数列表不同 的函数。注意，不能用 返回值类型 来区分重载函数。\nint add(int a, int b) { return a + b; } double add(double a, double b) { return a + b; } double add(double a, double b, double c) { return a + b + c; } 笔记 编译过程\n预处理：将源文件中的头文件展开，处理宏定义，删除注释等；\n对应命令：g++ -E main.cpp -o main.i；\n编译：进行词法分析、语法分析、语义分析，接着 生成汇编代码 ；\n词法分析：分析源代码中的关键字、标识符、常量等是否合法；\n语法分析：分析源代码中的语法结构是否合法；\n语义分析：分析源代码中的语义是否合法；\n对应命令：g++ -S main.i -o main.s；\n汇编：将 汇编代码 转换为 目标文件 ，即将汇编代码翻译成机器指令；\n对应命令：g++ -c main.s -o main.o；\n链接：将 目标文件 和 库文件 链接成 可执行文件 ；\n静态链接：将库文件的代码和目标文件的代码合并成一个可执行文件；\n动态链接：将库文件的代码和目标文件的代码分开，运行时再动态链接；\n对应命令：g++ main.o -o main。\n函数重载的原理是通过 函数名修饰 实现的，即在编译阶段，编译器会根据函数名和参数列表生成一个唯一的函数名。\n可以通过 objdump -t main.o 命令查看函数名修饰后的函数名。一般函数名格式为 _ZN + 类名长度 + 类名 + 函数名长度 + 函数名 + E + 参数类型首字母。\nclass A { public: void func(int a) { // 函数名修饰后：_ZN1A4funcEi std::cout \u003c\u003c \"int: \" \u003c\u003c a \u003c\u003c std::endl; } void func(double a, double b) { // 函数名修饰后：_ZN1A4funcEdd std::cout \u003c\u003c \"double: \" \u003c\u003c a \u003c\u003c \" \" \u003c\u003c b \u003c\u003c std::endl; } }; int main() { // ... } 模板模板也是一种静态多态。\n动态多态虚函数C++ 的多态性是通过虚函数实现的，虚函数是在基类中声明的，子类可以重写基类的虚函数，从而实现 基类指针指向子类对象 ，调用子类对象的成员函数。\n虚函数表虚函数表（vtable）是一个存储 虚函数地址 的一维数组，每个类都有一个虚函数表，虚函数表中存储的是虚函数的地址。\n虚函数表的创建时机是在 编译阶段 ，存放于 只读数据段（.rodata） 中，是一个全局变量，每个类的虚函数表都是唯一的，这个类的所有实例都会共享这个虚函数表。\n虚函数表指针虚函数表指针（vptr）是一个指向虚函数表的指针，是一个 隐藏的成员变量 ，存在于每个类的对象中，指向这个类的虚函数表。\n虚函数表指针是在构造函数中初始化的，指向这个类的虚函数表，当调用虚函数时，会通过这个虚函数表指针找到虚函数表，再找到虚函数的地址，最后调用虚函数。\n编译器任务如果一个类中有虚函数（用 virtual 关键字修饰的函数）：\n那么编译器就会为这个类生成一个 vtable ，存放这个类的虚函数地址。\n编译器还会在这个类的对象中添加一个 vptr，用于指向这个类的 vtable。\n编译器还会在这个类的 构造函数 插入初始化 vptr 的代码，指向这个类的 vtable。\n编译器还会在这个类的 析构函数 插入清空 vptr 的代码。\n对象实例的内存布局如下：\n继承下如果一个类继承了另一个类，在编译阶段，子类的 vtable 赋值流程如下：\n先将父类的 vtable 复制到子类的 vtable 中。\n再查找子类中 新的虚函数 ，如果有新的虚函数，就将新的虚函数地址 添加 到子类的 vtable 中。\n最后查找子类中 重写的虚函数 ，如果有重写的虚函数，就将重写的虚函数地址 覆盖 父类的虚函数地址。\n因此如果子类中没有新的虚函数和重写的虚函数，那么子类的 vtable 就和父类的 vtable 一样。\n","wordCount":"224","inLanguage":"zh","datePublished":"2024-06-27T22:52:10+08:00","dateModified":"2024-06-27T22:52:10+08:00","author":{"@type":"Person","name":"Cassius0924"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.cassdev.com/posts/c++-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"Cassius0924 的博客","logo":{"@type":"ImageObject","url":"https://blog.cassdev.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title="Cassius0924 的博客"><span>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.cassdev.com/>主页</a>&nbsp;»&nbsp;<a href=https://blog.cassdev.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">C++ 多态学习笔记</h1><div class=post-meta><span title='2024-06-27 22:52:10 +0800 +0800'>2024年06月27日</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;Cassius0924</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e9%9d%99%e6%80%81%e5%a4%9a%e6%80%81 aria-label=静态多态>静态多态</a><ul><li><a href=#%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd aria-label=函数重载>函数重载</a></li><li><a href=#%e6%a8%a1%e6%9d%bf aria-label=模板>模板</a></li></ul></li><li><a href=#%e5%8a%a8%e6%80%81%e5%a4%9a%e6%80%81 aria-label=动态多态>动态多态</a><ul><li><a href=#%e8%99%9a%e5%87%bd%e6%95%b0 aria-label=虚函数>虚函数</a></li><li><a href=#%e8%99%9a%e5%87%bd%e6%95%b0%e8%a1%a8 aria-label=虚函数表>虚函数表</a></li><li><a href=#%e8%99%9a%e5%87%bd%e6%95%b0%e8%a1%a8%e6%8c%87%e9%92%88 aria-label=虚函数表指针>虚函数表指针</a></li><li><a href=#%e7%bc%96%e8%af%91%e5%99%a8%e4%bb%bb%e5%8a%a1 aria-label=编译器任务>编译器任务</a></li><li><a href=#%e7%bb%a7%e6%89%bf%e4%b8%8b aria-label=继承下>继承下</a></li></ul></li></ul></div></details></div><div class=post-content><p>C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。</p><p>C++ 的多态性主要有两种实现方式：静态多态和动态多态。</p><ul><li><p>静态多态：通过函数重载和模板实现。</p></li><li><p>动态多态：通过虚函数实现。</p></li></ul><h2 id=静态多态>静态多态</h2><h3 id=函数重载>函数重载<a hidden class=anchor aria-hidden=true href=#静态多态>#</a></h3><p>函数重载是指在同一个作用域内，可以定义 <strong>多个名称相同</strong> 但 <strong>参数列表不同</strong> 的函数。注意，不能用 <strong>返回值类型</strong> 来区分重载函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>add</span><span class=p>(</span><span class=kt>double</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>add</span><span class=p>(</span><span class=kt>double</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=n>b</span><span class=p>,</span> <span class=kt>double</span> <span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span> <span class=o>+</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><link rel=stylesheet href=/css/vendors/admonitions.4fd9a0b8ec8899f2ca952048d255a569f433f77dfb3f52f5bc87e7d65cdce449.css integrity="sha256-T9mguOyImfLKlSBI0lWlafQz9337P1L1vIfn1lzc5Ek=" crossorigin=anonymous><div class="admonition note"><div class=admonition-header><svg viewBox="0 0 576 512"><path d="M0 64C0 28.7 28.7.0 64 0H224v128c0 17.7 14.3 32 32 32h128v125.7l-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3.0-64-28.7-64-64V64zm384 64H256V0L384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9.0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6.0zM311.9 417 441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z"/></svg>
<span>笔记</span></div><div class=admonition-content><p><strong>编译过程</strong></p><ol><li><p>预处理：将源文件中的头文件展开，处理宏定义，删除注释等；</p><p>对应命令：<code>g++ -E main.cpp -o main.i</code>；</p></li><li><p>编译：进行词法分析、语法分析、语义分析，接着 <strong>生成汇编代码</strong> ；</p><ul><li><p>词法分析：分析源代码中的关键字、标识符、常量等是否合法；</p></li><li><p>语法分析：分析源代码中的语法结构是否合法；</p></li><li><p>语义分析：分析源代码中的语义是否合法；</p></li></ul><p>对应命令：<code>g++ -S main.i -o main.s</code>；</p></li><li><p>汇编：将 <strong>汇编代码</strong> 转换为 <strong>目标文件</strong> ，即将汇编代码翻译成机器指令；</p><p>对应命令：<code>g++ -c main.s -o main.o</code>；</p></li><li><p>链接：将 <strong>目标文件</strong> 和 <strong>库文件</strong> 链接成 <strong>可执行文件</strong> ；</p><ul><li><p>静态链接：将库文件的代码和目标文件的代码合并成一个可执行文件；</p></li><li><p>动态链接：将库文件的代码和目标文件的代码分开，运行时再动态链接；</p></li></ul><p>对应命令：<code>g++ main.o -o main</code>。</p></li></ol></div></div><p>函数重载的原理是通过 <strong>函数名修饰</strong> 实现的，即在编译阶段，编译器会根据函数名和参数列表生成一个唯一的函数名。</p><p>可以通过 <code>objdump -t main.o</code> 命令查看函数名修饰后的函数名。一般函数名格式为 <code>_ZN + 类名长度 + 类名 + 函数名长度 + 函数名 + E + 参数类型首字母</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// 函数名修饰后：_ZN1A4funcEi
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;int: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>double</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// 函数名修饰后：_ZN1A4funcEdd
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;double: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=模板>模板<a hidden class=anchor aria-hidden=true href=#模板>#</a></h3><p>模板也是一种静态多态。</p><h2 id=动态多态>动态多态</h2><h3 id=虚函数>虚函数<a hidden class=anchor aria-hidden=true href=#动态多态>#</a></h3><p>C++ 的多态性是通过虚函数实现的，虚函数是在基类中声明的，子类可以重写基类的虚函数，从而实现 <strong>基类指针指向子类对象</strong> ，调用子类对象的成员函数。</p><h3 id=虚函数表>虚函数表<a hidden class=anchor aria-hidden=true href=#虚函数表>#</a></h3><p>虚函数表（vtable）是一个存储 <strong>虚函数地址</strong> 的一维数组，每个类都有一个虚函数表，虚函数表中存储的是虚函数的地址。</p><p>虚函数表的创建时机是在 <strong>编译阶段</strong> ，存放于 <strong>只读数据段（.rodata）</strong> 中，是一个全局变量，每个类的虚函数表都是唯一的，这个类的所有实例都会共享这个虚函数表。</p><h3 id=虚函数表指针>虚函数表指针<a hidden class=anchor aria-hidden=true href=#虚函数表指针>#</a></h3><p>虚函数表指针（vptr）是一个指向虚函数表的指针，是一个 <strong>隐藏的成员变量</strong> ，存在于每个类的对象中，指向这个类的虚函数表。</p><p>虚函数表指针是在构造函数中初始化的，指向这个类的虚函数表，当调用虚函数时，会通过这个虚函数表指针找到虚函数表，再找到虚函数的地址，最后调用虚函数。</p><h3 id=编译器任务>编译器任务<a hidden class=anchor aria-hidden=true href=#编译器任务>#</a></h3><p>如果一个类中有虚函数（用 <code>virtual</code> 关键字修饰的函数）：</p><ul><li><p>那么编译器就会为这个类生成一个 <code>vtable</code> ，存放这个类的虚函数地址。</p></li><li><p>编译器还会在这个类的对象中添加一个 <code>vptr</code>，用于指向这个类的 <code>vtable</code>。</p></li><li><p>编译器还会在这个类的 <strong>构造函数</strong> 插入初始化 <code>vptr</code> 的代码，指向这个类的 <code>vtable</code>。</p></li><li><p>编译器还会在这个类的 <strong>析构函数</strong> 插入清空 <code>vptr</code> 的代码。</p></li></ul><p>对象实例的内存布局如下：</p><p><img alt="vtable and vptr" loading=lazy src=https://s2.loli.net/2024/06/27/nz4KVwOmDsT5WMq.png></p><h3 id=继承下>继承下<a hidden class=anchor aria-hidden=true href=#继承下>#</a></h3><p>如果一个类继承了另一个类，在编译阶段，子类的 <code>vtable</code> 赋值流程如下：</p><ol><li><p>先将父类的 <code>vtable</code> 复制到子类的 <code>vtable</code> 中。</p></li><li><p>再查找子类中 <strong>新的虚函数</strong> ，如果有新的虚函数，就将新的虚函数地址 <strong>添加</strong> 到子类的 <code>vtable</code> 中。</p></li><li><p>最后查找子类中 <strong>重写的虚函数</strong> ，如果有重写的虚函数，就将重写的虚函数地址 <strong>覆盖</strong> 父类的虚函数地址。</p></li></ol><p>因此如果子类中没有新的虚函数和重写的虚函数，那么子类的 <code>vtable</code> 就和父类的 <code>vtable</code> 一样。</p><p><img alt=笔记 loading=lazy src=https://s2.loli.net/2024/06/27/1lEpohSzWbc6TX7.jpg></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.cassdev.com/tags/c++/>C++</a></li><li><a href=https://blog.cassdev.com/tags/polymorphism/>Polymorphism</a></li><li><a href=https://blog.cassdev.com/tags/oop/>OOP</a></li><li><a href=https://blog.cassdev.com/tags/notes/>Notes</a></li></ul></footer></article></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>