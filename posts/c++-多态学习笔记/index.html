<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cassius0924 的博客</title><meta name=keywords content><meta name=description content="C++ 多态学习笔记
C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。
C++ 的多态性主要有两种实现方式：静态多态和动态多态。


静态多态：通过函数重载和模板实现。


动态多态：通过虚函数实现。


静态多态
函数重载
函数重载是指在同一个作用域内，可以定义 多个名称相同 但 参数列表不同 的函数。注意，不能用 返回值类型 来区分重载函数。
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

double add(double a, double b, double c) {
    return a + b + c;
}

[!NOTE]
编译过程


预处理：将源文件中的头文件展开，处理宏定义，删除注释等；
对应命令：g++ -E main.cpp -o main.i；


编译：进行词法分析、语法分析、语义分析，接着 生成汇编代码 ；


词法分析：分析源代码中的关键字、标识符、常量等是否合法；


语法分析：分析源代码中的语法结构是否合法；


语义分析：分析源代码中的语义是否合法；


对应命令：g++ -S main.i -o main.s；


汇编：将 汇编代码 转换为 目标文件 ，即将汇编代码翻译成机器指令；
对应命令：g++ -c main.s -o main.o；


链接：将 目标文件 和 库文件 链接成 可执行文件 ；


静态链接：将库文件的代码和目标文件的代码合并成一个可执行文件；


动态链接：将库文件的代码和目标文件的代码分开，运行时再动态链接；


对应命令：g++ main.o -o main。


函数重载的原理是通过 函数名修饰 实现的，即在编译阶段，编译器会根据函数名和参数列表生成一个唯一的函数名。"><meta name=author content><link rel=canonical href=https://blog.cassdev.com/posts/c++-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.cassdev.com/posts/c++-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/posts/c++-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="Cassius0924 的博客"><meta property="og:description" content="C++ 多态学习笔记 C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。
C++ 的多态性主要有两种实现方式：静态多态和动态多态。
静态多态：通过函数重载和模板实现。
动态多态：通过虚函数实现。
静态多态 函数重载 函数重载是指在同一个作用域内，可以定义 多个名称相同 但 参数列表不同 的函数。注意，不能用 返回值类型 来区分重载函数。
int add(int a, int b) { return a + b; } double add(double a, double b) { return a + b; } double add(double a, double b, double c) { return a + b + c; } [!NOTE]
编译过程
预处理：将源文件中的头文件展开，处理宏定义，删除注释等；
对应命令：g++ -E main.cpp -o main.i；
编译：进行词法分析、语法分析、语义分析，接着 生成汇编代码 ；
词法分析：分析源代码中的关键字、标识符、常量等是否合法；
语法分析：分析源代码中的语法结构是否合法；
语义分析：分析源代码中的语义是否合法；
对应命令：g++ -S main.i -o main.s；
汇编：将 汇编代码 转换为 目标文件 ，即将汇编代码翻译成机器指令；
对应命令：g++ -c main.s -o main.o；
链接：将 目标文件 和 库文件 链接成 可执行文件 ；
静态链接：将库文件的代码和目标文件的代码合并成一个可执行文件；
动态链接：将库文件的代码和目标文件的代码分开，运行时再动态链接；
对应命令：g++ main.o -o main。
函数重载的原理是通过 函数名修饰 实现的，即在编译阶段，编译器会根据函数名和参数列表生成一个唯一的函数名。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="C++ 多态学习笔记
C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。
C++ 的多态性主要有两种实现方式：静态多态和动态多态。


静态多态：通过函数重载和模板实现。


动态多态：通过虚函数实现。


静态多态
函数重载
函数重载是指在同一个作用域内，可以定义 多个名称相同 但 参数列表不同 的函数。注意，不能用 返回值类型 来区分重载函数。
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

double add(double a, double b, double c) {
    return a + b + c;
}

[!NOTE]
编译过程


预处理：将源文件中的头文件展开，处理宏定义，删除注释等；
对应命令：g++ -E main.cpp -o main.i；


编译：进行词法分析、语法分析、语义分析，接着 生成汇编代码 ；


词法分析：分析源代码中的关键字、标识符、常量等是否合法；


语法分析：分析源代码中的语法结构是否合法；


语义分析：分析源代码中的语义是否合法；


对应命令：g++ -S main.i -o main.s；


汇编：将 汇编代码 转换为 目标文件 ，即将汇编代码翻译成机器指令；
对应命令：g++ -c main.s -o main.o；


链接：将 目标文件 和 库文件 链接成 可执行文件 ；


静态链接：将库文件的代码和目标文件的代码合并成一个可执行文件；


动态链接：将库文件的代码和目标文件的代码分开，运行时再动态链接；


对应命令：g++ main.o -o main。


函数重载的原理是通过 函数名修饰 实现的，即在编译阶段，编译器会根据函数名和参数列表生成一个唯一的函数名。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.cassdev.com/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://blog.cassdev.com/posts/c++-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"C++ 多态学习笔记 C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。\nC++ 的多态性主要有两种实现方式：静态多态和动态多态。\n静态多态：通过函数重载和模板实现。\n动态多态：通过虚函数实现。\n静态多态 函数重载 函数重载是指在同一个作用域内，可以定义 多个名称相同 但 参数列表不同 的函数。注意，不能用 返回值类型 来区分重载函数。\nint add(int a, int b) { return a + b; } double add(double a, double b) { return a + b; } double add(double a, double b, double c) { return a + b + c; } [!NOTE]\n编译过程\n预处理：将源文件中的头文件展开，处理宏定义，删除注释等；\n对应命令：g++ -E main.cpp -o main.i；\n编译：进行词法分析、语法分析、语义分析，接着 生成汇编代码 ；\n词法分析：分析源代码中的关键字、标识符、常量等是否合法；\n语法分析：分析源代码中的语法结构是否合法；\n语义分析：分析源代码中的语义是否合法；\n对应命令：g++ -S main.i -o main.s；\n汇编：将 汇编代码 转换为 目标文件 ，即将汇编代码翻译成机器指令；\n对应命令：g++ -c main.s -o main.o；\n链接：将 目标文件 和 库文件 链接成 可执行文件 ；\n静态链接：将库文件的代码和目标文件的代码合并成一个可执行文件；\n动态链接：将库文件的代码和目标文件的代码分开，运行时再动态链接；\n对应命令：g++ main.o -o main。\n函数重载的原理是通过 函数名修饰 实现的，即在编译阶段，编译器会根据函数名和参数列表生成一个唯一的函数名。\n","keywords":[],"articleBody":"C++ 多态学习笔记 C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。\nC++ 的多态性主要有两种实现方式：静态多态和动态多态。\n静态多态：通过函数重载和模板实现。\n动态多态：通过虚函数实现。\n静态多态 函数重载 函数重载是指在同一个作用域内，可以定义 多个名称相同 但 参数列表不同 的函数。注意，不能用 返回值类型 来区分重载函数。\nint add(int a, int b) { return a + b; } double add(double a, double b) { return a + b; } double add(double a, double b, double c) { return a + b + c; } [!NOTE]\n编译过程\n预处理：将源文件中的头文件展开，处理宏定义，删除注释等；\n对应命令：g++ -E main.cpp -o main.i；\n编译：进行词法分析、语法分析、语义分析，接着 生成汇编代码 ；\n词法分析：分析源代码中的关键字、标识符、常量等是否合法；\n语法分析：分析源代码中的语法结构是否合法；\n语义分析：分析源代码中的语义是否合法；\n对应命令：g++ -S main.i -o main.s；\n汇编：将 汇编代码 转换为 目标文件 ，即将汇编代码翻译成机器指令；\n对应命令：g++ -c main.s -o main.o；\n链接：将 目标文件 和 库文件 链接成 可执行文件 ；\n静态链接：将库文件的代码和目标文件的代码合并成一个可执行文件；\n动态链接：将库文件的代码和目标文件的代码分开，运行时再动态链接；\n对应命令：g++ main.o -o main。\n函数重载的原理是通过 函数名修饰 实现的，即在编译阶段，编译器会根据函数名和参数列表生成一个唯一的函数名。\n可以通过 objdump -t main.o 命令查看函数名修饰后的函数名。一般函数名格式为 _ZN + 类名长度 + 类名 + 函数名长度 + 函数名 + E + 参数类型首字母。\nclass A { public: void func(int a) { // 函数名修饰后：_ZN1A4funcEi std::cout \u003c\u003c \"int: \" \u003c\u003c a \u003c\u003c std::endl; } void func(double a, double b) { // 函数名修饰后：_ZN1A4funcEdd std::cout \u003c\u003c \"double: \" \u003c\u003c a \u003c\u003c \" \" \u003c\u003c b \u003c\u003c std::endl; } }; int main() { // ... } 模板 模板也是一种静态多态。\n动态多态 虚函数 C++ 的多态性是通过虚函数实现的，虚函数是在基类中声明的，子类可以重写基类的虚函数，从而实现 基类指针指向子类对象 ，调用子类对象的成员函数。\n虚函数表 虚函数表（vtable）是一个存储 虚函数地址 的一维数组，每个类都有一个虚函数表，虚函数表中存储的是虚函数的地址。\n虚函数表的创建时机是在 编译阶段 ，存放于 只读数据段（.rodata） 中，是一个全局变量，每个类的虚函数表都是唯一的，这个类的所有实例都会共享这个虚函数表。\n虚函数表指针 虚函数表指针（vptr）是一个指向虚函数表的指针，是一个 隐藏的成员变量 ，存在于每个类的对象中，指向这个类的虚函数表。\n虚函数表指针是在构造函数中初始化的，指向这个类的虚函数表，当调用虚函数时，会通过这个虚函数表指针找到虚函数表，再找到虚函数的地址，最后调用虚函数。\n编译器任务 如果一个类中有虚函数（用 virtual 关键字修饰的函数）：\n那么编译器就会为这个类生成一个 vtable ，存放这个类的虚函数地址。\n编译器还会在这个类的对象中添加一个 vptr，用于指向这个类的 vtable。\n编译器还会在这个类的 构造函数 插入初始化 vptr 的代码，指向这个类的 vtable。\n编译器还会在这个类的 析构函数 插入清空 vptr 的代码。\n对象实例的内存布局如下：\n继承下 如果一个类继承了另一个类，在编译阶段，子类的 vtable 赋值流程如下：\n先将父类的 vtable 复制到子类的 vtable 中。\n再查找子类中 新的虚函数 ，如果有新的虚函数，就将新的虚函数地址 添加 到子类的 vtable 中。\n最后查找子类中 重写的虚函数 ，如果有重写的虚函数，就将重写的虚函数地址 覆盖 父类的虚函数地址。\n因此如果子类中没有新的虚函数和重写的虚函数，那么子类的 vtable 就和父类的 vtable 一样。\n","wordCount":"235","inLanguage":"zh","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.cassdev.com/posts/c++-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"Cassius0924 的博客","logo":{"@type":"ImageObject","url":"https://blog.cassdev.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title=首页><span>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/gallery/ title=图库><span>图库</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.cassdev.com/>主页</a>&nbsp;»&nbsp;<a href=https://blog.cassdev.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>2 分钟</div></header><div class=post-content><h1 id=c-多态学习笔记>C++ 多态学习笔记<a hidden class=anchor aria-hidden=true href=#c-多态学习笔记>#</a></h1><p>C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。</p><p>C++ 的多态性主要有两种实现方式：静态多态和动态多态。</p><ul><li><p>静态多态：通过函数重载和模板实现。</p></li><li><p>动态多态：通过虚函数实现。</p></li></ul><h2 id=静态多态>静态多态<a hidden class=anchor aria-hidden=true href=#静态多态>#</a></h2><h3 id=函数重载>函数重载<a hidden class=anchor aria-hidden=true href=#函数重载>#</a></h3><p>函数重载是指在同一个作用域内，可以定义 <strong>多个名称相同</strong> 但 <strong>参数列表不同</strong> 的函数。注意，不能用 <strong>返回值类型</strong> 来区分重载函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>add</span><span class=p>(</span><span class=kt>double</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>add</span><span class=p>(</span><span class=kt>double</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=n>b</span><span class=p>,</span> <span class=kt>double</span> <span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span> <span class=o>+</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>[!NOTE]</p><p><strong>编译过程</strong></p><ol><li><p>预处理：将源文件中的头文件展开，处理宏定义，删除注释等；</p><p>对应命令：<code>g++ -E main.cpp -o main.i</code>；</p></li><li><p>编译：进行词法分析、语法分析、语义分析，接着 <strong>生成汇编代码</strong> ；</p><ul><li><p>词法分析：分析源代码中的关键字、标识符、常量等是否合法；</p></li><li><p>语法分析：分析源代码中的语法结构是否合法；</p></li><li><p>语义分析：分析源代码中的语义是否合法；</p></li></ul><p>对应命令：<code>g++ -S main.i -o main.s</code>；</p></li><li><p>汇编：将 <strong>汇编代码</strong> 转换为 <strong>目标文件</strong> ，即将汇编代码翻译成机器指令；</p><p>对应命令：<code>g++ -c main.s -o main.o</code>；</p></li><li><p>链接：将 <strong>目标文件</strong> 和 <strong>库文件</strong> 链接成 <strong>可执行文件</strong> ；</p><ul><li><p>静态链接：将库文件的代码和目标文件的代码合并成一个可执行文件；</p></li><li><p>动态链接：将库文件的代码和目标文件的代码分开，运行时再动态链接；</p></li></ul><p>对应命令：<code>g++ main.o -o main</code>。</p></li></ol></blockquote><p>函数重载的原理是通过 <strong>函数名修饰</strong> 实现的，即在编译阶段，编译器会根据函数名和参数列表生成一个唯一的函数名。</p><p>可以通过 <code>objdump -t main.o</code> 命令查看函数名修饰后的函数名。一般函数名格式为 <code>_ZN + 类名长度 + 类名 + 函数名长度 + 函数名 + E + 参数类型首字母</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// 函数名修饰后：_ZN1A4funcEi
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;int: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>double</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// 函数名修饰后：_ZN1A4funcEdd
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;double: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=模板>模板<a hidden class=anchor aria-hidden=true href=#模板>#</a></h3><p>模板也是一种静态多态。</p><h2 id=动态多态>动态多态<a hidden class=anchor aria-hidden=true href=#动态多态>#</a></h2><h3 id=虚函数>虚函数<a hidden class=anchor aria-hidden=true href=#虚函数>#</a></h3><p>C++ 的多态性是通过虚函数实现的，虚函数是在基类中声明的，子类可以重写基类的虚函数，从而实现 <strong>基类指针指向子类对象</strong> ，调用子类对象的成员函数。</p><h3 id=虚函数表>虚函数表<a hidden class=anchor aria-hidden=true href=#虚函数表>#</a></h3><p>虚函数表（vtable）是一个存储 <strong>虚函数地址</strong> 的一维数组，每个类都有一个虚函数表，虚函数表中存储的是虚函数的地址。</p><p>虚函数表的创建时机是在 <strong>编译阶段</strong> ，存放于 <strong>只读数据段（.rodata）</strong> 中，是一个全局变量，每个类的虚函数表都是唯一的，这个类的所有实例都会共享这个虚函数表。</p><h3 id=虚函数表指针>虚函数表指针<a hidden class=anchor aria-hidden=true href=#虚函数表指针>#</a></h3><p>虚函数表指针（vptr）是一个指向虚函数表的指针，是一个 <strong>隐藏的成员变量</strong> ，存在于每个类的对象中，指向这个类的虚函数表。</p><p>虚函数表指针是在构造函数中初始化的，指向这个类的虚函数表，当调用虚函数时，会通过这个虚函数表指针找到虚函数表，再找到虚函数的地址，最后调用虚函数。</p><h3 id=编译器任务>编译器任务<a hidden class=anchor aria-hidden=true href=#编译器任务>#</a></h3><p>如果一个类中有虚函数（用 <code>virtual</code> 关键字修饰的函数）：</p><ul><li><p>那么编译器就会为这个类生成一个 <code>vtable</code> ，存放这个类的虚函数地址。</p></li><li><p>编译器还会在这个类的对象中添加一个 <code>vptr</code>，用于指向这个类的 <code>vtable</code>。</p></li><li><p>编译器还会在这个类的 <strong>构造函数</strong> 插入初始化 <code>vptr</code> 的代码，指向这个类的 <code>vtable</code>。</p></li><li><p>编译器还会在这个类的 <strong>析构函数</strong> 插入清空 <code>vptr</code> 的代码。</p></li></ul><p>对象实例的内存布局如下：</p><p><img alt="vtable and vptr" loading=lazy src=https://s2.loli.net/2024/06/27/nz4KVwOmDsT5WMq.png></p><h3 id=继承下>继承下<a hidden class=anchor aria-hidden=true href=#继承下>#</a></h3><p>如果一个类继承了另一个类，在编译阶段，子类的 <code>vtable</code> 赋值流程如下：</p><ol><li><p>先将父类的 <code>vtable</code> 复制到子类的 <code>vtable</code> 中。</p></li><li><p>再查找子类中 <strong>新的虚函数</strong> ，如果有新的虚函数，就将新的虚函数地址 <strong>添加</strong> 到子类的 <code>vtable</code> 中。</p></li><li><p>最后查找子类中 <strong>重写的虚函数</strong> ，如果有重写的虚函数，就将重写的虚函数地址 <strong>覆盖</strong> 父类的虚函数地址。</p></li></ol><p>因此如果子类中没有新的虚函数和重写的虚函数，那么子类的 <code>vtable</code> 就和父类的 <code>vtable</code> 一样。</p><p><img alt=笔记 loading=lazy src=https://s2.loli.net/2024/06/27/1lEpohSzWbc6TX7.jpg></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://blog.cassdev.com/posts/c++-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><span class=title>« 上一页</span><br><span></span>
</a><a class=next href=https://blog.cassdev.com/posts/c++-%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><span class=title>下一页 »</span><br><span></span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share  on x" href="https://x.com/intent/tweet/?text=&amp;url=https%3a%2f%2fblog.cassdev.com%2fposts%2fc%2b%2b-%25E5%25A4%259A%25E6%2580%2581%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share  on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.cassdev.com%2fposts%2fc%2b%2b-%25E5%25A4%259A%25E6%2580%2581%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;title=&amp;summary=&amp;source=https%3a%2f%2fblog.cassdev.com%2fposts%2fc%2b%2b-%25E5%25A4%259A%25E6%2580%2581%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share  on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.cassdev.com%2fposts%2fc%2b%2b-%25E5%25A4%259A%25E6%2580%2581%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f&title="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share  on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.cassdev.com%2fposts%2fc%2b%2b-%25E5%25A4%259A%25E6%2580%2581%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share  on whatsapp" href="https://api.whatsapp.com/send?text=%20-%20https%3a%2f%2fblog.cassdev.com%2fposts%2fc%2b%2b-%25E5%25A4%259A%25E6%2580%2581%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share  on telegram" href="https://telegram.me/share/url?text=&amp;url=https%3a%2f%2fblog.cassdev.com%2fposts%2fc%2b%2b-%25E5%25A4%259A%25E6%2580%2581%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share  on ycombinator" href="https://news.ycombinator.com/submitlink?t=&u=https%3a%2f%2fblog.cassdev.com%2fposts%2fc%2b%2b-%25E5%25A4%259A%25E6%2580%2581%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>