<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Socket 编程之 IO 多路复用学习笔记 | Cassius0924 的博客</title><meta name=keywords content="Socket,IO Multiplexing,Asynchronous I/O,Network Programming,Notes"><meta name=description content="什么是 IO 多路复用？阻塞 IO 与 非阻塞 IO我们先了解一下阻塞 IO，阻塞 IO 是指应用程序在读写数据时，如果没有数据可读或者写，应用程序会一直 阻塞在那里 ，直到有数据可读或者写。
与它相反的是非阻塞 IO，是指应用程序在读写数据时，无论是否有数据可读写，都 立即返回 ，若没有数据可读写将会返回一个错误码，通过不断轮询来检查是否有数据可读或者写。
IO 多路复用由于 Scoket 默认是阻塞 IO，所以很多初学者在处理多个连接时，会为每个连接创建一个线程来处理，但这样做会引起 CPU 的上下文切换，降低系统的性能。
有一种更“优雅”的方式，那就是 IO 多路复用，也称为事件驱动模型（Event-driven IO）。IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 事件已经就绪，就通知该进程。IO 多路复用模型中，只需要一个线程就可以同时处理多个连接。
通俗易懂的说，IO 多路复用就是将多个 IO 事件交给内核，内核帮我们监听这些 IO 事件，当有 IO 事件就绪时，内核会通知我们，我们只需要处理就绪的 IO 事件即可。
IO 多路复用的优点

一个线程可以同时处理多个连接，减少线程的创建和销毁


降低了系统开销，提高了系统的并发性能


IO 多路复用的实现方式

select


poll


epoll (Linux)


kqueue (FreeBSD)


IOCP（Windows）


其中 epoll 是 Linux 下的 IO 多路复用机制，kqueue 是 FreeBSD（macOS 就属于 FreeBSD）下的 IO 多路复用机制。
下面的伪代码是 IO 多路复用的最基本实现方式："><meta name=author content="Cassius0924"><link rel=canonical href=https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.4f5249ac184c033613d94c5267209e90161d3a93365c2feb0ad3960a4bbb6393.css integrity="sha256-T1JJrBhMAzYT2UxSZyCekBYdOpM2XC/rCtOWCku7Y5M=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="Socket 编程之 IO 多路复用学习笔记"><meta property="og:description" content="什么是 IO 多路复用？阻塞 IO 与 非阻塞 IO我们先了解一下阻塞 IO，阻塞 IO 是指应用程序在读写数据时，如果没有数据可读或者写，应用程序会一直 阻塞在那里 ，直到有数据可读或者写。
与它相反的是非阻塞 IO，是指应用程序在读写数据时，无论是否有数据可读写，都 立即返回 ，若没有数据可读写将会返回一个错误码，通过不断轮询来检查是否有数据可读或者写。
IO 多路复用由于 Scoket 默认是阻塞 IO，所以很多初学者在处理多个连接时，会为每个连接创建一个线程来处理，但这样做会引起 CPU 的上下文切换，降低系统的性能。
有一种更“优雅”的方式，那就是 IO 多路复用，也称为事件驱动模型（Event-driven IO）。IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 事件已经就绪，就通知该进程。IO 多路复用模型中，只需要一个线程就可以同时处理多个连接。
通俗易懂的说，IO 多路复用就是将多个 IO 事件交给内核，内核帮我们监听这些 IO 事件，当有 IO 事件就绪时，内核会通知我们，我们只需要处理就绪的 IO 事件即可。
IO 多路复用的优点 一个线程可以同时处理多个连接，减少线程的创建和销毁
降低了系统开销，提高了系统的并发性能
IO 多路复用的实现方式 select
poll
epoll (Linux)
kqueue (FreeBSD)
IOCP（Windows）
其中 epoll 是 Linux 下的 IO 多路复用机制，kqueue 是 FreeBSD（macOS 就属于 FreeBSD）下的 IO 多路复用机制。
下面的伪代码是 IO 多路复用的最基本实现方式："><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-24T21:36:55+08:00"><meta property="article:modified_time" content="2024-06-24T21:36:55+08:00"><meta property="article:tag" content="Socket"><meta property="article:tag" content="IO Multiplexing"><meta property="article:tag" content="Asynchronous I/O"><meta property="article:tag" content="Network Programming"><meta property="article:tag" content="Notes"><meta name=twitter:card content="summary"><meta name=twitter:title content="Socket 编程之 IO 多路复用学习笔记"><meta name=twitter:description content="什么是 IO 多路复用？阻塞 IO 与 非阻塞 IO我们先了解一下阻塞 IO，阻塞 IO 是指应用程序在读写数据时，如果没有数据可读或者写，应用程序会一直 阻塞在那里 ，直到有数据可读或者写。
与它相反的是非阻塞 IO，是指应用程序在读写数据时，无论是否有数据可读写，都 立即返回 ，若没有数据可读写将会返回一个错误码，通过不断轮询来检查是否有数据可读或者写。
IO 多路复用由于 Scoket 默认是阻塞 IO，所以很多初学者在处理多个连接时，会为每个连接创建一个线程来处理，但这样做会引起 CPU 的上下文切换，降低系统的性能。
有一种更“优雅”的方式，那就是 IO 多路复用，也称为事件驱动模型（Event-driven IO）。IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 事件已经就绪，就通知该进程。IO 多路复用模型中，只需要一个线程就可以同时处理多个连接。
通俗易懂的说，IO 多路复用就是将多个 IO 事件交给内核，内核帮我们监听这些 IO 事件，当有 IO 事件就绪时，内核会通知我们，我们只需要处理就绪的 IO 事件即可。
IO 多路复用的优点

一个线程可以同时处理多个连接，减少线程的创建和销毁


降低了系统开销，提高了系统的并发性能


IO 多路复用的实现方式

select


poll


epoll (Linux)


kqueue (FreeBSD)


IOCP（Windows）


其中 epoll 是 Linux 下的 IO 多路复用机制，kqueue 是 FreeBSD（macOS 就属于 FreeBSD）下的 IO 多路复用机制。
下面的伪代码是 IO 多路复用的最基本实现方式："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.cassdev.com/posts/"},{"@type":"ListItem","position":2,"name":"Socket 编程之 IO 多路复用学习笔记","item":"https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Socket 编程之 IO 多路复用学习笔记","name":"Socket 编程之 IO 多路复用学习笔记","description":"什么是 IO 多路复用？阻塞 IO 与 非阻塞 IO我们先了解一下阻塞 IO，阻塞 IO 是指应用程序在读写数据时，如果没有数据可读或者写，应用程序会一直 阻塞在那里 ，直到有数据可读或者写。\n与它相反的是非阻塞 IO，是指应用程序在读写数据时，无论是否有数据可读写，都 立即返回 ，若没有数据可读写将会返回一个错误码，通过不断轮询来检查是否有数据可读或者写。\nIO 多路复用由于 Scoket 默认是阻塞 IO，所以很多初学者在处理多个连接时，会为每个连接创建一个线程来处理，但这样做会引起 CPU 的上下文切换，降低系统的性能。\n有一种更“优雅”的方式，那就是 IO 多路复用，也称为事件驱动模型（Event-driven IO）。IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 事件已经就绪，就通知该进程。IO 多路复用模型中，只需要一个线程就可以同时处理多个连接。\n通俗易懂的说，IO 多路复用就是将多个 IO 事件交给内核，内核帮我们监听这些 IO 事件，当有 IO 事件就绪时，内核会通知我们，我们只需要处理就绪的 IO 事件即可。\nIO 多路复用的优点 一个线程可以同时处理多个连接，减少线程的创建和销毁\n降低了系统开销，提高了系统的并发性能\nIO 多路复用的实现方式 select\npoll\nepoll (Linux)\nkqueue (FreeBSD)\nIOCP（Windows）\n其中 epoll 是 Linux 下的 IO 多路复用机制，kqueue 是 FreeBSD（macOS 就属于 FreeBSD）下的 IO 多路复用机制。\n下面的伪代码是 IO 多路复用的最基本实现方式：\n","keywords":["Socket","IO Multiplexing","Asynchronous I/O","Network Programming","Notes"],"articleBody":"什么是 IO 多路复用？阻塞 IO 与 非阻塞 IO我们先了解一下阻塞 IO，阻塞 IO 是指应用程序在读写数据时，如果没有数据可读或者写，应用程序会一直 阻塞在那里 ，直到有数据可读或者写。\n与它相反的是非阻塞 IO，是指应用程序在读写数据时，无论是否有数据可读写，都 立即返回 ，若没有数据可读写将会返回一个错误码，通过不断轮询来检查是否有数据可读或者写。\nIO 多路复用由于 Scoket 默认是阻塞 IO，所以很多初学者在处理多个连接时，会为每个连接创建一个线程来处理，但这样做会引起 CPU 的上下文切换，降低系统的性能。\n有一种更“优雅”的方式，那就是 IO 多路复用，也称为事件驱动模型（Event-driven IO）。IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 事件已经就绪，就通知该进程。IO 多路复用模型中，只需要一个线程就可以同时处理多个连接。\n通俗易懂的说，IO 多路复用就是将多个 IO 事件交给内核，内核帮我们监听这些 IO 事件，当有 IO 事件就绪时，内核会通知我们，我们只需要处理就绪的 IO 事件即可。\nIO 多路复用的优点 一个线程可以同时处理多个连接，减少线程的创建和销毁\n降低了系统开销，提高了系统的并发性能\nIO 多路复用的实现方式 select\npoll\nepoll (Linux)\nkqueue (FreeBSD)\nIOCP（Windows）\n其中 epoll 是 Linux 下的 IO 多路复用机制，kqueue 是 FreeBSD（macOS 就属于 FreeBSD）下的 IO 多路复用机制。\n下面的伪代码是 IO 多路复用的最基本实现方式：\nwhile (1) { for (fd : fds) { // 遍历所有的文件描述符 if (fd 有数据) { 处理数据; // 如果文件描述符有数据则处理数据 } } } 如果我们在自行编写的程序中使用上面的伪代码，那么每次判断 fd 是否有数据时，都需要询问内核，所以每次判断都会引起一次系统调用，也就是会从用户态切换到内核态，这样的效率是不够高的。\n所以操作系统为我们提供了 select、poll、epoll、kqueue、ICOP 这几种解决方案，它们可以在内核中直接监听文件描述符，当文件描述符就绪时，内核会通知我们，这样就不需要我们自己去轮询文件描述符了。\n下面介绍一下五种方式的区别：\nselect 笔记 前置知识\nfd_set\nfd_set（file descriptor set）是一个文件描述符集合，它本质上是一个 bitmap（位图），每个文件描述符对应一个位，如果文件描述符在集合中，则对应的位为 1，否则为 0。例如我们有 3 个文件描述符，分别为 3、4、8，那么 fd_set 的值为 000110001。\nstruct timeval\nstruct timeval 是一个结构体，用来表示时间，它有两个成员变量，分别是 tv_sec 和 tv_usec，分别表示秒和微秒。\n提示 文件描述符补充知识\n在 Linux 中，用户创建的文件描述符最小值为 3，因为 0、1、2 分别为标准输入、标准输出和标准错误。\nint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); nfds：监听的文件描述符的最大值加 1\nreadfds：读事件 fd 集合（输出参数）\nwritefds：写事件 fd 集合（输出参数）\nexceptfds：异常事件 fd 集合（输出参数）\ntimeout：超时时间，类型为 struct timeval\n函数返回值：就绪的文件描述符的数量，如果超时返回 0，出错返回 -1\n从函数原型可以看出，select 函数中间三个参数都是输出参数，我们只需要传入 fd_set 结构体的指针即可。我们需要给予 select 函数的数据只有监听的 fd 的最大值加 1 和监听超时时间，然后 select 函数就会帮我们监听这些文件描述符。\n至于 nfds 为什么要加 1，是因为 select 函数是从 0 开始遍历文件描述符的。用刚刚 fd_set 的例子来说，如果我们不加 1，那么 select 函数只会遍历到 00011000 七个 fd，而不会遍历最后一个 1 对应的 fd。\ntimeout 参数除了设置一个具体的时间值外，还可以设置为 -1，表示永久阻塞，直到有文件描述符就绪。如果设置为 0，则表示立即返回，不会阻塞。\nselect 的工作原理大致如下：\n用户态将需要监听的文件描述符集合传递给内核\n内核将这些文件描述符集合拷贝到内核空间\n内核循环遍历这些 fd ，如果有 fd 可读，则将 readfds 对应的位设置为 1，如果有 fd 可写，则将 writefds 对应的位设置为 1，如果有异常，则将 exceptfds 对应的位设置为 1\n函数返回\nselect 函数每次调用时会将需要遍历的文件描述符直接一次全量拷贝到内核空间，并在内核态进行轮询判断，这样就不会引起用户态和内核态的频繁切换，自然也就提高了效率。\n当 select 函数返回后，我们就可以通过判断 readfds、writefds、exceptfds 中的位来判断哪些文件描述符有数据可读、可写或者有异常。\nselect 函数的使用示例：\n// ... // 假设 fds 为一个 fd 数组，里面存放了需要监听的文件描述符，fd_max 为 fds 中最大的 fd fd_set r_fdset; fd_set w_fdset; fd_set e_fdset; while (1) { FD_ZERO(\u0026r_fdset); // 清空 fd_set FD_ZERO(\u0026w_fdset); FD_ZERO(\u0026e_fdset); for (int i = 0; i \u003c fds.size(); i++) { // 初始化 fd_set FD_SET(fds[i], \u0026r_fdset); FD_SET(fds[i], \u0026w_fdset); FD_SET(fds[i], \u0026e_fdset); } struct timeval timeout; timeout.tv_sec = 5; // 设置超时时间为 5 秒 timeout.tv_usec = 0; int ret = select(fd_max + 1, \u0026r_fdset, \u0026w_fdset, \u0026e_fdset, \u0026timeout); if (ret == 0) { printf(\"select timeout\\n\"); continue; } if (ret \u003c 0) { perror(\"select error\"); break; } for (int i = 0; i \u003c fds.size(); i++) { if (FD_ISSET(fds[i], \u0026r_fdset)) { // 处理读事件 } if (FD_ISSET(fds[i], \u0026w_fdset)) { // 处理写事件 } if (FD_ISSET(fds[i], \u0026e_fdset)) { // 处理异常事件 } } } select 函数的缺点：\nfd_set 的大小有限，一般为 1024，所以 select 函数最多只能监听 1024 个文件描述符 fd_set 不可重用，每次调用 select 函数都需要重新初始化 fd_set。上述代码中，每次 while 循环都需要重新初始化 r_fdset、w_fdset 以及 e_fdset select 函数的时间复杂度为 O(n)，n 为文件描述符的数量 每次调用 select 函数都会将所有的文件描述符集合从用户态拷贝到内核态，这样仍有一定的开销 判断哪些文件描述符有数据可读、可写或者有异常时，需要再次遍历所有的文件描述符，时间复杂度为 O(n)，效率不高 select 函数有这些缺点也不奇怪，因为它是最早的 IO 多路复用函数，随着时间的推移，就出现了第二个 IO 多路复用函数 poll。\npoll 笔记 前置知识\nstruct pollfd\npollfd 是一个结构体，用来存放需要监听的文件描述符，它的定义如下：\nstruct pollfd { int fd; // 文件描述符 short events; // 需要监听的事件 short revents; // 返回的事件 }; events 和 revents 都是一个位掩码，用来表示需要监听的事件和返回的事件，它们可以是以下几个值的组合（使用或 | 运算符）：\nPOLLIN：有数据可读，相当于 POLLRDNORM | POLLRDBAND POLLOUT：有数据可写，相当于 POLLWRNORM | POLLWRBAND POLLERR：有错误 POLLHUP：挂起 POLLNVAL：无效请求 POLLPRI：有紧急数据 POLLRDBAND：有带外数据可读 POLLRDNORM：有普通数据可读 POLLWRBAND：有带外数据可写 POLLWRNORM：有普通数据可写 int poll(struct pollfd *fds, nfds_t nfds, int timeout); fds：pollfd 结构体数组，用来存放需要监听的文件描述符\nnfds：fds 数组的大小\ntimeout：超时时间，单位为毫秒\n函数返回值：与 select 函数一样，返回就绪的文件描述符的数量，如果超时返回 0，出错返回 -1\n可以看出，poll 比 select 少了两个参数，fds 既为输入参数，又为输出参数，nfds 为 fds 数组的大小，timeout 为超时时间。poll 函数在有 IO 事件或错误发生时，会将对应的 fd 的 revents 设置为对应的事件，我们只需要遍历 fds 数组，判断 revents 的值即可。\nrevents 的默认值为 0，因此我们在处理完一个 fd 后，只需要将其 revents 设置为 0，这相比于 select 函数的 fd_set 初始化要简洁一些。\npoll 函数的最大亮点就是使用了 pollfd 结构体存放需要监听的文件描述符，所以 poll 函数不会有文件描述符个数的限制，相比于 select 函数能承受更高的并发量。\npoll 函数的使用示例：\n// ... // 假设 pollfds 为一个 pollfd 数组，里面存放了需要监听的文件描述符，pollfds_size 为 pollfds 的大小 for (int i = 0; i \u003c pollfds_size; i++) { pollfds[i].events = POLLIN | POLLOUT | POLLERR; // 设置需要监听的事件 } while(1) { int ret = poll(pollfds, pollfds_size, 5000); // 设置超时时间为 5 秒 if (ret == 0) { printf(\"poll timeout\\n\"); continue; } if (ret \u003c 0) { perror(\"poll error\"); break; } for (int i = 0; i \u003c pollfds_size(); i++) { if (pollfds[i].revents \u0026 POLLIN) { pollfds[i].revents = 0; // 处理完后将 revents 设置为 0 // 处理读事件 } if (pollfds[i].revents \u0026 POLLOUT) { pollfds[i].revents = 0; // 处理写事件 } if (pollfds[i].revents \u0026 POLLERR) { pollfds[i].revents = 0; // 处理异常事件 } } } poll 函数解决了 select 函数的 fd_set 大小有限、不可重用的问题，但是它仍有以下两个缺点：\n每次调用 poll 函数都会将所有的文件描述符集合从用户态拷贝到内核态 poll 函数与 select 函数一样，为了判断文件描述符是否就绪，需要遍历所有的文件描述符 是否能够不用每次调用都将文件描述符集合从用户态拷贝到内核态呢，而是只值传递一次呢？是否能够不用每次都遍历所有的文件描述符呢，而是只遍历就绪的文件描述符呢？答案是肯定的，这就是 epoll。\nepoll 笔记 前置知识\nepoll_event\nepoll_event 是一个结构体，用来存放需要监听的文件描述符，它的定义如下：\ntypedef union epoll_data { void *ptr; int fd; __uint32_t u32; __uint64_t u64; } epoll_data_t; struct epoll_event { __uint32_t events; // 需要监听的事件 epoll_data_t data; // 用户数据 }; events 是需要监听的事件，它可以是以下几个值的组合（使用或 | 运算符）：\nEPOLLIN：有数据可读 EPOLLOUT：有数据可写 EPOLLERR：有错误 EPOLLHUP：挂起 EPOLLPRI：有 OOB 紧急数据 EPOLLRDHUP：断开连接或者半关闭的情况，只有在边缘触发模式下才有效（关于边缘触发会在下文中介绍） EPOLLONESHOT：只监听一次事件，发生一次事件后，此文件描述符就不再收到事件通知。需要使用 epoll_ctl 的 EPOLL_CTL_MOD 修改事件 EPOLLET：设置为边缘触发模式 EPOLLWAKEUP：唤醒进程 EPOLLEXCLUSIVE：独占模式 data 是用户数据，一般用于存放文件描述符。\nepoll 共有三个函数：\nepoll_create：创建一个 epoll 实例\nepoll_ctl：控制 epoll 实例中的文件描述符\nepoll_wait：等待就绪的文件描述符\nepoll 的 “e” 代表了 “event”，这是一个事件驱动的模型，即响应式的模型。内核不再需要 主动 轮询文件描述符，而是通过回调函数来实现通知进程，属于 被动响应 。\nselect 和 poll 都只有一个函数，所有功能都聚合到一个函数中，因此每次调用都需要传入需要监听的文件描述符，也就导致了每次都需要将文件描述符集合从用户态拷贝到内核态，增加了开销。\nepoll 将 维护文件描述符集合 和 判断文件描述符是否就绪 两个功能进行了拆分，整个过程只需要使用 epoll_ctl 函数添加一次文件描述符，在 epoll_wait 函数中不再需要传入需要监听文件描述符，这样就大大减少了从用户态到内核态切换的开销。\nint epoll_create(int size); Linux 手册：\nepoll_create() creates a new epoll(7) instance. Since Linux 2.6.8, the size argument is ignored, but must be greater than zero; see HISTORY.\n根据 Linux 手册，epoll_create 函数的 size 参数在 Linux 2.6.8 之后被忽略，但是必须大于 0。所以我们可以将 size 参数设置为 1。根本原因是内核支持了动态扩容，所以 size 参数不再有意义，但为了向下兼容，size 参数仍然需要传入。\nepoll_create 函数作用是创建一个 eventpoll 结构体（ epoll 实例 ），函数返回值是一个非负的文件描述符，用于操作 eventpoll，如果返回 -1 则表示创建失败，并且 errno 会被设置为相应的错误码。这个文件描述符与其他文件描述符一样，需要通过 close 函数关闭，否则文件描述符会被耗尽。\neventpoll 是一个内核数据结构，由操作系统管理，其内部有三个重要的字段：\n红黑树：用来存放需要监听的文件描述符，时间复杂度为 O(log n)\n就绪列表：用来存放就绪的文件描述符，是一个双向循环链表，其作用就是告诉内核哪些文件描述符的哪些事件已经就绪\n等待队列：用来存放等待的进程/线程\n通过 eventpoll 可知，与 select 和 poll 采用的 线性结构 的方式存储文件描述符不同，eventpoll 维护了一个名为 rbr 的红黑树，用来存放需要监听的文件描述符，采用了 树形结构 存储文件描述符，将查询操作的时间复杂度从 O(n) 降低到了 O(log n)。\neventpoll 还维护了一个名为 rdllist 的就绪列表，用来存放就绪的文件描述符。当文件描述符就绪时，其会被 rdllist 引用，因此用户只需要获取 rdllist 中的内容即可知道哪些文件描述符就绪。\n由于一个 epoll 实例可以被多个进程共享，即一个 epfd 可以被多个进程的 epoll_wait 函数调用，所以 eventpoll 还维护了一个名为 wq 的等待队列，用来存放等待中（阻塞中）的线程。\nepoll_create 的工作原理大致如下：\n为 eventpoll 申请空间，并且初始化其成员，如红黑树、就绪列表和等待队列等\n为 eventpoll 申请一个未使用的文件描述符 fd\n申请一个满足 VFS 的虚拟文件结构体 file\neventpoll 与 file 关联，将 fd 和 file 关联起来\n返回 fd\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epfd：epoll 实例的文件描述符，即 epoll_create 函数返回的文件描述符\nop：操作类型，Linux 为我们定义了三个宏：\nEPOLL_CTL_ADD：添加一个文件描述符到 epoll 实例中\nEPOLL_CTL_MOD：修改一个文件描述符在 epoll 实例中的事件\nEPOLL_CTL_DEL：从 epoll 实例中删除一个文件描述符\nfd：需要监听的文件描述符\nevent：epoll_event 结构体，用来存放需要监听的事件\n函数返回值：成功返回 0，失败返回 -1，并且 errno 会被设置为相应的错误码\nepoll_ctl 函数（ epoll control ）用来控制 epoll 实例中的文件描述符，可以添加、修改或者删除文件描述符。\n阅读下面代码语句：\nepoll_ctl(A, EPOLL_CTL_ADD, B, \u0026C); epoll_ctl(A, EPOLL_CTL_DEL, B, NULL); 第一条语句的意思是在 epoll 实例 A 中注册（添加）文件描述符 B，并监听参数 C 中的事件。 第二条语句的意思是在 epoll 实例 A 中删除文件描述符 B。可以看出在删除文件描述符时，不需要传入事件参数。\n由于 epoll_ctl 函数的实现里有互斥锁的存在，所以它是一个线程安全的函数，多个线程/进程可以并发调用 epoll_ctl 函数。\n在调用 epoll_ctl 函数时，epoll_ctl 函数会为每个文件描述符创建一个 epitem 结构体，这个结构体用来存放文件描述符的信息，包括文件描述符、事件、回调函数等。这个 epitem 结构体会被添加到 eventpoll 的红黑树中。\nepitem 结构体的定义如下：\nstruct epitem { struct rb_node rbn; // 红黑树节点 struct list_head rdllink; // 就绪列表节点 struct eppoll_entry *pwqlist; // socket 等待队列 struct eventpoll* ep; // 指向 eventpoll 结构体 struct epoll_event event; // 事件 } epoll_ctl(ADD) 函数的工作原理大致如下：\n将 event 拷贝到内核空间\n尝试在红黑树中查找 fd 对应的 epitem 结构体\n找不到则创建一个新的 epitem，并将 epitem 添加到红黑树中\n创建一个 epitem 对应的 eppoll_entry 用于链接到 socket 等待队列，并为 eppoll_entry 设置回调函数\n将 eppoll_entry 添加到 socket 等待队列中\n检查该 socket 的读写缓冲区和状态，如果有事件发生，则将 epitem 添加到就绪列表中，并且唤醒 eventpoll.wq 中的等待进程\n函数返回\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); epfd：epoll 实例的文件描述符\nevents：用来存放就绪的文件描述符\nmaxevents：events 数组的大小\ntimeout：超时时间，单位为毫秒\n函数返回值：返回就绪的文件描述符的数量，如果超时返回 0，出错返回 -1\n其中 epfd 和 timeout 参数皆为输入参数，events 为输出参数，我们只需要传入空的 epoll_event 数组即可。events 数组会被填充就绪的文件描述符，所以其大小 maxevents 应该大于等于监听的文件描述符的数量。\nepoll_wait 函数会检查 epoll 实例的就绪链表，如果就绪链表中有文件描述符，则将其添加到 events 数组中，然后返回就绪的文件描述符的数量。如果就绪链表为空，则会阻塞直到有文件描述符就绪或者超时。\nepoll_wait 函数的工作原理大致如下：\n通过传入的 epfd 找到对应的 eventpoll 结构体\n判断 eventpoll.rdllist 是否有 epitem，有则代表有 epitem 就绪，但不一定是我们感兴趣的事件，所以需要进一步判断\n若 rdllist 不为空，则遍历它，获取 epitem 的 socket 后，在 rdllist 中删除此 epitem，接着判断 socket 具体触发的事件类型是否为我们需要监听的事件\n若是我们需要监听的事件，则将此事件拷贝回用户态的 events 数组中，函数返回\n若是水平触发模式，则将 epitem 重新添加到 rdllist 中，以便下次再次判断\n若 rdllist 为空，则判断是否超时，若超时则直接返回\n未超时则将该进程加入到 eventpoll.wq 进程等待队列中，并且将进程置为可中断睡眠状态，等待唤醒\n唤醒后，将进程设置为运行状态，并在 wq 中删除该进程\n重复 2-8 步骤，直到超时或者有文件描述符就绪\n笔记 注意，epoll 并没有采用共享内存的方式，阅读源码可知，epoll 采用了内核态和用户态的数据拷贝：\nepoll_put_uevent(__poll_t revents, __u64 data, struct epoll_event __user *uevent) { // __put_user 是内核态到用户态的数据拷贝的函数 if (__put_user(revents, \u0026uevent-\u003eevents) || __put_user(data, \u0026uevent-\u003edata)) return NULL; return uevent+1; } 笔记 epoll 的两种触发模式\nepoll 有两种触发模式，分别是 水平触发模式（ Level Trigger ）和 边缘触发模式（ Edge Trigger ）。水平触发模式是 epoll 默认的工作模式。\n水平触发模式（ LT模式 ）：相当于时序电路中的高电平触发。关注点是 数据，只要读操作缓冲区不为空或写操作缓冲区不为满，epoll_wait 就会返回就绪事件。\n边缘触发模式（ ET模式 ）：相当于时序电路中的边沿出发。关注点是 变化，只有当有数据写接收进缓冲区或者从发送缓冲区读出数据时，epoll_wait 才会返回就绪事件。\nepoll 函数的使用示例：\n// ... // 假设 epfd 为 epoll 实例的文件描述符，fds 为需要监听的文件描述符数组，fds_size 为 fds 的大小 struct epoll_event events[5] int epfd = epoll_create(1); for (int i = 0; i \u003c 5; i++) { static struct epoll_event ev; ev.events = EPOLLIN | EPOLLOUT | EPOLLERR; // 设置需要监听的事件 ev.data.fd = fds[i]; // 设置需要监听的文件描述符 epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, \u0026ev); // 注册文件描述符和事件 } while (1) { int ret = epoll_wait(epfd, events, 5, 5000); // 设置超时时间为 5 秒 if (ret == 0) { printf(\"epoll timeout\\n\"); continue; } if (ret \u003c 0) { perror(\"epoll error\"); break; } for (int i = 0; i \u003c ret; i++) { if (events[i].events \u0026 EPOLLIN) { // 处理读事件，events[i].data.fd 为就绪的文件描述符 } if (events[i].events \u0026 EPOLLOUT) { // 处理写事件，events[i].data.fd 为就绪的文件描述符 } if (events[i].events \u0026 EPOLLERR) { // 处理异常事件，events[i].data.fd 为就绪的文件描述符 } } } kqueueIOCP几个问题1. select 和 poll 一无是处了吗？在学完这几个多路复用函数后，可能有些人会对 select 和 poll 感到失望。但是它们也有优点，比如 select 函数是跨平台的，无论你在 Linux、Windows 还是 macOS 下，都可以使用 select 函数。而改进的 IO 多路复用模型兼容性差，epoll 函数只能在 Linux 下使用，kqueue 函数只能在 FreeBSD 下使用，IOCP 函数只能在 Windows 下使用。\n除此之外，未必所有的程序都需要处理大量的并发连接，如果一个程序只需要处理十几个连接，那么选择 select 函数是优于 epoll 函数的。\n2. epoll 为什么使用红黑树而不是哈希表或 AVL 树？其实历史版本的 Linux 内核中，epoll 使用的是哈希表，但后面改用了红黑树。\n应用程序在调用 epoll 函数，尤其是当 epoll 监视的文件数量达到百万级的时候，对文件描述符的增删改查操作的频率很高，选用不同的数据结构带来的效率差异可能非常大。我们需要选择一个综合性能较好的数据结构。\n数据结构 插入 删除 查找 特点 红黑树 O(log n) O(log n) O(log n) 综合性能最优，最坏情况下时间复杂度为 O(log n) 哈希表 O(1) O(1) O(1) ReHashing 开销大即扩展性差，且难以抉择哈希表大小 AVL 树 O(log n) O(log n) O(log n) 查询效率稍快于红黑树，但插入删除效率稍慢于红黑树 综合考量，红黑树是最优选择。\n3. 为什么是 epitem 的成员指向就绪列表，而不是列表元素指向 epitem？有人可能会发现，在 epitem 结构体中，rdllink 指向就绪列表，而不是就绪列表的元素指向 epitem。这是由于 Linux 内核的链表设计哲学：“让万物包含链表，而不是链表包含万物。” Linux 内核可以通过 container_of 宏来获取链表元素的所在结构体地址，所以就绪列表的元素不需要指向 epitem。\n参考资料 TCP/IP 网络编程（伊圣雨）（书籍）\n如果这篇文章说不清epoll的本质，那就过来掐死我吧！（文章）\n源码解读epoll内核机制（文章）\n十个问题理解Linux epoll工作原理（文章）\n【并发】IO多路复用select/poll/epoll介绍（视频）\n腾讯面试：请描述 select、poll、epoll 这三种IO多路复用技术的执行原理（视频）\n","wordCount":"1332","inLanguage":"zh","datePublished":"2024-06-24T21:36:55+08:00","dateModified":"2024-06-24T21:36:55+08:00","author":{"@type":"Person","name":"Cassius0924"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"Cassius0924 的博客","logo":{"@type":"ImageObject","url":"https://blog.cassdev.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title="Cassius0924 的博客"><span>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.cassdev.com/>首页</a>&nbsp;»&nbsp;<a href=https://blog.cassdev.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Socket 编程之 IO 多路复用学习笔记</h1><div class=post-meta><span title='2024-06-24 21:36:55 +0800 +0800'>2024年06月24日</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Cassius0924</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af-io-%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8 aria-label="什么是 IO 多路复用？">什么是 IO 多路复用？</a><ul><li><a href=#%e9%98%bb%e5%a1%9e-io-%e4%b8%8e-%e9%9d%9e%e9%98%bb%e5%a1%9e-io aria-label="阻塞 IO 与 非阻塞 IO">阻塞 IO 与 非阻塞 IO</a></li><li><a href=#io-%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8 aria-label="IO 多路复用">IO 多路复用</a></li></ul></li><li><a href=#io-%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8%e7%9a%84%e4%bc%98%e7%82%b9 aria-label="IO 多路复用的优点">IO 多路复用的优点</a></li><li><a href=#io-%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f aria-label="IO 多路复用的实现方式">IO 多路复用的实现方式</a><ul><li><a href=#select aria-label=select>select</a></li><li><a href=#poll aria-label=poll>poll</a></li><li><a href=#epoll aria-label=epoll>epoll</a></li><li><a href=#kqueue aria-label=kqueue>kqueue</a></li><li><a href=#iocp aria-label=IOCP>IOCP</a></li></ul></li><li><a href=#%e5%87%a0%e4%b8%aa%e9%97%ae%e9%a2%98 aria-label=几个问题>几个问题</a><ul><li><a href=#1-select-%e5%92%8c-poll--%e4%b8%80%e6%97%a0%e6%98%af%e5%a4%84%e4%ba%86%e5%90%97 aria-label="1. select 和 poll  一无是处了吗？">1. select 和 poll 一无是处了吗？</a></li><li><a href=#2-epoll-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e7%ba%a2%e9%bb%91%e6%a0%91%e8%80%8c%e4%b8%8d%e6%98%af%e5%93%88%e5%b8%8c%e8%a1%a8%e6%88%96-avl-%e6%a0%91 aria-label="2. epoll 为什么使用红黑树而不是哈希表或 AVL 树？">2. epoll 为什么使用红黑树而不是哈希表或 AVL 树？</a></li><li><a href=#3-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af-epitem-%e7%9a%84%e6%88%90%e5%91%98%e6%8c%87%e5%90%91%e5%b0%b1%e7%bb%aa%e5%88%97%e8%a1%a8%e8%80%8c%e4%b8%8d%e6%98%af%e5%88%97%e8%a1%a8%e5%85%83%e7%b4%a0%e6%8c%87%e5%90%91-epitem aria-label="3. 为什么是 epitem 的成员指向就绪列表，而不是列表元素指向 epitem？">3. 为什么是 epitem 的成员指向就绪列表，而不是列表元素指向 epitem？</a></li></ul></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li></ul></div></details></div><div class=post-content><h2 id=什么是-io-多路复用>什么是 IO 多路复用？</h2><h3 id=阻塞-io-与-非阻塞-io>阻塞 IO 与 非阻塞 IO<a hidden class=anchor aria-hidden=true href=#什么是-io-多路复用>#</a></h3><p>我们先了解一下阻塞 IO，阻塞 IO 是指应用程序在读写数据时，如果没有数据可读或者写，应用程序会一直 <strong>阻塞在那里</strong> ，直到有数据可读或者写。</p><p>与它相反的是非阻塞 IO，是指应用程序在读写数据时，无论是否有数据可读写，都 <strong>立即返回</strong> ，若没有数据可读写将会返回一个错误码，通过不断轮询来检查是否有数据可读或者写。</p><h3 id=io-多路复用>IO 多路复用<a hidden class=anchor aria-hidden=true href=#io-多路复用>#</a></h3><p>由于 Scoket 默认是阻塞 IO，所以很多初学者在处理多个连接时，会为每个连接创建一个线程来处理，但这样做会引起 CPU 的上下文切换，降低系统的性能。</p><p>有一种更“优雅”的方式，那就是 IO 多路复用，也称为事件驱动模型（Event-driven IO）。IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 事件已经就绪，就通知该进程。IO 多路复用模型中，只需要一个线程就可以同时处理多个连接。</p><p>通俗易懂的说，IO 多路复用就是将多个 IO 事件交给内核，内核帮我们监听这些 IO 事件，当有 IO 事件就绪时，内核会通知我们，我们只需要处理就绪的 IO 事件即可。</p><h2 id=io-多路复用的优点>IO 多路复用的优点<a hidden class=anchor aria-hidden=true href=#io-多路复用的优点>#</a></h2><ul><li><p>一个线程可以同时处理多个连接，减少线程的创建和销毁</p></li><li><p>降低了系统开销，提高了系统的并发性能</p></li></ul><h2 id=io-多路复用的实现方式>IO 多路复用的实现方式<a hidden class=anchor aria-hidden=true href=#io-多路复用的实现方式>#</a></h2><ul><li><p>select</p></li><li><p>poll</p></li><li><p>epoll (Linux)</p></li><li><p>kqueue (FreeBSD)</p></li><li><p>IOCP（Windows）</p></li></ul><p>其中 epoll 是 Linux 下的 IO 多路复用机制，kqueue 是 FreeBSD（macOS 就属于 FreeBSD）下的 IO 多路复用机制。</p><p>下面的伪代码是 IO 多路复用的最基本实现方式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=nl>fd</span> <span class=p>:</span> <span class=n>fds</span><span class=p>)</span> <span class=p>{</span>    <span class=c1>// 遍历所有的文件描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=err>有数据</span><span class=p>)</span> <span class=p>{</span>    
</span></span><span class=line><span class=cl>            <span class=err>处理数据</span><span class=p>;</span>   <span class=c1>// 如果文件描述符有数据则处理数据
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果我们在自行编写的程序中使用上面的伪代码，那么每次判断 <code>fd</code> 是否有数据时，都需要询问内核，所以每次判断都会引起一次系统调用，也就是会从用户态切换到内核态，这样的效率是不够高的。</p><p>所以操作系统为我们提供了 <code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>、<code>ICOP</code> 这几种解决方案，它们可以在内核中直接监听文件描述符，当文件描述符就绪时，内核会通知我们，这样就不需要我们自己去轮询文件描述符了。</p><p>下面介绍一下五种方式的区别：</p><h3 id=select>select<a hidden class=anchor aria-hidden=true href=#select>#</a></h3><link rel=stylesheet href=/css/vendors/admonitions.4fd9a0b8ec8899f2ca952048d255a569f433f77dfb3f52f5bc87e7d65cdce449.css integrity="sha256-T9mguOyImfLKlSBI0lWlafQz9337P1L1vIfn1lzc5Ek=" crossorigin=anonymous><div class="admonition note"><div class=admonition-header><svg viewBox="0 0 576 512"><path d="M0 64C0 28.7 28.7.0 64 0H224v128c0 17.7 14.3 32 32 32h128v125.7l-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3.0-64-28.7-64-64V64zm384 64H256V0L384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9.0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6.0zM311.9 417 441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z"/></svg>
<span>笔记</span></div><div class=admonition-content><p><strong>前置知识</strong></p><ul><li><p><strong>fd_set</strong></p><p>fd_set（file descriptor set）是一个文件描述符集合，它本质上是一个 bitmap（位图），每个文件描述符对应一个位，如果文件描述符在集合中，则对应的位为 1，否则为 0。例如我们有 3 个文件描述符，分别为 <code>3</code>、<code>4</code>、<code>8</code>，那么 fd_set 的值为 <code>000110001</code>。</p></li><li><p><strong>struct timeval</strong></p><p>struct timeval 是一个结构体，用来表示时间，它有两个成员变量，分别是 <code>tv_sec</code> 和 <code>tv_usec</code>，分别表示秒和微秒。</p></li></ul></div></div><div class="admonition tip"><div class=admonition-header><svg viewBox="0 0 384 512"><path d="M272 384c9.6-31.9 29.5-59.1 49.2-86.2 5.2-7.1 10.4-14.2 15.4-21.4 19.8-28.5 31.4-63 31.4-100.3C368 78.8 289.2.0 192 0S16 78.8 16 176c0 37.3 11.6 71.9 31.4 100.3 5 7.2 10.2 14.3 15.4 21.4 19.8 27.1 39.7 54.4 49.2 86.2h160zM192 512c44.2.0 80-35.8 80-80v-16H112v16c0 44.2 35.8 80 80 80zM112 176c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-61.9 50.1-112 112-112 8.8.0 16 7.2 16 16s-7.2 16-16 16c-44.2.0-80 35.8-80 80z"/></svg>
<span>提示</span></div><div class=admonition-content><p><strong>文件描述符补充知识</strong></p><p>在 Linux 中，用户创建的文件描述符最小值为 3，因为 0、1、2 分别为标准输入、标准输出和标准错误。</p></div></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>select</span><span class=p>(</span><span class=kt>int</span> <span class=n>nfds</span><span class=p>,</span> <span class=n>fd_set</span> <span class=o>*</span><span class=n>readfds</span><span class=p>,</span> <span class=n>fd_set</span> <span class=o>*</span><span class=n>writefds</span><span class=p>,</span> <span class=n>fd_set</span> <span class=o>*</span><span class=n>exceptfds</span><span class=p>,</span> <span class=k>struct</span> <span class=n>timeval</span> <span class=o>*</span><span class=n>timeout</span><span class=p>);</span>
</span></span></code></pre></div><ul><li><p><strong>nfds</strong>：监听的文件描述符的最大值加 1</p></li><li><p><strong>readfds</strong>：读事件 fd 集合（输出参数）</p></li><li><p><strong>writefds</strong>：写事件 fd 集合（输出参数）</p></li><li><p><strong>exceptfds</strong>：异常事件 fd 集合（输出参数）</p></li><li><p><strong>timeout</strong>：超时时间，类型为 struct timeval</p></li><li><p><strong>函数返回值</strong>：就绪的文件描述符的数量，如果超时返回 0，出错返回 -1</p></li></ul><p>从函数原型可以看出，<code>select</code> 函数中间三个参数都是输出参数，我们只需要传入 <code>fd_set</code> 结构体的指针即可。我们需要给予 <code>select</code> 函数的数据只有监听的 <code>fd</code> 的最大值加 1 和监听超时时间，然后 <code>select</code> 函数就会帮我们监听这些文件描述符。</p><p>至于 nfds 为什么要加 1，是因为 <code>select</code> 函数是从 0 开始遍历文件描述符的。用刚刚 fd_set 的例子来说，如果我们不加 1，那么 <code>select</code> 函数只会遍历到 <code>00011000</code> 七个 fd，而不会遍历最后一个 <code>1</code> 对应的 fd。</p><p><code>timeout</code> 参数除了设置一个具体的时间值外，还可以设置为 <code>-1</code>，表示永久阻塞，直到有文件描述符就绪。如果设置为 <code>0</code>，则表示立即返回，不会阻塞。</p><p>select 的工作原理大致如下：</p><ol><li><p>用户态将需要监听的文件描述符集合传递给内核</p></li><li><p>内核将这些文件描述符集合拷贝到内核空间</p></li><li><p>内核循环遍历这些 fd ，如果有 fd 可读，则将 readfds 对应的位设置为 1，如果有 fd 可写，则将 writefds 对应的位设置为 1，如果有异常，则将 exceptfds 对应的位设置为 1</p></li><li><p>函数返回</p></li></ol><p><code>select</code> 函数每次调用时会将需要遍历的文件描述符直接一次全量拷贝到内核空间，并在内核态进行轮询判断，这样就不会引起用户态和内核态的频繁切换，自然也就提高了效率。</p><p>当 <code>select</code> 函数返回后，我们就可以通过判断 <code>readfds</code>、<code>writefds</code>、<code>exceptfds</code> 中的位来判断哪些文件描述符有数据可读、可写或者有异常。</p><p><code>select</code> 函数的使用示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1>// 假设 fds 为一个 fd 数组，里面存放了需要监听的文件描述符，fd_max 为 fds 中最大的 fd
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>fd_set</span> <span class=n>r_fdset</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fd_set</span> <span class=n>w_fdset</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fd_set</span> <span class=n>e_fdset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>FD_ZERO</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r_fdset</span><span class=p>);</span>  <span class=c1>// 清空 fd_set
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>FD_ZERO</span><span class=p>(</span><span class=o>&amp;</span><span class=n>w_fdset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>FD_ZERO</span><span class=p>(</span><span class=o>&amp;</span><span class=n>e_fdset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>fds</span><span class=p>.</span><span class=nf>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// 初始化 fd_set
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>FD_SET</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>r_fdset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>FD_SET</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>w_fdset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>FD_SET</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>e_fdset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>timeval</span> <span class=n>timeout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>timeout</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>  <span class=c1>// 设置超时时间为 5 秒
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>timeout</span><span class=p>.</span><span class=n>tv_usec</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=nf>select</span><span class=p>(</span><span class=n>fd_max</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>r_fdset</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>w_fdset</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>e_fdset</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;select timeout</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;select error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>fds</span><span class=p>.</span><span class=nf>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>FD_ISSET</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>r_fdset</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 处理读事件
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>FD_ISSET</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>w_fdset</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 处理写事件
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>FD_ISSET</span><span class=p>(</span><span class=n>fds</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>e_fdset</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 处理异常事件
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>select</code> 函数的缺点：</p><ul><li>fd_set 的大小有限，一般为 1024，所以 <code>select</code> 函数最多只能监听 1024 个文件描述符</li><li>fd_set 不可重用，每次调用 <code>select</code> 函数都需要重新初始化 fd_set。上述代码中，每次 while 循环都需要重新初始化 r_fdset、w_fdset 以及 e_fdset</li><li><code>select</code> 函数的时间复杂度为 O(n)，n 为文件描述符的数量</li><li>每次调用 <code>select</code> 函数都会将所有的文件描述符集合从用户态拷贝到内核态，这样仍有一定的开销</li><li>判断哪些文件描述符有数据可读、可写或者有异常时，需要再次遍历所有的文件描述符，时间复杂度为 O(n)，效率不高</li></ul><p><code>select</code> 函数有这些缺点也不奇怪，因为它是最早的 IO 多路复用函数，随着时间的推移，就出现了第二个 IO 多路复用函数 <code>poll</code>。</p><h3 id=poll>poll<a hidden class=anchor aria-hidden=true href=#poll>#</a></h3><div class="admonition note"><div class=admonition-header><svg viewBox="0 0 576 512"><path d="M0 64C0 28.7 28.7.0 64 0H224v128c0 17.7 14.3 32 32 32h128v125.7l-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3.0-64-28.7-64-64V64zm384 64H256V0L384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9.0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6.0zM311.9 417 441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z"/></svg>
<span>笔记</span></div><div class=admonition-content><p><strong>前置知识</strong></p><ul><li><p><strong>struct pollfd</strong></p><p>pollfd 是一个结构体，用来存放需要监听的文件描述符，它的定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>pollfd</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>         <span class=c1>// 文件描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>short</span> <span class=n>events</span><span class=p>;</span>   <span class=c1>// 需要监听的事件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>short</span> <span class=n>revents</span><span class=p>;</span>  <span class=c1>// 返回的事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>events 和 revents 都是一个位掩码，用来表示需要监听的事件和返回的事件，它们可以是以下几个值的组合（使用或 <code>|</code> 运算符）：</p><ul><li><code>POLLIN</code>：有数据可读，相当于 <code>POLLRDNORM | POLLRDBAND</code></li><li><code>POLLOUT</code>：有数据可写，相当于 <code>POLLWRNORM | POLLWRBAND</code></li><li><code>POLLERR</code>：有错误</li><li><code>POLLHUP</code>：挂起</li><li><code>POLLNVAL</code>：无效请求</li><li><code>POLLPRI</code>：有紧急数据</li><li><code>POLLRDBAND</code>：有带外数据可读</li><li><code>POLLRDNORM</code>：有普通数据可读</li><li><code>POLLWRBAND</code>：有带外数据可写</li><li><code>POLLWRNORM</code>：有普通数据可写</li></ul></li></ul></div></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>poll</span><span class=p>(</span><span class=k>struct</span> <span class=n>pollfd</span> <span class=o>*</span><span class=n>fds</span><span class=p>,</span> <span class=kt>nfds_t</span> <span class=n>nfds</span><span class=p>,</span> <span class=kt>int</span> <span class=n>timeout</span><span class=p>);</span>
</span></span></code></pre></div><ul><li><p><strong>fds</strong>：pollfd 结构体数组，用来存放需要监听的文件描述符</p></li><li><p><strong>nfds</strong>：fds 数组的大小</p></li><li><p><strong>timeout</strong>：超时时间，单位为毫秒</p></li><li><p><strong>函数返回值</strong>：与 <code>select</code> 函数一样，返回就绪的文件描述符的数量，如果超时返回 0，出错返回 -1</p></li></ul><p>可以看出，<code>poll</code> 比 <code>select</code> 少了两个参数，<code>fds</code> 既为输入参数，又为输出参数，<code>nfds</code> 为 fds 数组的大小，<code>timeout</code> 为超时时间。<code>poll</code> 函数在有 IO 事件或错误发生时，会将对应的 fd 的 revents 设置为对应的事件，我们只需要遍历 fds 数组，判断 revents 的值即可。</p><p><code>revents</code> 的默认值为 0，因此我们在处理完一个 fd 后，只需要将其 revents 设置为 0，这相比于 <code>select</code> 函数的 fd_set 初始化要简洁一些。</p><p><code>poll</code> 函数的最大亮点就是使用了 pollfd 结构体存放需要监听的文件描述符，所以 <code>poll</code> 函数不会有文件描述符个数的限制，相比于 <code>select</code> 函数能承受更高的并发量。</p><p><code>poll</code> 函数的使用示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1>// 假设 pollfds 为一个 pollfd 数组，里面存放了需要监听的文件描述符，pollfds_size 为 pollfds 的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>pollfds_size</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pollfds</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>events</span> <span class=o>=</span> <span class=n>POLLIN</span> <span class=o>|</span> <span class=n>POLLOUT</span> <span class=o>|</span> <span class=n>POLLERR</span><span class=p>;</span>  <span class=c1>// 设置需要监听的事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=nf>poll</span><span class=p>(</span><span class=n>pollfds</span><span class=p>,</span> <span class=n>pollfds_size</span><span class=p>,</span> <span class=mi>5000</span><span class=p>);</span>  <span class=c1>// 设置超时时间为 5 秒
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;poll timeout</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;poll error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nf>pollfds_size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>pollfds</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>revents</span> <span class=o>&amp;</span> <span class=n>POLLIN</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>pollfds</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>revents</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// 处理完后将 revents 设置为 0
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 处理读事件
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>pollfds</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>revents</span> <span class=o>&amp;</span> <span class=n>POLLOUT</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>pollfds</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>revents</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 处理写事件
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>pollfds</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>revents</span> <span class=o>&amp;</span> <span class=n>POLLERR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>pollfds</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>revents</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 处理异常事件
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>poll</code> 函数解决了 <code>select</code> 函数的 fd_set 大小有限、不可重用的问题，但是它仍有以下两个缺点：</p><ul><li>每次调用 <code>poll</code> 函数都会将所有的文件描述符集合从用户态拷贝到内核态</li><li><code>poll</code> 函数与 <code>select</code> 函数一样，为了判断文件描述符是否就绪，需要遍历所有的文件描述符</li></ul><p>是否能够不用每次调用都将文件描述符集合从用户态拷贝到内核态呢，而是只值传递一次呢？是否能够不用每次都遍历所有的文件描述符呢，而是只遍历就绪的文件描述符呢？答案是肯定的，这就是 <strong>epoll</strong>。</p><h3 id=epoll>epoll<a hidden class=anchor aria-hidden=true href=#epoll>#</a></h3><div class="admonition note"><div class=admonition-header><svg viewBox="0 0 576 512"><path d="M0 64C0 28.7 28.7.0 64 0H224v128c0 17.7 14.3 32 32 32h128v125.7l-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3.0-64-28.7-64-64V64zm384 64H256V0L384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9.0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6.0zM311.9 417 441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z"/></svg>
<span>笔记</span></div><div class=admonition-content><p><strong>前置知识</strong></p><ul><li><p><strong>epoll_event</strong></p><p>epoll_event 是一个结构体，用来存放需要监听的文件描述符，它的定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>union</span> <span class=n>epoll_data</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>__uint32_t</span> <span class=n>u32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>__uint64_t</span> <span class=n>u64</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kt>epoll_data_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>epoll_event</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>__uint32_t</span> <span class=n>events</span><span class=p>;</span>  <span class=c1>// 需要监听的事件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>epoll_data_t</span> <span class=n>data</span><span class=p>;</span>  <span class=c1>// 用户数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>events 是需要监听的事件，它可以是以下几个值的组合（使用或 <code>|</code> 运算符）：</p><ul><li><code>EPOLLIN</code>：有数据可读</li><li><code>EPOLLOUT</code>：有数据可写</li><li><code>EPOLLERR</code>：有错误</li><li><code>EPOLLHUP</code>：挂起</li><li><code>EPOLLPRI</code>：有 OOB 紧急数据</li><li><code>EPOLLRDHUP</code>：断开连接或者半关闭的情况，只有在边缘触发模式下才有效（关于边缘触发会在下文中介绍）</li><li><code>EPOLLONESHOT</code>：只监听一次事件，发生一次事件后，此文件描述符就不再收到事件通知。需要使用 <code>epoll_ctl</code> 的 <code>EPOLL_CTL_MOD</code> 修改事件</li><li><code>EPOLLET</code>：设置为边缘触发模式</li><li><code>EPOLLWAKEUP</code>：唤醒进程</li><li><code>EPOLLEXCLUSIVE</code>：独占模式</li></ul><p>data 是用户数据，一般用于存放文件描述符。</p></li></ul></div></div><p>epoll 共有三个函数：</p><ul><li><p><code>epoll_create</code>：创建一个 epoll 实例</p></li><li><p><code>epoll_ctl</code>：控制 epoll 实例中的文件描述符</p></li><li><p><code>epoll_wait</code>：等待就绪的文件描述符</p></li></ul><p>epoll 的 “e” 代表了 “event”，这是一个事件驱动的模型，即响应式的模型。内核不再需要 <strong>主动</strong> 轮询文件描述符，而是通过回调函数来实现通知进程，属于 <strong>被动响应</strong> 。</p><p>select 和 poll 都只有一个函数，所有功能都聚合到一个函数中，因此每次调用都需要传入需要监听的文件描述符，也就导致了每次都需要将文件描述符集合从用户态拷贝到内核态，增加了开销。</p><p>epoll 将 <strong>维护文件描述符集合</strong> 和 <strong>判断文件描述符是否就绪</strong> 两个功能进行了拆分，整个过程只需要使用 <code>epoll_ctl</code> 函数添加一次文件描述符，在 <code>epoll_wait</code> 函数中不再需要传入需要监听文件描述符，这样就大大减少了从用户态到内核态切换的开销。</p><p><img loading=lazy src=https://s2.loli.net/2024/06/20/1NOKzukrtp5Aev6.jpg></p><hr><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_create</span><span class=p>(</span><span class=kt>int</span> <span class=n>size</span><span class=p>);</span>
</span></span></code></pre></div><blockquote><p><em>Linux 手册：</em></p><p><em>epoll_create() creates a new epoll(7) instance. Since Linux 2.6.8, the size argument is ignored, but must be greater than zero; see HISTORY.</em></p></blockquote><p>根据 Linux 手册，<code>epoll_create</code> 函数的 <code>size</code> 参数在 Linux 2.6.8 之后被忽略，但是必须大于 0。所以我们可以将 <code>size</code> 参数设置为 <code>1</code>。根本原因是内核支持了动态扩容，所以 <code>size</code> 参数不再有意义，但为了向下兼容，<code>size</code> 参数仍然需要传入。</p><p><code>epoll_create</code> 函数作用是创建一个 eventpoll 结构体（ <em>epoll 实例</em> ），函数返回值是一个非负的文件描述符，用于操作 eventpoll，如果返回 <code>-1</code> 则表示创建失败，并且 <code>errno</code> 会被设置为相应的错误码。这个文件描述符与其他文件描述符一样，需要通过 <code>close</code> 函数关闭，否则文件描述符会被耗尽。</p><p>eventpoll 是一个内核数据结构，由操作系统管理，其内部有三个重要的字段：</p><ul><li><p><strong>红黑树</strong>：用来存放需要监听的文件描述符，时间复杂度为 <code>O(log n)</code></p></li><li><p><strong>就绪列表</strong>：用来存放就绪的文件描述符，是一个双向循环链表，其作用就是告诉内核哪些文件描述符的哪些事件已经就绪</p></li><li><p><strong>等待队列</strong>：用来存放等待的进程/线程</p></li></ul><p>通过 eventpoll 可知，与 select 和 poll 采用的 <strong>线性结构</strong> 的方式存储文件描述符不同，eventpoll 维护了一个名为 <code>rbr</code> 的红黑树，用来存放需要监听的文件描述符，采用了 <strong>树形结构</strong> 存储文件描述符，将查询操作的时间复杂度从 <code>O(n)</code> 降低到了 <code>O(log n)</code>。</p><p>eventpoll 还维护了一个名为 <code>rdllist</code> 的就绪列表，用来存放就绪的文件描述符。当文件描述符就绪时，其会被 <code>rdllist</code> 引用，因此用户只需要获取 <code>rdllist</code> 中的内容即可知道哪些文件描述符就绪。</p><p>由于一个 epoll 实例可以被多个进程共享，即一个 <code>epfd</code> 可以被多个进程的 <code>epoll_wait</code> 函数调用，所以 eventpoll 还维护了一个名为 <code>wq</code> 的等待队列，用来存放等待中（阻塞中）的线程。</p><p><code>epoll_create</code> 的工作原理大致如下：</p><ul><li><p>为 <code>eventpoll</code> 申请空间，并且初始化其成员，如红黑树、就绪列表和等待队列等</p></li><li><p>为 <code>eventpoll</code> 申请一个未使用的文件描述符 <code>fd</code></p></li><li><p>申请一个满足 VFS 的虚拟文件结构体 <code>file</code></p></li><li><p><code>eventpoll</code> 与 <code>file</code> 关联，将 <code>fd</code> 和 <code>file</code> 关联起来</p></li><li><p>返回 <code>fd</code></p></li></ul><hr><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_ctl</span><span class=p>(</span><span class=kt>int</span> <span class=n>epfd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>op</span><span class=p>,</span> <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>epoll_event</span> <span class=o>*</span><span class=n>event</span><span class=p>);</span>
</span></span></code></pre></div><ul><li><p><strong>epfd</strong>：epoll 实例的文件描述符，即 <code>epoll_create</code> 函数返回的文件描述符</p></li><li><p><strong>op</strong>：操作类型，Linux 为我们定义了三个宏：</p><ul><li><p><code>EPOLL_CTL_ADD</code>：添加一个文件描述符到 epoll 实例中</p></li><li><p><code>EPOLL_CTL_MOD</code>：修改一个文件描述符在 epoll 实例中的事件</p></li><li><p><code>EPOLL_CTL_DEL</code>：从 epoll 实例中删除一个文件描述符</p></li></ul></li><li><p><strong>fd</strong>：需要监听的文件描述符</p></li><li><p><strong>event</strong>：epoll_event 结构体，用来存放需要监听的事件</p></li><li><p><strong>函数返回值</strong>：成功返回 0，失败返回 -1，并且 <code>errno</code> 会被设置为相应的错误码</p></li></ul><p><code>epoll_ctl</code> 函数（ <em>epoll control</em> ）用来控制 epoll 实例中的文件描述符，可以添加、修改或者删除文件描述符。</p><p>阅读下面代码语句：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>epoll_ctl</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>EPOLL_CTL_ADD</span><span class=p>,</span> <span class=n>B</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>C</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>epoll_ctl</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>EPOLL_CTL_DEL</span><span class=p>,</span> <span class=n>B</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span></code></pre></div><p>第一条语句的意思是在 epoll 实例 <code>A</code> 中注册（添加）文件描述符 <code>B</code>，并监听参数 <code>C</code> 中的事件。 第二条语句的意思是在 epoll 实例 <code>A</code> 中删除文件描述符 <code>B</code>。可以看出在删除文件描述符时，不需要传入事件参数。</p><p>由于 <code>epoll_ctl</code> 函数的实现里有互斥锁的存在，所以它是一个线程安全的函数，多个线程/进程可以并发调用 <code>epoll_ctl</code> 函数。</p><p>在调用 <code>epoll_ctl</code> 函数时，<code>epoll_ctl</code> 函数会为每个文件描述符创建一个 epitem 结构体，这个结构体用来存放文件描述符的信息，包括文件描述符、事件、回调函数等。这个 <code>epitem</code> 结构体会被添加到 eventpoll 的红黑树中。</p><p>epitem 结构体的定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>epitem</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>rb_node</span> <span class=n>rbn</span><span class=p>;</span>  <span class=c1>// 红黑树节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>list_head</span> <span class=n>rdllink</span><span class=p>;</span>  <span class=c1>// 就绪列表节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>eppoll_entry</span> <span class=o>*</span><span class=n>pwqlist</span><span class=p>;</span>  <span class=c1>// socket 等待队列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>eventpoll</span><span class=o>*</span> <span class=n>ep</span><span class=p>;</span>   <span class=c1>// 指向 eventpoll 结构体
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>event</span><span class=p>;</span>  <span class=c1>// 事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><code>epoll_ctl(ADD)</code> 函数的工作原理大致如下：</p><ol><li><p>将 <code>event</code> 拷贝到内核空间</p></li><li><p>尝试在红黑树中查找 <code>fd</code> 对应的 <code>epitem</code> 结构体</p></li><li><p>找不到则创建一个新的 <code>epitem</code>，并将 <code>epitem</code> 添加到红黑树中</p></li><li><p>创建一个 <code>epitem</code> 对应的 <code>eppoll_entry</code> 用于链接到 socket 等待队列，并为 <code>eppoll_entry</code> 设置回调函数</p></li><li><p>将 <code>eppoll_entry</code> 添加到 socket 等待队列中</p></li><li><p>检查该 socket 的读写缓冲区和状态，如果有事件发生，则将 <code>epitem</code> 添加到就绪列表中，并且唤醒 <code>eventpoll.wq</code> 中的等待进程</p></li><li><p>函数返回</p></li></ol><hr><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_wait</span><span class=p>(</span><span class=kt>int</span> <span class=n>epfd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>epoll_event</span> <span class=o>*</span><span class=n>events</span><span class=p>,</span> <span class=kt>int</span> <span class=n>maxevents</span><span class=p>,</span> <span class=kt>int</span> <span class=n>timeout</span><span class=p>);</span>
</span></span></code></pre></div><ul><li><p><strong>epfd</strong>：epoll 实例的文件描述符</p></li><li><p><strong>events</strong>：用来存放就绪的文件描述符</p></li><li><p><strong>maxevents</strong>：events 数组的大小</p></li><li><p><strong>timeout</strong>：超时时间，单位为毫秒</p></li><li><p><strong>函数返回值</strong>：返回就绪的文件描述符的数量，如果超时返回 0，出错返回 -1</p></li></ul><p>其中 <code>epfd</code> 和 <code>timeout</code> 参数皆为输入参数，<code>events</code> 为输出参数，我们只需要传入空的 <code>epoll_event</code> 数组即可。<code>events</code> 数组会被填充就绪的文件描述符，所以其大小 <code>maxevents</code> 应该大于等于监听的文件描述符的数量。</p><p><code>epoll_wait</code> 函数会检查 epoll 实例的就绪链表，如果就绪链表中有文件描述符，则将其添加到 <code>events</code> 数组中，然后返回就绪的文件描述符的数量。如果就绪链表为空，则会阻塞直到有文件描述符就绪或者超时。</p><p><code>epoll_wait</code> 函数的工作原理大致如下：</p><ol><li><p>通过传入的 <code>epfd</code> 找到对应的 <code>eventpoll</code> 结构体</p></li><li><p>判断 <code>eventpoll.rdllist</code> 是否有 <code>epitem</code>，有则代表有 <code>epitem</code> 就绪，但不一定是我们感兴趣的事件，所以需要进一步判断</p></li><li><p>若 <code>rdllist</code> 不为空，则遍历它，获取 <code>epitem</code> 的 <code>socket</code> 后，在 <code>rdllist</code> 中删除此 <code>epitem</code>，接着判断 <code>socket</code> 具体触发的事件类型是否为我们需要监听的事件</p></li><li><p>若是我们需要监听的事件，则将此事件拷贝回用户态的 <code>events</code> 数组中，函数返回</p></li><li><p>若是水平触发模式，则将 <code>epitem</code> 重新添加到 <code>rdllist</code> 中，以便下次再次判断</p></li><li><p>若 <code>rdllist</code> 为空，则判断是否超时，若超时则直接返回</p></li><li><p>未超时则将该进程加入到 <code>eventpoll.wq</code> 进程等待队列中，并且将进程置为可中断睡眠状态，等待唤醒</p></li><li><p>唤醒后，将进程设置为运行状态，并在 <code>wq</code> 中删除该进程</p></li><li><p>重复 2-8 步骤，直到超时或者有文件描述符就绪</p></li></ol><div class="admonition note"><div class=admonition-header><svg viewBox="0 0 576 512"><path d="M0 64C0 28.7 28.7.0 64 0H224v128c0 17.7 14.3 32 32 32h128v125.7l-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3.0-64-28.7-64-64V64zm384 64H256V0L384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9.0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6.0zM311.9 417 441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z"/></svg>
<span>笔记</span></div><div class=admonition-content><p>注意，epoll 并没有采用共享内存的方式，阅读源码可知，epoll 采用了内核态和用户态的数据拷贝：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>epoll_put_uevent</span><span class=p>(</span><span class=n>__poll_t</span> <span class=n>revents</span><span class=p>,</span> <span class=n>__u64</span> <span class=n>data</span><span class=p>,</span> <span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>__user</span> <span class=o>*</span><span class=n>uevent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// __put_user 是内核态到用户态的数据拷贝的函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=nf>__put_user</span><span class=p>(</span><span class=n>revents</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>uevent</span><span class=o>-&gt;</span><span class=n>events</span><span class=p>)</span> <span class=o>||</span> <span class=nf>__put_user</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>uevent</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>uevent</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div></div><div class="admonition note"><div class=admonition-header><svg viewBox="0 0 576 512"><path d="M0 64C0 28.7 28.7.0 64 0H224v128c0 17.7 14.3 32 32 32h128v125.7l-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3.0-64-28.7-64-64V64zm384 64H256V0L384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9.0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6.0zM311.9 417 441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z"/></svg>
<span>笔记</span></div><div class=admonition-content><p><strong>epoll 的两种触发模式</strong></p><p>epoll 有两种触发模式，分别是 <strong>水平触发模式</strong>（ <em>Level Trigger</em> ）和 <strong>边缘触发模式</strong>（ <em>Edge Trigger</em> ）。水平触发模式是 epoll 默认的工作模式。</p><ul><li><p><strong>水平触发模式（ <em>LT模式</em> ）</strong>：相当于时序电路中的高电平触发。关注点是 <strong>数据</strong>，只要读操作缓冲区不为空或写操作缓冲区不为满，<code>epoll_wait</code> 就会返回就绪事件。</p></li><li><p><strong>边缘触发模式（ <em>ET模式</em> ）</strong>：相当于时序电路中的边沿出发。关注点是 <strong>变化</strong>，只有当有数据写接收进缓冲区或者从发送缓冲区读出数据时，<code>epoll_wait</code> 才会返回就绪事件。</p></li></ul></div></div><p><code>epoll</code> 函数的使用示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1>// 假设 epfd 为 epoll 实例的文件描述符，fds 为需要监听的文件描述符数组，fds_size 为 fds 的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>events</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>epfd</span> <span class=o>=</span> <span class=nf>epoll_create</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>ev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ev</span><span class=p>.</span><span class=n>events</span> <span class=o>=</span> <span class=n>EPOLLIN</span> <span class=o>|</span> <span class=n>EPOLLOUT</span> <span class=o>|</span> <span class=n>EPOLLERR</span><span class=p>;</span>  <span class=c1>// 设置需要监听的事件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ev</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>fd</span> <span class=o>=</span> <span class=n>fds</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>  <span class=c1>// 设置需要监听的文件描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>epoll_ctl</span><span class=p>(</span><span class=n>epfd</span><span class=p>,</span> <span class=n>EPOLL_CTL_ADD</span><span class=p>,</span> <span class=n>ev</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ev</span><span class=p>);</span>  <span class=c1>// 注册文件描述符和事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=nf>epoll_wait</span><span class=p>(</span><span class=n>epfd</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>5000</span><span class=p>);</span>  <span class=c1>// 设置超时时间为 5 秒
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;epoll timeout</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;epoll error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>ret</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>EPOLLIN</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 处理读事件，events[i].data.fd 为就绪的文件描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>EPOLLOUT</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 处理写事件，events[i].data.fd 为就绪的文件描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>EPOLLERR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 处理异常事件，events[i].data.fd 为就绪的文件描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=kqueue>kqueue</h3><h3 id=iocp>IOCP</h3><h2 id=几个问题>几个问题</h2><h3 id=1-select-和-poll--一无是处了吗>1. select 和 poll 一无是处了吗？<a hidden class=anchor aria-hidden=true href=#kqueue>#</a></h3><p>在学完这几个多路复用函数后，可能有些人会对 select 和 poll 感到失望。但是它们也有优点，比如 <code>select</code> 函数是跨平台的，无论你在 Linux、Windows 还是 macOS 下，都可以使用 <code>select</code> 函数。而改进的 IO 多路复用模型兼容性差，<code>epoll</code> 函数只能在 Linux 下使用，<code>kqueue</code> 函数只能在 FreeBSD 下使用，<code>IOCP</code> 函数只能在 Windows 下使用。</p><p>除此之外，未必所有的程序都需要处理大量的并发连接，如果一个程序只需要处理十几个连接，那么选择 <code>select</code> 函数是优于 <code>epoll</code> 函数的。</p><h3 id=2-epoll-为什么使用红黑树而不是哈希表或-avl-树>2. epoll 为什么使用红黑树而不是哈希表或 AVL 树？<a hidden class=anchor aria-hidden=true href=#2-epoll-为什么使用红黑树而不是哈希表或-avl-树>#</a></h3><p>其实历史版本的 Linux 内核中，<code>epoll</code> 使用的是哈希表，但后面改用了红黑树。</p><p>应用程序在调用 epoll 函数，尤其是当 epoll 监视的文件数量达到百万级的时候，对文件描述符的增删改查操作的频率很高，选用不同的数据结构带来的效率差异可能非常大。我们需要选择一个综合性能较好的数据结构。</p><table><thead><tr><th>数据结构</th><th>插入</th><th>删除</th><th>查找</th><th>特点</th></tr></thead><tbody><tr><td>红黑树</td><td>O(log n)</td><td>O(log n)</td><td>O(log n)</td><td>综合性能最优，最坏情况下时间复杂度为 O(log n)</td></tr><tr><td>哈希表</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>ReHashing 开销大即扩展性差，且难以抉择哈希表大小</td></tr><tr><td>AVL 树</td><td>O(log n)</td><td>O(log n)</td><td>O(log n)</td><td>查询效率稍快于红黑树，但插入删除效率稍慢于红黑树</td></tr></tbody></table><p>综合考量，红黑树是最优选择。</p><h3 id=3-为什么是-epitem-的成员指向就绪列表而不是列表元素指向-epitem>3. 为什么是 <code>epitem</code> 的成员指向就绪列表，而不是列表元素指向 <code>epitem</code>？<a hidden class=anchor aria-hidden=true href=#3-为什么是-epitem-的成员指向就绪列表而不是列表元素指向-epitem>#</a></h3><p>有人可能会发现，在 <code>epitem</code> 结构体中，<code>rdllink</code> 指向就绪列表，而不是就绪列表的元素指向 <code>epitem</code>。这是由于 Linux 内核的链表设计哲学：“让万物包含链表，而不是链表包含万物。” Linux 内核可以通过 <code>container_of</code> 宏来获取链表元素的所在结构体地址，所以就绪列表的元素不需要指向 <code>epitem</code>。</p><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li><p><a href=https://book.douban.com/subject/25911735>TCP/IP 网络编程（伊圣雨）</a>（书籍）</p></li><li><p><a href=https://zhuanlan.zhihu.com/p/63179839>如果这篇文章说不清epoll的本质，那就过来掐死我吧！</a>（文章）</p></li><li><p><a href=https://gityuan.com/2019/01/06/linux-epoll/>源码解读epoll内核机制</a>（文章）</p></li><li><p><a href=https://mp.weixin.qq.com/s/h3CBZt2KEA-ScXFSKHaRBg>十个问题理解Linux epoll工作原理</a>（文章）</p></li><li><p><a href=https://www.bilibili.com/video/BV1qJ411w7du>【并发】IO多路复用select/poll/epoll介绍</a>（视频）</p></li><li><p><a href=https://www.bilibili.com/video/BV1gN411e7gd>腾讯面试：请描述 select、poll、epoll 这三种IO多路复用技术的执行原理</a>（视频）</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.cassdev.com/tags/socket/>Socket</a></li><li><a href=https://blog.cassdev.com/tags/io-multiplexing/>IO Multiplexing</a></li><li><a href=https://blog.cassdev.com/tags/asynchronous-i/o/>Asynchronous I/O</a></li><li><a href=https://blog.cassdev.com/tags/network-programming/>Network Programming</a></li><li><a href=https://blog.cassdev.com/tags/notes/>Notes</a></li></ul></footer></article></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>