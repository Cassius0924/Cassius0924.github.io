<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Cassius0924 的博客</title><meta name=keywords content><meta name=description content="Posts - Cassius0924 的博客"><meta name=author content><link rel=canonical href=https://blog.cassdev.com/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.cassdev.com/posts/index.xml><link rel=alternate hreflang=zh href=https://blog.cassdev.com/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/posts/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.cassdev.com/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title=首页><span>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/gallery/ title=图库><span>图库</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://blog.cassdev.com/>主页</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>macOS Word 更好的快捷键配置指南 Microsoft Word在macOS平台上是一款功能强大的文字处理工具，然而，要使其与macOS原生编辑器更好地无缝切换，合理配置快捷键是至关重要的。本指南将介绍一些新的macOS Word的快捷键，使您能够更高效地编辑文档，同时保持与系统级快捷键的一致性。
快捷键 Word快捷键名 备注 Ctrl + A StartOfLine 跳到行首 Ctrl + E EndOfLine 跳到行尾 Ctrl + N LineDown 下一行 Ctrl + P LineUp 上一行 Ctrl + F CharRight 下一个字符 Ctrl + B CharLeft 上一个字符 Ctrl + J NextPage 跳到下一页 Ctrl + K PrevPage 跳到上一页 Ctrl + V PasteTextOnly 无格式粘贴 Ctrl + H Highlight 高亮选中的文字 Ctrl + T TableInsertTable 插入表格 Cmd + Shift + F NavPaneSearch 高级面板搜索 Option + Return TableInsertRowBelow 在表格下方插入一行</p></div><footer class=entry-footer>1 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/macos-word-%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>macOS Word 设置论文排版指南 正文 字体大小默认12，两端对齐，1.5倍行距。字体类型选择 Latin 文字，将字体改成 Times New Roman，再将字体类型改成 Asian 亚洲文字，将字体改成 SimHei（黑体）。
带首行缩进的正文 打开样式面板，点击 New Style。
输入样式名称“Indent”，继承于 Normal 样式。
左下角选择 Paragraph 面板，将 Special 改成 First line，后面填 0.86cm。
各级标题 一级标题 打开 Heading 1 一级标题的设置。
字体大小默认16，加粗，黑色，居中对齐，1.5倍行距。字体类型选择 Latin 文字，将字体改成 Times New Roman，再将字体类型改成 Asian 亚洲文字，将字体改成 SimHei（黑体）。
左下角选择 Paragraph 面板，将 Special 改成 none，取消继承于正文样式（Normal）的值。
...</p></div><footer class=entry-footer>1 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/macos-word-%E8%AE%BE%E7%BD%AE%E8%AE%BA%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>macOS 为 Google Coral Dev Board 刷入系统镜像指南 本指南旨在帮助 macOS 开发者为 Google Coral Dev Board （Google Edege TPU） 通过 OTG 刷入 Mendel Linux 系统。
第一步：连接到开发板串行控制台 安装 USB 转 UART Bridge VCP 驱动程序 官方下载地址：https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers?tab=downloads
下载完成后，双击运行并安装即可。
安装辅助程序 通过 Homebrew 安装：
sudo brew install screen fastboot 连接开发板 先不给开发板供电，使用 micro-B USB 线将 Mac 连接到开发板。连接成功后会开发板会亮起绿色🟩和橙色🟧指示灯。
随后使用命令查看串口连接是否正常工作：
ls /dev/cu* 连接正常应该会列出/dev/cu.SLAB_USBtoUART，如下图所示。
然后使用screen命令连接开发板串行命令行：
screen /dev/cu.SLAB_USBtoUART 115200 此时命令行应为空白，因为开发板未供电开机。
给开发板供电 如图所示，将开发板电源插入，电源接口为右边的 USB-C 接口。
连接后开发板会亮起电源指示灯并转动风扇。串行命令行则会打印开发板的开机信息：
...</p></div><footer class=entry-footer>2 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/macos-%E4%B8%BA-google-coral-dev-board-%E5%88%B7%E5%85%A5%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>macOS 设置自动复制短信验证码指南 前提 接受短信验证码的 SMI 卡必须在上 iPhone iPhone 和 macOS 须登录同一个 iCloud 打开短信转发 打开 iPhone 的设置，找到 Message 短信 App 的设置。
往下拉，找到 Text Message Forwarding 短信转发并点击，打开需要被转发的 Mac 电脑。若你有 iPda，也可以顺便转发至 iPad。
打开 macOS 的 Message 短信应用，按下快捷键 command+, 打开设置。打开 iMessage 面板，勾选需要接受的短信来源。
下载 MessAuto 点击跳转 Github 下载地址
下载自己电脑对应的版本，M系列的芯片下载第一个，Intel芯片下载第二个。
下载完毕后，解压压缩包会直接得到一个名为 MessAuto.app 的应用程序文件，需要将它拖进 Applicatioin 文件夹里。
打开 Finder，按下快捷键command+ T 创建新的标签页，再按下 command+shift+A打开 Application 应用程序文件夹。
回到第一个标签页，将 MessAuto.app 拖到 Application 文件夹下。
...</p></div><footer class=entry-footer>1 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/macos-%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%A4%8D%E5%88%B6%E6%B6%88%E6%81%AF%E9%AA%8C%E8%AF%81%E7%A0%81%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Redis 为什么采用单线程，为什么性能好 Redis 采用单线程的原因是因为在 内存中 进行读写操作，CPU不是Redis的性能瓶颈，而是内存和带宽，所以采用单线程可以避免 线程切换和锁的开销。
Redis 是什么？ Redis 是一个开源的内存数据库，它可以存储键值对，支持多种数据结构，如字符串（string）、哈希（hash）、列表（list）、集合（set）、有序集合（zset）等。
Redis 是不是单线程？ 实际上，Redis 是多线程的，其内部有以下几个线程：
redis-server：主线程，负责接收客户端的连接，读取请求，发送响应。
bio-close-file：负责异步关闭大文件。
bio-aof-fsync：负责将 AOF 文件异步刷到磁盘。
bio-lasy-free：负责异步释放大内存。
jemalloc-bg-thread：负责内存碎片整理。
io-thread：IO 线程，负责 read/write，decode/encode。
[!NOTE]
AOF（Append Only File） 是 Redis 的一种持久化方式，将所有写操作追加到文件末尾，重启时重新执行 AOF 文件中的命令即可恢复数据。实时硬盘操作，不会丢失数据，但是会影响性能。
除了 AOF，Redis 还有一种持久化方式是 RDB（Redis DataBase） ，它是将内存中的数据快照保存到磁盘上。非实时硬盘操作，可能会丢失数据，但是性能更好。
Redis 为什么采用单线程？ Redis 不是 CPU 密集型应用，CPU 不是 Redis 的性能瓶颈。
如果采用多线程，会导致加锁解锁的开销大，CPU 上下文切换开销大。数据库请求量变化大，一会有请求，一会无请求，多线程会在运行和阻塞状态来回切换。
单线程的 Redis 为什么速度很快？ Redis 机制 内存数据库：Redis 是一个内存数据库，内存的读写速度相比于磁盘的读写速度要快很多。
数据结构高效：Redis 使用了很多高效的数据结构，如哈希表、跳表等。
使用了 Reactor 模型：Redis 使用了 Reactor 模型，采用了 IO 多路复用技术，可以处理多个客户端请求。采用的是非阻塞 IO，不会因为一个 IO 阻塞导致其他任务无法执行。
...</p></div><footer class=entry-footer>1 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E5%A5%BD/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Socket 编程之 epoll 源码分析学习笔记 本文基于 Linux 6.9 内核源码进行分析。
几个数据结构 eventpoll 这是 epoll 的主要数据结构，它用于存储 epoll 的相关信息，包括等待队列、就绪队列、红黑树等。
struct eventpoll { wait_queue_head_t wq; // epoll 的等待队列：用于存储等待的进程/线程，指向等待队列头 wait_queue_head_t poll_wait;// 这个 poll_wait 等待队列只有在 epoll 嵌套的情况下才会用到 struct list_head rdllist; // 就绪队列：用于存储就绪的 fd，指向就绪队列头 struct rb_root_cached rbr; // 红黑树：用于存储所有的 fd，指向红黑树根节点 struct wakeup_source *ws; // 一个唤醒源，用于唤醒进程 }; epitem epitem 的作用是将 fd、就绪队列、红黑树节点等信息封装在一起。
struct epitem { union { struct rb_node rbn; // 红黑树节点，用于存储 fd，指向红黑树节点 struct rcu_head rcu; // 用于释放 epitem }; struct list_head rdllink; // 就绪队列节点，用于存储就绪的 fd，指向就绪队列节点 struct eventpoll *ep; // 指向 eventpoll struct epoll_filefd ffd; // epoll 文件描述符 struct wakeup_source *ws; // 一个唤醒源，用于唤醒进程 struct epoll_event event; // 监听的事件 }; ep_pqueue 给 poll 队列封装的结构体，用于存储 poll_table 和 epitem。
...</p></div><footer class=entry-footer>9 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-epoll-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Socket 编程之 IO 多路复用学习笔记 什么是 IO 多路复用？ 阻塞 IO 与 非阻塞 IO 我们先了解一下阻塞 IO，阻塞 IO 是指应用程序在读写数据时，如果没有数据可读或者写，应用程序会一直 阻塞在那里 ，直到有数据可读或者写。
与它相反的是非阻塞 IO，是指应用程序在读写数据时，无论是否有数据可读写，都 立即返回 ，若没有数据可读写将会返回一个错误码，通过不断轮询来检查是否有数据可读或者写。
IO 多路复用 由于 Scoket 默认是阻塞 IO，所以很多初学者在处理多个连接时，会为每个连接创建一个线程来处理，但这样做会引起 CPU 的上下文切换，降低系统的性能。
有一种更“优雅”的方式，那就是 IO 多路复用，也称为事件驱动模型（Event-driven IO）。IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 事件已经就绪，就通知该进程。IO 多路复用模型中，只需要一个线程就可以同时处理多个连接。
通俗易懂的说，IO 多路复用就是将多个 IO 事件交给内核，内核帮我们监听这些 IO 事件，当有 IO 事件就绪时，内核会通知我们，我们只需要处理就绪的 IO 事件即可。
IO 多路复用的优点 一个线程可以同时处理多个连接，减少线程的创建和销毁
降低了系统开销，提高了系统的并发性能
IO 多路复用的实现方式 select
poll
epoll (Linux)
kqueue (FreeBSD)
IOCP（Windows）
其中 epoll 是 Linux 下的 IO 多路复用机制，kqueue 是 FreeBSD（macOS 就属于 FreeBSD）下的 IO 多路复用机制。
...</p></div><footer class=entry-footer>7 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>SSH 远程连接后解决 No protocol specified 指南 参考链接：https://unix.stackexchange.com/questions/209746/how-to-resolve-no-protocol-specified-for-su-user</p></div><footer class=entry-footer>1 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/ssh-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%90%8E%E8%A7%A3%E5%86%B3-no-protocol-specified-%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>TCP 的常见拥塞控制算法学习笔记 TCP 的拥塞控制算法有几种：
Tahoe
Reno
NewReno
SACK
BIC
CUBIC
BBR
[!NOTE]
MSS: Maximum Segment Size，最大分段大小。
cwnd: Congestion Window，拥塞窗口，单位为 MSS。
ssthresh: Slow Start Threshold，慢启动阈值，单位为 MSS。
RTO: Retransmission TimeOut，重传超时时间。
Tahoe Tahoe 只有两种状态：慢启动和拥塞避免。
慢启动阶段：cwnd = 1; ssthresh = 65535;。
每次收到一个 ACK，cwnd = cwnd + 1;，所以一个 RTT 内 cwnd 会翻倍，cwnd 呈指数增长。
拥塞避免阶段：cwnd = cwnd + 1;。
每次收到一个 ACK，cwnd = cwnd + 1 / cwnd;，所以每个 RTT 内 cwnd 只会增加 1，cwnd 呈线性增长。
触发事件：RTO 超时 或 3 个冗余 ACK。
...</p></div><footer class=entry-footer>1 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/tcp-%E7%9A%84%E5%B8%B8%E8%A7%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Ubuntu Neovim 安装和配置指南 安装 不建议使用apt安装，因为apt安装的版本总是不是最新版。一些neovim插件依赖于高版本的neovim，因此使用apt安装可能会导致一些插件无法正常使用。
下面介绍安装最新版neovim的方法。
下载安装压缩包：
wget https://github.com/neovim/neovim/releases/latest/download/nvim-linux64.tar.gz 安装：
tar xzvf nvim-linux64.tar.gz cp ./nvim-linux64/bin/nvim /usr/bin/ 测试：
nvim -v nvim配置 核心配置 配置 nvim 需要先创建配置文件的文件夹。
cd ~ mkdir -r .config/nvim cd .config/nvim nvim 使用 lua 语言作为配置文件语言，新建 init.lua，该文件是 nvim 的配置的入口。
touch init.lua 模块化配置 nvim 支持模块化配置，所以可以在 nvim 文件夹下创建多个配置模块：
mkdir -r lua/core cd lua/core core 文件夹存放 nvim 的核心配置，例如 nvim 基础配置（options.lua）和快捷键配置（keymaps）：
touch options.lua keymaps.lua 此时，neovim 的配置文件结构如下所示：
~ `--.config `-- nvim |-- init.lua |-- lua | |-- core | | |-- keymaps.lua | | `-- options.lua | `-- plugins | `-- plugins-setup.lua `-- plugin `-- packer_compiled.lua 回到 init.lua 文件，在 init.lua 中调用刚刚新建的两个模块：
...</p></div><footer class=entry-footer>1 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/ubuntu-neovim-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.cassdev.com/posts/page/5/>«&nbsp;上一页&nbsp;5/8
</a><a class=next href=https://blog.cassdev.com/posts/page/7/>下一页&nbsp;7/8&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>