<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Cassius0924 的博客</title><meta name=keywords content><meta name=description content="Posts - Cassius0924 的博客"><meta name=author content><link rel=canonical href=https://blog.cassdev.com/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.4f5249ac184c033613d94c5267209e90161d3a93365c2feb0ad3960a4bbb6393.css integrity="sha256-T1JJrBhMAzYT2UxSZyCekBYdOpM2XC/rCtOWCku7Y5M=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.cassdev.com/posts/index.xml><link rel=alternate hreflang=zh href=https://blog.cassdev.com/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/posts/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.cassdev.com/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title="Cassius0924 的博客"><span>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://blog.cassdev.com/>主页</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YOLO 目标检测算法学习笔记（一）</h2></header><div class=entry-content><p>深度学习经典检测方法 one-stage（单阶段）：YOLO系列
two-stage（双阶段）：Faster-Rcnn、Mask-Rcnn系列
Faster-Rcnn：物体检测开山之作。
one-stage 单阶段检测优势：速度快，适合做实时检测任务。
缺点：效果不佳。
目标检测的两个主要指标：mAP和FPS。
mAP：检测效果的综合指标。（mAP值越大效果越好）
two-stage 双阶段检测优势：效果较好。
缺点：速度较慢、不适合用于视频流的实时检测。
Mask-Rcnn是一个非常实用的通用框架（建议了解）。</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to YOLO 目标检测算法学习笔记（一）" href=https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>基于 L2CAP 协议的蓝牙 BLE 设备通信指南</h2></header><div class=entry-content><p>蓝牙 BLE 是什么蓝牙BLE，即蓝牙低功耗 （Bluetooth Lower Energy）是一种蓝牙通信标准，设计用于短距离通信和低功耗应用。
相比经典蓝牙，BLE 更加节能，传输距离更远，连接更快。BLE 主要用于健身设备、医疗设备、家居自动化等场景。
蓝牙 BLE 设备的连接信道L2CAP的基本概念是信道（Signaling Channel）。信道是个抽象概念，表示两个设备某个协议层之间的通道。每个信道分配一个2字节的信道ID——CID（Channel ID），每个信道功用不同，比如CID=0x0004的信道表示属性协议（Attribute Protocol）专用信道。对于BLE协议，L2CAP共有三个信道ID：
0x0004 – 属性协议 0x0005 – 低功耗信令信道 0x0006 – 安全管理协议 其他信道则用于经典蓝牙。协议复用可以理解为，不同的协议走不同的信道，互不干扰。
代码#define ATT_CID 4; // 创建 L2CAP socket int s = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP); // 绑定 L2CAP socket struct sockaddr_l2 bind_addr = {0}; bind_addr.l2_family = AF_BLUETOOTH; bind_addr.l2_cid = htobs(ATT_CID); // ATT 信道 CID bdaddr_t any_addr = {{0, 0, 0, 0, 0, 0}}; bacpy(&amp;bind_addr.l2_bdaddr, &amp;any_addr); bind_addr.l2_bdaddr_type = BDADDR_LE_PUBLIC; int err = bind(s, (struct sockaddr *)&amp;bind_addr, sizeof(bind_addr)); if (err) { return -1; } // 连接 L2CAP socket struct sockaddr_l2 conn_addr = {0}; conn_addr.l2_family = AF_BLUETOOTH; conn_addr.l2_cid = htobs(ATT_CID); // ATT CID str2ba(mac_address.c_str(), &amp;conn_addr.l2_bdaddr); conn_addr.l2_bdaddr_type = BDADDR_LE_PUBLIC; err = connect(s, (struct sockaddr *)&amp;conn_addr, sizeof(conn_addr)); if (err) { exit(-1); } L2CAP 数据包解析L2CAP（Logical Linked Control and Adaptation Protocol 逻辑链路控制与适配协议）工作在链路层,为上层协议提供数据通道。它支持数据分片与重组,确保数据完整可靠地传输。
...</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 基于 L2CAP 协议的蓝牙 BLE 设备通信指南" href=https://blog.cassdev.com/posts/%E5%9F%BA%E4%BA%8E-l2cap-%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%93%9D%E7%89%99-ble-%E8%AE%BE%E5%A4%87%E9%80%9A%E4%BF%A1%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>解决VScode远程开发C++项目时无代码提示问题</h2></header><div class=entry-content><p>简单粗暴，给本地主机和远程主机都安装上C/C++插件即可。</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 解决VScode远程开发C++项目时无代码提示问题" href=https://blog.cassdev.com/posts/%E8%A7%A3%E5%86%B3vscode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91c++%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%97%A0%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA%E9%97%AE%E9%A2%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>三维重建笔记——从变换矩阵中提取并分析平移量</h2></header><div class=entry-content><p>在编写点云变换和姿态估计代码时，我们经常需要从结果的变换矩阵中提取平移信息，并分析平移量的大小，帮助判断结果的准确性。
本文将介绍如何从变换矩阵中提取平移向量，并计算其欧几里得长度。
提取平移向量假设我们通过某种姿态估计算法得到了一个4x4的变换矩阵 result.transformation_ ,其中包含了旋转和平移信息。
我们可以通过以下代码提取出平移部分:（以Open3D为例）
core::Tensor translation = result.transformation_.Slice(0, 0, 3).Slice(1, 3, 4); Slice(0,0,3);表示从矩阵的第0维(行)，第0行开始，取3行，即前3行；Slice(1,3,4);表示从矩阵的第1维(列)，第3列开始，取1列，即第4列。 最后获得一个3x1的平移向量，包含x、y、z三个方向的平移量。
计算欧几里得长度有了平移向量后,我们可以计算其欧几里得长度,表示平移量的大小:
double translation_norm = std::sqrt((translation * translation).Sum({0, 1}).Item&lt;double>()); std::sqrt计算平方根，translation * translation 计算向量每个元素的平方，Sum 聚合，最终得到平移向量的L2范数，即欧几里得长度。
分析平移量通过提取并计算平移向量的模长，我们可以分析相机或物体的移动距离，以及姿态估计结果的准确性。
如果 translation_norm 的值过大，可能表示估计存在误差，需要反复优化算法。
设置不同的阈值可以根据实际场景需求，判断平移量是否在允许的范围内。
以上是从变换矩阵中提取和利用平移信息的简单示例，可以提供点云变换和姿态估计任务有用的辅助分析。</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 三维重建笔记——从变换矩阵中提取并分析平移量" href=https://blog.cassdev.com/posts/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%AC%94%E8%AE%B0%E4%BB%8E%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%8F%90%E5%8F%96%E5%B9%B6%E5%88%86%E6%9E%90%E5%B9%B3%E7%A7%BB%E9%87%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>通过 frp 内网穿透实现异地 SSH 连接（反向代理）</h2></header><div class=entry-content><p>起因是我放假回家，想在家里通过 SSH 连接放在学校的无显示器的 Linux，但是学校的 Linux 是内网，无法直接连接，且无显示器无法使用向日葵等远程桌面软件，所以想到了使用 frp 的反向代理功能实现内网穿透，进而实现异地 SSH 连接。
前提 一台具有公网 IP 的服务器（阿里云、腾讯云等） 配置远程主机我们需要有三台主机，分别是：自己的电脑、远程 Linux 主机和具有公网 IP 的服务器。
只需要在远程 Linux 和具有公网 IP 的服务器上配置 frp 即可。
首先在远程 Linux 上下载 frp，Github 下载地址。下载远程主机对应的版本，我这里是 ARM64 架构的 Linux，所以下载 frp_0.51.2_linux_arm64.tar.gz。
下载完毕后解压：
tar -xvf frp_0.51.2_linux_arm64.tar.gz cd frp_0.51.2_linux_arm64 远程 Linux 为客户端，所以只需要保留 frpc* 文件即可，frps可以删除。
rm frps* 修改frpc.ini，只需要将server_addr修改为服务器的 IP 地址即可，local_ip不变。server_port和remote_port一般不变，若与其他服务冲突了可以修改。
vim frpc.ini #:wq 退出 配置服务器同样下载好对应系统版本的 frp，解压后删除frpc*文件。
rm frpc* 修改frpc.ini，确保bind_port与 frpc 客户端，即远程主机的server_port一致。
再前往阿里云或腾讯云官网配置服务器防火墙规则，开放服务器的 6000 和 7000 端口（若修改了则开放修改后的端口）。
...</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 通过 frp 内网穿透实现异地 SSH 连接（反向代理）" href=https://blog.cassdev.com/posts/%E9%80%9A%E8%BF%87-frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%9C%B0-ssh-%E8%BF%9E%E6%8E%A5%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ Copy&amp;Swap 惯用法指南</h2></header><div class=entry-content><p>Copy&amp;Swap 是什么Copy&amp;Swap 是一种 C++ 中常用的编程技巧，用于实现类的赋值运算符（operator=）。
实现传统写法先看看未使用 Copy&amp;Swap 的赋值运算符写法：
#include &lt;iostream> #include &lt;vector> class OldAClass { private: int _count; std::string _str; std::vector&lt;int> _vec; public: OldAClass() : _count(0), _vec(10) {} // 拷贝构造函数 和 拷贝赋值运算符 OldAClass(OldAClass &amp;a) : _count(a._count), _str(a._str), _vec(a._vec) { std::cout &lt;&lt; "Copy constructor called\n"; } OldAClass &amp;operator=(OldAClass &amp;a) { std::cout &lt;&lt; "Copy Assignment operator called\n"; if (this != &amp;a) { //判断传入的 a 是否是自己 _count = a._count; _str = a._str; _vec = a._vec; } return *this; } // 移动构造函数 和 移动赋值运算符 OldAClass(OldAClass &&amp;a) noexcept : _count(a._count), _str(std::move(a._str)), _vec(std::move(a._vec)) { std::cout &lt;&lt; "Move constructor called\n"; } OldAClass &amp;operator=(OldAClass &&amp;a) noexcept { std::cout &lt;&lt; "Move Assignment operator called\n"; if (this != &amp;a) { _count = a._count; _str = std::move(a._str); _vec = std::move(a._vec); } return *this; } }; 可以看到，这种写法需要重复写两次赋值运算符，并且每次都需要判断传入的参数是否是自己，而且代码重复度高。
Copy&amp;Swap 写法class AClass { private: int _count; std::string _str; std::vector&lt;int> _vec; public: AClass() : _count(0), _vec(10) {} static void swap(AClass &amp;a, AClass &amp;b) { std::swap(a._count, b._count); std::swap(a._str, b._str); std::swap(a._vec, b._vec); } // 拷贝构造函数 AClass(AClass &amp;a) : _count(a._count), _str(a._str), _vec(a._vec) { std::cout &lt;&lt; "Copy constructor called\n"; } // 移动构造函数 AClass(AClass &&amp;a) noexcept { std::cout &lt;&lt; "Move constructor called\n"; swap(*this, a); } // 赋值运算符 AClass &amp;operator=(AClass a) { // 注意这里的参数是值传递，会调用拷贝构造函数 std::cout &lt;&lt; "Assignment operator called\n"; swap(*this, a); return *this; } }; 这种写法只需要写一次赋值运算符，代码更简洁，而且不需要判断传入的参数是否是自己。
...</p></div><footer class=entry-footer><span title='2024-01-15 10:00:00 +0800 +0800'>2024年01月15日</span>&nbsp;·&nbsp;2 分钟</footer><a class=entry-link aria-label="post link to C++ Copy&Swap 惯用法指南" href=https://blog.cassdev.com/posts/c++-copyswap-%E6%83%AF%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Jetson (Ubuntu Arm64) 安装 Bazel</h2></header><div class=entry-content><p>简介本文旨在帮助用户在 Jetson 上的 Ubuntu Arm64 系统上安装 Bazel。Bazel 是一个开源的构建工具，它专注于构建和测试大型软件项目，并且被广泛应用于机器学习和深度学习领域。通过使用 Bazel，您可以更高效地管理和构建您的项目。
步骤 1：安装OpenJDK在开始安装 Bazel 之前，我们需要安装 OpenJDK。在终端中执行以下命令：
sudo add-apt-repository ppa:webupd8team/java sudo apt-get update sudo apt-get install openjdk-11-jdk 步骤 2：下载 Bazel 安装包在安装 OpenJDK 之后，我们需要下载 Bazel 的安装包。在终端中执行以下命令：
wget https://github.com/bazelbuild/bazel/releases/download/6.2.1/bazel-6.2.1-dist.zip 或者，您也可以从 Bazel 的 Github 仓库下载最新版本的安装包。（必须下载dist.zip文件）
步骤 3：安装 Bazel下载完成后，我们可以使用以下命令来安装 Bazel：
unzip bazel-6.2.1-dist.zip -d bazel-6.2.1 bash./compile.sh sudo cp output/bazel /usr/local/bin 步骤 4：验证安装安装完成后，我们可以验证 Bazel 是否成功安装。在终端中执行以下命令：
bazel version 如果一切正常，您应该能够看到如下输出：</p></div><footer class=entry-footer><span title='2023-06-14 10:00:00 +0800 +0800'>2023年06月14日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Jetson (Ubuntu Arm64) 安装 Bazel" href=https://blog.cassdev.com/posts/jetson-ubuntu-arm64-%E5%AE%89%E8%A3%85-bazel/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Ubuntu 安装 Protobuf 指南</h2></header><div class=entry-content><p>Protobuf（Protocol Buffers）是一种轻量级的数据交换格式，常用于高效地序列化结构化数据。本指南将介绍如何在 Ubuntu 上安装 Protobuf。
步骤 1：更新系统在安装 Protobuf 之前，我们首先需要确保系统已经更新到最新版本。打开终端并执行以下命令：
sudo apt update sudo apt upgrade 这将更新系统的软件包并安装最新的安全补丁。
步骤 2：安装编译工具和依赖项在安装 Protobuf 之前，我们需要安装一些编译工具和依赖项。执行以下命令来安装它们：
sudo apt install build-essential autoconf libtool 这些工具和依赖项将帮助我们编译和构建 Protobuf。
步骤 3：下载和编译 Protobuf 首先，我们需要下载 Protobuf 的源代码。这里选择下载v3.20.3版本的Protobuf源码压缩包。（必须下载-all压缩包）
解压压缩包
tar -zxvf protobuf-all-3.20.3.tar.gz 这将克隆 Protobuf 的源代码到当前目录。
进入克隆下来的 Protobuf 目录： cd protobuf-all-3.20.3 在源代码目录中，运行以下命令来生成配置文件和构建系统： ./autogen.sh 接下来，我们需要运行 configure 脚本来配置编译选项。可以使用以下命令进行配置： ./configure 配置完成后，我们可以使用以下命令编译和安装 Protobuf： sudo make sudo make check #这一步可能会报错，解决方法见下文 sudo make install sudo ldconfig 编译过程可能需要一些时间，请耐心等待。
步骤 4：验证安装安装完成后，我们可以验证 Protobuf 是否成功安装。执行以下命令来检查 Protobuf 的版本信息：
...</p></div><footer class=entry-footer><span title='2023-06-12 10:00:00 +0800 +0800'>2023年06月12日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Ubuntu 安装 Protobuf 指南" href=https://blog.cassdev.com/posts/ubuntu-%E5%AE%89%E8%A3%85-protobuf/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>解决 Open3D 同时链接其他库时的 Undefined Reference 错误</h2></header><div class=entry-content><p>当你的 Open3D 项目同时使用了 OpenCV 或 Protobuf 等其他库时，在链接库时可能会出现 Undefined Reference 的错误。这是因为 Open3D 默认使用的 C++ ABI 版本与其他库不一致导致的。
为了解决这个问题，可以在重新编译安装 Open3D 时打开 -DGLIBCXX_USE_CXX11_ABI=ON 选项，即使用 C++11 ABI 版本。以下是具体的步骤：
解决方法找到 Open3D 源码cd open3d 找不到请在 Github 上重新下载。
重新编译安装 Open3D进入 Open3D 的源代码目录的 build 子目录进行编译安装。
cd build 在 build 子目录中执行 CMake 命令生成 Makefile。在命令行中添加 -DGLIBCXX_USE_CXX11_ABI=ON 选项。
cmake .. -DBUILD_SHARED_LIBS=ON -DGLIBCXX_USE_CXX11_ABI=ON -DCMAKE_BUILD_TYPE=Release 最后，执行 make 命令编译并安装 Open3D。
make -j6 sudo make install 使用 Open3D重新编译安装后的 Open3D 就能够正常链接其他库了。</p></div><footer class=entry-footer><span title='2023-06-09 10:00:00 +0800 +0800'>2023年06月09日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 解决 Open3D 同时链接其他库时的 Undefined Reference 错误" href=https://blog.cassdev.com/posts/%E8%A7%A3%E5%86%B3-open3d-%E5%90%8C%E6%97%B6%E9%93%BE%E6%8E%A5%E5%85%B6%E4%BB%96%E5%BA%93%E6%97%B6%E7%9A%84-undefined-reference-%E9%94%99%E8%AF%AF/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Unity 脚本使用 NuGet 安装解决方案包</h2></header><div class=entry-content><p>本文旨在教大家如何在 Unity 中使用 NuGet 安装解决方案包。
Visual Studio 集成了 NuGet 管理器，可以方便的安装和卸载解决方案包。但在使用 Viusal Studio 开发 Unity C# 脚本时，不能直接在内置的 NuGet 管理器安装解决方案包。因为 Unity 工程打开或运行时会刷新工程文件，导致我们在 Visual Studio 内置 NuGet 管理器安装的解决方案包失效。所以 Unity 使用 NuGet 安装解决方案包需要特殊步骤。
步骤下载解决方案包在NuGet官网下载你需要解决方案包，例如Google.Protobuf。
直接下载会下载最新预览版，稳定版需要点击右上角的 Full stats，查看所有版本。
找到稳定版 3.22.4，点击即可下载。
解压包下载后会得到拓展名为.nupkg的文件，先将文件拓展名改为.zip，接着解压即可。
导入dll文件解压后可以得到 dll 文件，位于 google.protobuf.3.22.4/lib/**/Google.Protobuf.dll ，将dll文件复制到 Unity 工程文件夹的 Assets/Plugins 文件夹下，若没有这个文件夹自己手动新建一个。
配置Unity项目接着需要将 Unity 项目的 Api Compatibility Level 更改为与 dll 文件对应的版本。打开 Unity 的 Project Settings，找到 Player > Other Settings > Api Compatibility Level。
...</p></div><footer class=entry-footer><span title='2023-06-01 10:00:00 +0800 +0800'>2023年06月01日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Unity 脚本使用 NuGet 安装解决方案包" href=https://blog.cassdev.com/posts/unity-%E4%BD%BF%E7%94%A8-nuget-%E5%AE%89%E8%A3%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%8C%85/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.cassdev.com/posts/page/5/>«&nbsp;上一页&nbsp;5/8
</a><a class=next href=https://blog.cassdev.com/posts/page/7/>下一页&nbsp;7/8&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>