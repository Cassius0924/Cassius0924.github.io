<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Cassius0924 的博客</title><meta name=keywords content><meta name=description content="Posts - Cassius0924 的博客"><meta name=author content><link rel=canonical href=https://blog.cassdev.com/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.4f5249ac184c033613d94c5267209e90161d3a93365c2feb0ad3960a4bbb6393.css integrity="sha256-T1JJrBhMAzYT2UxSZyCekBYdOpM2XC/rCtOWCku7Y5M=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.cassdev.com/posts/index.xml><link rel=alternate hreflang=zh href=https://blog.cassdev.com/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/posts/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.cassdev.com/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title="Cassius0924 的博客"><span>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/gallery/ title=图库><span>图库</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://blog.cassdev.com/>主页</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>在编写点云变换和姿态估计代码时，我们经常需要从结果的变换矩阵中提取平移信息，并分析平移量的大小，帮助判断结果的准确性。
本文将介绍如何从变换矩阵中提取平移向量，并计算其欧几里得长度。
提取平移向量假设我们通过某种姿态估计算法得到了一个4x4的变换矩阵 result.transformation_ ,其中包含了旋转和平移信息。
我们可以通过以下代码提取出平移部分:（以Open3D为例）
core::Tensor translation = result.transformation_.Slice(0, 0, 3).Slice(1, 3, 4); Slice(0,0,3);表示从矩阵的第0维(行)，第0行开始，取3行，即前3行；Slice(1,3,4);表示从矩阵的第1维(列)，第3列开始，取1列，即第4列。 最后获得一个3x1的平移向量，包含x、y、z三个方向的平移量。
计算欧几里得长度有了平移向量后,我们可以计算其欧几里得长度,表示平移量的大小:
double translation_norm = std::sqrt((translation * translation).Sum({0, 1}).Item&lt;double>()); std::sqrt计算平方根，translation * translation 计算向量每个元素的平方，Sum 聚合，最终得到平移向量的L2范数，即欧几里得长度。
分析平移量通过提取并计算平移向量的模长，我们可以分析相机或物体的移动距离，以及姿态估计结果的准确性。
如果 translation_norm 的值过大，可能表示估计存在误差，需要反复优化算法。
设置不同的阈值可以根据实际场景需求，判断平移量是否在允许的范围内。
以上是从变换矩阵中提取和利用平移信息的简单示例，可以提供点云变换和姿态估计任务有用的辅助分析。</p></div><footer class=entry-footer>1 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%AC%94%E8%AE%B0%E4%BB%8E%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%8F%90%E5%8F%96%E5%B9%B6%E5%88%86%E6%9E%90%E5%B9%B3%E7%A7%BB%E9%87%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>我的开源项目 JTGO： JSON Template with GO，基于 Go 的 JSON 模板引擎，支持条件语句、循环、函数调用等功能，可以用于生成动态的 JSON 数据。
WeChatter： 基于 wechatbot-webhook 的微信机器人，支持 GPT 问答、热搜、天气预报、消息转发、小游戏、Webhook 提醒等功能。
TetrisTwins： 基于终端的双人竞赛俄罗斯方块小游戏，用 C++17 编写。
Cpp-Style-Guide：由我编写的个人 C++ 代码风格规范。
Scel2Rime：macOS 的 Rime 输入法自动化工具，自动下载词库并转成 YAML 格式，自动部署 Rime。
MultipleSearch：快捷切换搜索引擎的油猴脚本。
我的技术栈Languages Technologies & Frameworks Games Libraries & Tools 我的邮箱联系我：cassius0924@qq.com</p></div><footer class=entry-footer>1 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/%E4%B8%BB%E9%A1%B5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>链地址法链地址法也叫做拉链法，它的基本思想是，将哈希表中的每个槽位都指向一个链表，当发生哈希冲突时，将数据插入到链表中。
很好理解，如图所示：
开放定址法开放定址法是一种解决哈希冲突的方法，它的基本思想是，当发生哈希冲突时，不是将数据直接插入到哈希表中，而是寻找哈希表中的空槽位，将数据插入到空槽位中。
线性探测线性探测采用固定步长的线性搜索来进行探测。
插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 1），直至找到空桶，将元素插入其中。 查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 value 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 None 。 注意，我们不能在开放寻址哈希表中直接删除元素。因为删除元素会在数组内产生一个空桶 None ，当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在。
为了解决该问题，我们可以采用懒删除（ lazy deletion ）机制，不直接从哈希表中移除元素，而是利用一个常量 TOMBSTONE 来标记这个桶。
None 和 TOMBSTONE 都代表空桶，都可以放置键值对。线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。在线性探测中记录遇到的首个 TOMBSTONE 的索引，并将搜索到的目标元素与该 TOMBSTONE 交换位置，这样可以优化效率。
线性探测容易产生 聚集现象，为了缓解这个问题，就有了平方探测和双重散列。
平方探测平方探测思想与线性探测类似，不同之处在于探测的步长是平方级别的。即当发生哈希冲突时，探测的步长为 1，4，9，…步。
平方探测可以缓解线性探测的聚集现象，但不能彻底解决。
多次哈希多次哈希的基本思想是，当发生哈希冲突时，尝试其他的哈希函数，直到找到空槽位。
与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。
警告 以上三种方法，线性探测、平方探测和多次哈希哈希表都存在 不能直接删除元素 的问题。
...</p></div><footer class=entry-footer>1 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>蓝牙 BLE 是什么蓝牙BLE，即蓝牙低功耗 （Bluetooth Lower Energy）是一种蓝牙通信标准，设计用于短距离通信和低功耗应用。
相比经典蓝牙，BLE 更加节能，传输距离更远，连接更快。BLE 主要用于健身设备、医疗设备、家居自动化等场景。
蓝牙 BLE 设备的连接信道L2CAP的基本概念是信道（Signaling Channel）。信道是个抽象概念，表示两个设备某个协议层之间的通道。每个信道分配一个2字节的信道ID——CID（Channel ID），每个信道功用不同，比如CID=0x0004的信道表示属性协议（Attribute Protocol）专用信道。对于BLE协议，L2CAP共有三个信道ID：
0x0004 – 属性协议 0x0005 – 低功耗信令信道 0x0006 – 安全管理协议 其他信道则用于经典蓝牙。协议复用可以理解为，不同的协议走不同的信道，互不干扰。
代码#define ATT_CID 4; // 创建 L2CAP socket int s = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP); // 绑定 L2CAP socket struct sockaddr_l2 bind_addr = {0}; bind_addr.l2_family = AF_BLUETOOTH; bind_addr.l2_cid = htobs(ATT_CID); // ATT 信道 CID bdaddr_t any_addr = {{0, 0, 0, 0, 0, 0}}; bacpy(&amp;bind_addr.l2_bdaddr, &amp;any_addr); bind_addr.l2_bdaddr_type = BDADDR_LE_PUBLIC; int err = bind(s, (struct sockaddr *)&amp;bind_addr, sizeof(bind_addr)); if (err) { return -1; } // 连接 L2CAP socket struct sockaddr_l2 conn_addr = {0}; conn_addr.l2_family = AF_BLUETOOTH; conn_addr.l2_cid = htobs(ATT_CID); // ATT CID str2ba(mac_address.c_str(), &amp;conn_addr.l2_bdaddr); conn_addr.l2_bdaddr_type = BDADDR_LE_PUBLIC; err = connect(s, (struct sockaddr *)&amp;conn_addr, sizeof(conn_addr)); if (err) { exit(-1); } L2CAP 数据包解析L2CAP（Logical Linked Control and Adaptation Protocol 逻辑链路控制与适配协议）工作在链路层,为上层协议提供数据通道。它支持数据分片与重组,确保数据完整可靠地传输。
...</p></div><footer class=entry-footer>3 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/%E5%9F%BA%E4%BA%8E-l2cap-%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%93%9D%E7%89%99-ble-%E8%AE%BE%E5%A4%87%E9%80%9A%E4%BF%A1%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>在学习堆排序之前，我们先来了解一下堆这种数据结构。
堆的概念堆是一种特殊的树形数据结构，它满足以下性质：
堆必须是一个 完全二叉树 。 堆序性：堆中任意节点的值总是不大于或不小于其子节点的值。 根据堆序性，我们可以将堆分为两种类型：
大顶堆：每个节点的值都大于或等于其子节点的值
小顶堆：每个节点的值都小于或等于其子节点的值
所以，如果一个完全二叉树的一个节点即大于其父节点，又大于其子节点，那么这个树就不是一个堆。小于同理。
笔记 完全二叉树的性质
...</p></div><footer class=entry-footer>2 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>本文章主要介绍如何使用 GitHub Actions 实现基于 MkDocs 的 GitHub.io 个人静态博客的自动化部署。
本指南主要分为以下几个部分：
创建 GitHub 仓库 创建 MkDocs 项目 配置 GitHub Actions 部署到 GitHub Pages 创建 GitHub 仓库由于我们的博客是托管在 GitHub io 上的，所以我们需要一个 GitHub 仓库来存放我们的 MkDocs 博客。
创建仓库首先，我们需要在 GitHub 上创建一个新的仓库，仓库名可以是 &lt;username>.github.io，其中 &lt;username> 是你的 GitHub 用户名。
克隆仓库然后，我们需要将这个仓库克隆到本地：
git clone &lt;repository-url> cd &lt;repository-name> 创建 MkDocs 项目安装 MkDocsMkDocs 是一个 Python 项目使用 pip 安装：
pip install mkdocs 我们需要创建一个 MkDocs 项目，可以使用 MkDocs 官方提供的模板来创建。直接在仓库根目录执行以下命令即可：
mkdocs new . 然后，我们需要安装 MkDocs Material 主题。当然我们也可以选择其他主题，可以在 MkDocs 的 WiKi 查看更多主题。
...</p></div><footer class=entry-footer>3 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%9A%84-github.io-%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>起因是因为我在对我的 C++ 项目进行跨平台适配，从 macOS 平台移植到 Windows 平台时，在使用 Cmake + MSVC 编译后，出现了这个问题。
问题原因这是由于 Windows 平台默认使用的是 GBK 编码，而 macOS 平台上使用的是 UTF-8 编码。
解决方法方法一在 CMakeLists.txt 文件中添加如下代码：
add_compile_options("$&lt;$&lt;C_COMPILER_ID:MSVC>:/source-charset:utf-8>") 方法二在 CMakeLists.txt 文件中添加如下代码：
if(MSVC) target_compile_options(&lt;你的项目名> PRIVATE "/utf-8") endif()</p></div><footer class=entry-footer>1 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/%E8%A7%A3%E5%86%B3-warning-c4819--%E8%AF%A5%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8D%E8%83%BD%E5%9C%A8%E5%BD%93%E5%89%8D%E4%BB%A3%E7%A0%81%E9%A1%B5936%E4%B8%AD%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%AD%97%E7%AC%A6-%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>简单粗暴，给本地主机和远程主机都安装上C/C++插件即可。</p></div><footer class=entry-footer>1 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/%E8%A7%A3%E5%86%B3vscode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91c++%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%97%A0%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA%E9%97%AE%E9%A2%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>语法高亮是指在IDE或编辑器中，对文本进行分词，即将文本拆解为 Token（标记），每个 Token 都有对应的名称（作用域）进行标记。再配合主题样式规则，对不同名称的 Token 的进行主题化，以提高代码的可读性。
程序员离不开语法高亮，就像作家离不开标点符号一样。（你可以代入一下使用 txt 文本编辑器写代码的场景）
语法高亮由两个部分组成：
分词（Tokenization）：将文本拆解为一系列 Token。 主题化（Theming）：对 Token 进行样式渲染，如字体颜色、背景色、加粗等。 我们以 JSON 的语法为例，简单介绍一下语法高亮的过程。
首先分词引擎会对 JSON 文本进行分词，下图是将 JSON 文本进行分词后的结果，其中每个矩形所包括的文本都是一个 Token，每个 Token 都有一个作用域名称，例如 null 对应的是 constant.language.json 作用域。
然后主题化引擎会根据 Token 的作用域名称，对 Token 进行样式渲染，例如将 constant.language.json 作用域映射为蓝色不加粗字体。那么 null 就会被渲染为蓝色不加粗字体。
2. 分词的实现方式目前主流的分词实现方式大致有有以下三种：
基于正则表达式的分词：Textmate 基于词法分析的分词：Highlight.js 基于语法树的分词：Tree-sitter (如果有其他，欢迎补充) 本文只讨论 Textmate 的语法高亮规则编写。
Textmate 原是 MacOS 下的一款文本编辑器，其语法高亮规则是基于正则表达式的，但由于其规则简单易懂，且支持多种语言，因此被广泛应用于各种编辑器和IDE中，如 VSCode、Sublime Text 等。JetBrains 的 IDE 也集成了 Textmate Bundle 插件，可以直接导入 Textmate 的语法高亮规则。
...</p></div><footer class=entry-footer>2 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>起因是我放假回家，想在家里通过 SSH 连接放在学校的无显示器的 Linux，但是学校的 Linux 是内网，无法直接连接，且无显示器无法使用向日葵等远程桌面软件，所以想到了使用 frp 的反向代理功能实现内网穿透，进而实现异地 SSH 连接。
前提 一台具有公网 IP 的服务器（阿里云、腾讯云等） 配置远程主机我们需要有三台主机，分别是：自己的电脑、远程 Linux 主机和具有公网 IP 的服务器。
只需要在远程 Linux 和具有公网 IP 的服务器上配置 frp 即可。
首先在远程 Linux 上下载 frp，Github 下载地址。下载远程主机对应的版本，我这里是 ARM64 架构的 Linux，所以下载 frp_0.51.2_linux_arm64.tar.gz。
下载完毕后解压：
tar -xvf frp_0.51.2_linux_arm64.tar.gz cd frp_0.51.2_linux_arm64 远程 Linux 为客户端，所以只需要保留 frpc* 文件即可，frps可以删除。
rm frps* 修改frpc.ini，只需要将server_addr修改为服务器的 IP 地址即可，local_ip不变。server_port和remote_port一般不变，若与其他服务冲突了可以修改。
vim frpc.ini #:wq 退出 配置服务器同样下载好对应系统版本的 frp，解压后删除frpc*文件。
rm frpc* 修改frpc.ini，确保bind_port与 frpc 客户端，即远程主机的server_port一致。
再前往阿里云或腾讯云官网配置服务器防火墙规则，开放服务器的 6000 和 7000 端口（若修改了则开放修改后的端口）。
...</p></div><footer class=entry-footer>1 分钟</footer><a class=entry-link aria-label="post link to " href=https://blog.cassdev.com/posts/%E9%80%9A%E8%BF%87-frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%9C%B0-ssh-%E8%BF%9E%E6%8E%A5%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.cassdev.com/posts/page/7/>«&nbsp;上一页&nbsp;7/8</a></nav></footer></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>