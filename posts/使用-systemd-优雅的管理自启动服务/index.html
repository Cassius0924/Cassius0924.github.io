<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用 systemd 优雅的管理自启动服务 | Cassius0924 的博客</title><meta name=keywords content="Linux,systemd,服务管理,自启动"><meta name=description content="介绍如何使用 systemd 来管理和配置 Linux 系统中的自启动服务。"><meta name=author content="Cassius0924"><link rel=canonical href=https://blog.cassdev.com/posts/%E4%BD%BF%E7%94%A8-systemd-%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/><link crossorigin=anonymous href=/assets/css/stylesheet.4f5249ac184c033613d94c5267209e90161d3a93365c2feb0ad3960a4bbb6393.css integrity="sha256-T1JJrBhMAzYT2UxSZyCekBYdOpM2XC/rCtOWCku7Y5M=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.cassdev.com/posts/%E4%BD%BF%E7%94%A8-systemd-%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/posts/%E4%BD%BF%E7%94%A8-systemd-%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="使用 systemd 优雅的管理自启动服务"><meta property="og:description" content="介绍如何使用 systemd 来管理和配置 Linux 系统中的自启动服务。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-31T01:40:00+08:00"><meta property="article:modified_time" content="2026-01-31T01:40:00+08:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Systemd"><meta property="article:tag" content="服务管理"><meta property="article:tag" content="自启动"><meta property="og:image" content="https://s2.loli.net/2026/01/31/Zrlvk4jgiQbsVy3.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://s2.loli.net/2026/01/31/Zrlvk4jgiQbsVy3.jpg"><meta name=twitter:title content="使用 systemd 优雅的管理自启动服务"><meta name=twitter:description content="介绍如何使用 systemd 来管理和配置 Linux 系统中的自启动服务。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.cassdev.com/posts/"},{"@type":"ListItem","position":2,"name":"使用 systemd 优雅的管理自启动服务","item":"https://blog.cassdev.com/posts/%E4%BD%BF%E7%94%A8-systemd-%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用 systemd 优雅的管理自启动服务","name":"使用 systemd 优雅的管理自启动服务","description":"介绍如何使用 systemd 来管理和配置 Linux 系统中的自启动服务。","keywords":["Linux","systemd","服务管理","自启动"],"articleBody":"systemd 是现代 Linux 发行版中广泛使用的初始化系统和服务管理器。它不仅提供了强大的功能来管理系统服务，还允许用户轻松地配置和管理自启动服务。\nsystemd 中的字母 d 表示 （daemon）守护进程，相信学过操作系统的同学都知道守护进程是指在后台运行的进程。\nsystemd 作为守护进程管理器，负责启动、停止和管理系统中的各种服务。\nsystemd 操作命令systemctlsystemctl（system control）是 systemd 的主要命令行工具。它用于检查和控制 systemd 系统和服务管理器的状态。\n刷新配置文件\nsudo systemctl daemon-reload 但你修改了服务的配置文件后，需要运行这个命令来让 systemd 重新加载配置文件。否则 systemd 不会识别你的更改。\n启动服务\nsudo systemctl start 这个命令用于启动指定的服务，当系统重启后，服务不会自动启动。\n停止服务\nsudo systemctl stop 这个命令用于停止指定的服务。\n重启服务\nsudo systemctl restart 这个命令用于重启指定的服务。\n重新加载服务配置\nsudo systemctl reload 这个命令用于重新加载指定服务的配置，而不停止服务。它与 restart 的区别在于，reload 不会中断服务的运行，适用于支持热加载配置的服务。\n查看服务状态\nsudo systemctl status 这个命令用于查看指定服务的当前状态。\n启用服务自启动\nsudo systemctl enable 这个命令用于使指定的服务在系统启动时自动启动。但是不会立即启动服务，如果想立即启动服务，可以加上 --now 选项： sudo systemctl enable --now 禁用服务自启动\nsudo systemctl disable 这个命令用于禁止指定的服务在系统启动时自动启动。\n查询服务是否启用自启动\nsudo systemctl is-enabled 这个命令用于检查指定的服务是否设置为自启动。\n注销服务\nsudo systemctl mask 这个命令用于禁止指定的服务被启动，包括手动启动和自动启动。应用场景如：某些服务存在安全隐患时，可以使用该命令彻底禁止其运行。\n取消注销服务\nsudo systemctl unmask 这个命令用于取消对指定服务的禁止启动设置。\n查看所有正在运行的服务\nsudo systemctl list-units --type=service --state=running 这个命令用于列出所有当前正在运行的服务。\njournalctljournalctl 是 systemd 的日志查看工具。它用于查看和管理由 systemd 记录的日志信息。\n查看指定服务的日志\nsudo journalctl -u 加上 -f 参数可以实时查看日志输出。\n如果你也不想输入 journalctl 这么长的命令，可以用下面 bash 函数简化：\nsrvlog() { sudo journalctl -u \"$@\" } 我使用 srvlog 来查看服务日志，这里使用了 $@，表示传递给函数的所有参数，所以 -f 等参数也可以传递进去。当然你也可以把 srvlog 改成你喜欢的名字。\nsystemd-analyzesystemd-analyze 是 systemd 的性能分析工具。它用于分析系统启动时间和服务启动时间。\n查看系统启动时间\nsystemd-analyze 这个命令显示系统启动所花费的总时间以及内核、initrd 和用户空间的时间。\n查看各个服务的启动时间\nsystemd-analyze blame 这个命令列出所有服务及其启动时间，按时间长短排序，帮助识别启动缓慢的服务。\n查看启动过程的可视化图表\nsystemd-analyze plot \u003e boot.svg 这个命令生成一个 SVG 文件，显示系统启动过程的可视化图表，便于分析启动过程中的瓶颈。\n服务配置文件systemd 的服务配置文件通常位于 /etc/systemd/system/ 或 /lib/systemd/system/ 目录下，文件扩展名为 .service。这些文件定义了服务的启动方式、依赖关系等信息。\n一个简单的服务配置文件示例如下：\n[Unit] Description=My Custom Service After=network.target [Service] ExecStart=/usr/bin/my_custom_service Restart=always [Install] WantedBy=multi-user.target 服务配置文件参数配置文件通常分为三个区块：\n[Unit]：描述服务的元数据和依赖关系（启动顺序）。 [Service]：核心区块，描述如何启动、停止、重启以及运行时的环境。 [Install]：描述如何“安装”这个服务（即 systemctl enable 时挂载到哪个目标）。 以下是常用的参数详解：\n[Unit] 区块（依赖与顺序）这一块决定了服务“什么时候”启动。\n参数名 意思 说明 Description 描述 systemctl status 时显示的文本，可写可不写，给自己看的。 Documentation 文档链接 可选，http 链接或 man 页面。 After 在谁之后启动 仅控制启动顺序，不代表强依赖。例如 After=network.target 表示网络栈初始化后再启动我。 Before 在谁之前启动 仅控制启动顺序，不代表强依赖。 Requires 强依赖 如果这里列出的服务启动失败，那么我也不会启动；如果它中途停了，我也会被停止。 Wants 弱依赖 我“想要”它启动，但如果它启动失败了，并不影响我继续运行。最常用的依赖方式。 [Service] 区块这是你最关心的部分，决定了服务怎么跑、挂了怎么救。\n参数名 意思与常见值 说明 Type 启动类型 simple: （默认）启动的主进程就是服务本身（适合绝大多数程序）。 forking: 程序启动后会派生子进程并在后台运行（如 Nginx）。\noneshot: 执行一次就结束（适合运行脚本）。 ExecStart 启动命令 必须使用绝对路径（例如 /usr/bin/python3 而不是 python3）。 ExecStop 停止命令 Systemd 默认会发 SIGTERM 信号杀进程。如果你需要执行特定的清理命令或脚本，可以在这里定义。 ExecReload 重载命令 执行 systemctl reload 时运行的命令。 ExecStartPre 启动前执行 在 ExecStart 之前运行。常用于清理环境、检查配置或数据库迁移。 Restart 重启策略 no: （默认）退出后不重启。\nalways: 无论怎么退出，总是重启（适合守护进程）。\non-failure: 只有非正常退出（退出码非0）才重启。 生产环境常用 on-failure 或 always。 RestartSec 重启间隔 挂掉后等待多久再尝试重启。例如 5s。防止进程疯狂闪退导致 CPU 飙升。 User / Group 运行用户/组 默认是 root。 WorkingDirectory 工作目录 进程启动时的当前目录。对于 docker-compose 很重要，因为它要找当前目录下的 .yml 文件。 Environment 环境变量 设置环境变量，如 Environment=\"ENV=production\"。 EnvironmentFile 环境变量文件 从文件中读取环境变量（类似 .env），如 EnvironmentFile=/etc/default/myapp。 TimeoutStartSec 启动超时时间 如果服务启动太慢，超过这个时间 Systemd 会杀掉它。默认 90s。如果是初始化很慢的服务），可以设为 0 (无限) 或更大值。 笔记 Service.Type 的区别\n主要在于 systemd 如何判断服务已经启动成功：\nsimple：systemd 认为服务一启动就成功。 forking：systemd 认为当主进程派生出子进程后，服务就成功启动了。 oneshot：systemd 认为当程序执行完毕并返回时，服务就成功启动了。 [Install] 区块这一块决定了 systemctl enable 的行为。\n参数名 意思 说明 WantedBy 挂载目标 通常填 multi-user.target。意思是“当系统进入多用户模式（正常启动后的状态）时，请启动我”。 Alias 别名 给服务起个别名，比如 systemctl start myapp 也可以用 systemctl start shortname。 service 示例下面是一个完整的 systemd 服务配置文件示例，假设我们需要开机自启动一个 Docker Compose 管理的服务：\n直接创建文件 vim /etc/systemd/system/example.service，内容如下：\n[Unit] Description= My Example Service # 强依赖 docker 服务 Requires=docker.service # 弱依赖 nginx 服务 Wants=nginx.service [Service] Type=simple WorkingDirectory=/root/dev-service/example-service # 启动前先停止 ExecStartPre=/usr/bin/docker-compose down # 启动命令 ExecStart=/usr/bin/docker-compose up # 停止命令 ExecStop=/usr/bin/docker-compose down # 无论如何都重启 Restart=always # 重启间隔 5 秒 RestartSec=5s [Install] # 挂载到多用户目标 WantedBy=multi-user.target 配置好服务文件后，执行以下命令使其生效：\nsudo systemctl daemon-reload sudo systemctl enable --now example 这样，每次系统启动时，example 服务都会自动启动。查看日志的话可以使用 sudo journalctl -u example -f。\n日志相关我通常会设置日志最大大小，防止日志把我的小水桶服务器塞满了。\n这个配置文件位于 /etc/systemd/journald.conf\n[Journal] # 设置日志最大大小为 500M SystemMaxUse=500M # 设置日志保留时间为 2 周 MaxRetentionSec=2week # 启用压缩以节省空间 Compress=yes 下面详细介绍一下可配置的参数：\n存储策略\n参数名 含义 选项 备注 Storage 日志存储位置 auto、persistent、volatile、none auto：自动选择存储位置。\npersistent：存储在 /var/log/journal/。\nvolatile：存储在 /run/log/journal/（重启后丢失）。\nnone：不存储日志。 Compress 启用日志压缩 yes、no 启用后，日志会被压缩以节省空间。可以节省磁盘空间，建议开启。 Seal 启用日志完整性保护 yes、no 启用后，日志文件会被加密签名以防篡改。一般只有在高安全需求环境下才需要开启。 SplitMode 日志拆分模式 uid、none uid：按用户 ID 拆分日志文件。\nnone：不拆分日志文件，这样所有用户的日志就会混在一起。 磁盘占用限制\n参数名 含义 备注 SystemMaxUse 系统日志最大占用空间 定义系统日志文件的最大总大小。超过后会删除旧日志。 SystemKeepFree 系统日志保留空间 定义系统日志文件保留的最小可用空间。 SystemMaxFileSize 单个系统日志文件最大大小 定义单个系统日志文件的最大大小。 SystemMaxFiles 系统日志文件最大数量 定义系统日志文件的最大数量。 单位可以是 K（千字节）、M（兆字节）、G（千兆字节）等。\n内存占用限制\n这部分配置决定了日志文件在内存中的限制。 逻辑同上，只是把 System 换成了 Runtime。\n参数名 含义 备注 RuntimeMaxUse 运行时日志最大占用空间 定义运行时日志文件的最大总大小。超过后会删除旧日志。 RuntimeKeepFree 运行时日志保留空间 定义运行时日志文件保留的最小可用空间。 RuntimeMaxFileSize 单个运行时日志文件最大大小 定义单个运行时日志文件的最大大小。 RuntimeMaxFiles 运行时日志文件最大数量 定义运行时日志文件的最大数量。 速率限制\n参数名 含义 备注 RateLimitIntervalSec 速率限制时间间隔 定义日志速率限制的时间窗口。 RateLimitBurst 速率限制突发值 定义在时间窗口内允许的最大日志条数。超过后会丢弃日志。 这两个参数是一对，简单来说就是在 RateLimitIntervalSec 时间内，允许最多 RateLimitBurst 条日志记录，超过的日志会被丢弃，直到下一个时间窗口开始。\nRateLimitIntervalSec 的默认值是 30s，单位可以是 s（秒）、m（分钟）、h（小时）等。RateLimitBurst 的默认值是 10000 条。\n作用是防止某个服务疯狂输出日志（例如报错，或死循环 log），瞬间写满磁盘或沾满 CPU。\n时间轮转与同步\n参数名 含义 备注 SyncIntervalSec 日志同步间隔 定义日志数据从内存同步到磁盘的时间间隔。journald 会先把日志写到内存中，然后定期同步到磁盘。减少磁盘 I/O 压力。 MaxRetentionSec 最大保留时间 定义日志文件的最大保留时间，超过后会被删除。 MaxFileSec 单个日志文件最大时间 定义单个日志文件的最大时间长度，超过后会创建新文件。 转发配置\nJournald 收集到日志后，可以转发给其他地方。\n参数名 含义 选项 备注 ForwardToSyslog 是否转发到 syslog yes、no 是否将日志转发到传统的 syslog 系统。 ForwardToKMsg 是否转发到内核日志缓冲区 yes、no 一般不开。 ForwardToConsole 是否转发到控制台 yes、 no 一般不开。 ForwardToWall 是否转发到所有登录用户终端 yes、no 只要有 Emerg 级别的日志，就会广播到所有登录用户的终端。 其他配置\n参数名 含义 备注 TTYPath 控制台设备路径 定义日志输出的控制台设备路径。默认是 /dev/console。 MaxLevelStore 存储的最大日志级别 定义存储到磁盘的最大日志级别。 MaxLevelSyslog 转发到 syslog 的最大日志级别 定义转发到 syslog 的最大日志级别。 MaxLevelKMsg 转发到内核日志缓冲区的最大日志级别 定义转发到内核日志缓冲区的最大日志级别。 MaxLevelConsole 转发到控制台的最大日志级别 定义转发到控制台的最大日志级别。 MaxLevelWall 转发到所有登录用户终端的最大日志级别 定义转发到所有登录用户终端的最大日志级别。 LineMax 单行日志最大长度 定义单行日志的最大长度，超过后会被截断。默认是 48K 字节。 ReadKMsg 读取内核消息缓冲区 定义是否读取内核消息缓冲区的日志。默认是 yes。 Audit 审计日志支持 定义是否启用审计日志支持。默认是 no。 ","wordCount":"598","inLanguage":"zh","image":"https://s2.loli.net/2026/01/31/Zrlvk4jgiQbsVy3.jpg","datePublished":"2026-01-31T01:40:00+08:00","dateModified":"2026-01-31T01:40:00+08:00","author":{"@type":"Person","name":"Cassius0924"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.cassdev.com/posts/%E4%BD%BF%E7%94%A8-systemd-%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/"},"publisher":{"@type":"Organization","name":"Cassius0924 的博客","logo":{"@type":"ImageObject","url":"https://blog.cassdev.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title="Cassius0924 的博客"><span>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.cassdev.com/>首页</a>&nbsp;»&nbsp;<a href=https://blog.cassdev.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">使用 systemd 优雅的管理自启动服务</h1><div class=post-description>介绍如何使用 systemd 来管理和配置 Linux 系统中的自启动服务。</div><div class=post-meta><span title='2026-01-31 01:40:00 +0800 +0800'>2026年01月31日</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Cassius0924</div></header><figure class=entry-cover><img loading=eager src=https://s2.loli.net/2026/01/31/Zrlvk4jgiQbsVy3.jpg alt="使用 systemd 优雅的管理自启动服务"><figcaption>使用 systemd 优雅的管理自启动服务</figcaption></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#systemd-%e6%93%8d%e4%bd%9c%e5%91%bd%e4%bb%a4 aria-label="systemd 操作命令">systemd 操作命令</a><ul><li><a href=#systemctl aria-label=systemctl>systemctl</a></li><li><a href=#journalctl aria-label=journalctl>journalctl</a></li><li><a href=#systemd-analyze aria-label=systemd-analyze>systemd-analyze</a></li></ul></li><li><a href=#%e6%9c%8d%e5%8a%a1%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6 aria-label=服务配置文件>服务配置文件</a><ul><li><a href=#%e6%9c%8d%e5%8a%a1%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%8f%82%e6%95%b0 aria-label=服务配置文件参数>服务配置文件参数</a></li><li><a href=#unit-%e5%8c%ba%e5%9d%97%e4%be%9d%e8%b5%96%e4%b8%8e%e9%a1%ba%e5%ba%8f aria-label="[Unit] 区块（依赖与顺序）">[Unit] 区块（依赖与顺序）</a></li><li><a href=#service-%e5%8c%ba%e5%9d%97 aria-label="[Service] 区块">[Service] 区块</a></li><li><a href=#install-%e5%8c%ba%e5%9d%97 aria-label="[Install] 区块">[Install] 区块</a></li><li><a href=#service-%e7%a4%ba%e4%be%8b aria-label="service 示例">service 示例</a></li></ul></li><li><a href=#%e6%97%a5%e5%bf%97%e7%9b%b8%e5%85%b3 aria-label=日志相关>日志相关</a></li></ul></div></details></div><div class=post-content><p>systemd 是现代 Linux 发行版中广泛使用的初始化系统和服务管理器。它不仅提供了强大的功能来管理系统服务，还允许用户轻松地配置和管理自启动服务。</p><p>systemd 中的字母 d 表示 <strong>（daemon）守护进程</strong>，相信学过操作系统的同学都知道守护进程是指在后台运行的进程。</p><p><strong>systemd 作为守护进程管理器，负责启动、停止和管理系统中的各种服务。</strong></p><h2 id=systemd-操作命令>systemd 操作命令</h2><h3 id=systemctl>systemctl<a hidden class=anchor aria-hidden=true href=#systemd-操作命令>#</a></h3><p>systemctl（system control）是 systemd 的主要命令行工具。它用于检查和控制 systemd 系统和服务管理器的状态。</p><ul><li><p><strong>刷新配置文件</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl daemon-reload
</span></span></code></pre></div><p>但你修改了服务的配置文件后，需要运行这个命令来让 systemd 重新加载配置文件。否则 systemd 不会识别你的更改。</p></li><li><p><strong>启动服务</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl start &lt;service_name&gt;
</span></span></code></pre></div><p>这个命令用于启动指定的服务，当系统重启后，服务不会自动启动。</p></li><li><p><strong>停止服务</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl stop &lt;service_name&gt;
</span></span></code></pre></div><p>这个命令用于停止指定的服务。</p></li><li><p><strong>重启服务</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl restart &lt;service_name&gt;
</span></span></code></pre></div><p>这个命令用于重启指定的服务。</p></li><li><p><strong>重新加载服务配置</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl reload &lt;service_name&gt;
</span></span></code></pre></div><p>这个命令用于重新加载指定服务的配置，而不停止服务。它与 <code>restart</code> 的区别在于，<code>reload</code> 不会中断服务的运行，适用于支持热加载配置的服务。</p></li><li><p><strong>查看服务状态</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl status &lt;service_name&gt;
</span></span></code></pre></div><p>这个命令用于查看指定服务的当前状态。</p></li><li><p><strong>启用服务自启动</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl <span class=nb>enable</span> &lt;service_name&gt;
</span></span></code></pre></div><p>这个命令用于使指定的服务在系统启动时自动启动。但是不会立即启动服务，如果想立即启动服务，可以加上 <code>--now</code> 选项： <code>sudo systemctl enable --now &lt;service_name></code></p></li><li><p><strong>禁用服务自启动</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl disable &lt;service_name&gt;
</span></span></code></pre></div><p>这个命令用于禁止指定的服务在系统启动时自动启动。</p></li><li><p><strong>查询服务是否启用自启动</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl is-enabled &lt;service_name&gt;
</span></span></code></pre></div><p>这个命令用于检查指定的服务是否设置为自启动。</p></li><li><p><strong>注销服务</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl mask &lt;service_name&gt;
</span></span></code></pre></div><p>这个命令用于禁止指定的服务被启动，包括手动启动和自动启动。应用场景如：某些服务存在安全隐患时，可以使用该命令彻底禁止其运行。</p></li><li><p><strong>取消注销服务</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl unmask &lt;service_name&gt;
</span></span></code></pre></div><p>这个命令用于取消对指定服务的禁止启动设置。</p></li><li><p><strong>查看所有正在运行的服务</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl list-units --type<span class=o>=</span>service --state<span class=o>=</span>running
</span></span></code></pre></div><p>这个命令用于列出所有当前正在运行的服务。</p></li></ul><h3 id=journalctl>journalctl<a hidden class=anchor aria-hidden=true href=#journalctl>#</a></h3><p>journalctl 是 systemd 的日志查看工具。它用于查看和管理由 systemd 记录的日志信息。</p><ul><li><p><strong>查看指定服务的日志</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo journalctl -u &lt;service_name&gt;
</span></span></code></pre></div><p>加上 <code>-f</code> 参数可以实时查看日志输出。</p><p>如果你也不想输入 <code>journalctl</code> 这么长的命令，可以用下面 bash 函数简化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>srvlog<span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    sudo journalctl -u <span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>我使用 <code>srvlog &lt;service_name></code> 来查看服务日志，这里使用了 <code>$@</code>，表示传递给函数的所有参数，所以 <code>-f</code> 等参数也可以传递进去。当然你也可以把 <code>srvlog</code> 改成你喜欢的名字。</p></li></ul><h3 id=systemd-analyze>systemd-analyze<a hidden class=anchor aria-hidden=true href=#systemd-analyze>#</a></h3><p>systemd-analyze 是 systemd 的性能分析工具。它用于分析系统启动时间和服务启动时间。</p><ul><li><p><strong>查看系统启动时间</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>systemd-analyze
</span></span></code></pre></div><p>这个命令显示系统启动所花费的总时间以及内核、initrd 和用户空间的时间。</p></li><li><p><strong>查看各个服务的启动时间</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>systemd-analyze blame
</span></span></code></pre></div><p>这个命令列出所有服务及其启动时间，按时间长短排序，帮助识别启动缓慢的服务。</p></li><li><p><strong>查看启动过程的可视化图表</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>systemd-analyze plot &gt; boot.svg
</span></span></code></pre></div><p>这个命令生成一个 SVG 文件，显示系统启动过程的可视化图表，便于分析启动过程中的瓶颈。</p></li></ul><h2 id=服务配置文件>服务配置文件<a hidden class=anchor aria-hidden=true href=#服务配置文件>#</a></h2><p>systemd 的服务配置文件通常位于 <code>/etc/systemd/system/</code> 或 <code>/lib/systemd/system/</code> 目录下，文件扩展名为 <code>.service</code>。这些文件定义了服务的启动方式、依赖关系等信息。</p><p>一个简单的服务配置文件示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=k>[Unit]</span>
</span></span><span class=line><span class=cl><span class=na>Description</span><span class=o>=</span><span class=s>My Custom Service</span>
</span></span><span class=line><span class=cl><span class=na>After</span><span class=o>=</span><span class=s>network.target</span>
</span></span><span class=line><span class=cl><span class=k>[Service]</span>
</span></span><span class=line><span class=cl><span class=na>ExecStart</span><span class=o>=</span><span class=s>/usr/bin/my_custom_service</span>
</span></span><span class=line><span class=cl><span class=na>Restart</span><span class=o>=</span><span class=s>always</span>
</span></span><span class=line><span class=cl><span class=k>[Install]</span>
</span></span><span class=line><span class=cl><span class=na>WantedBy</span><span class=o>=</span><span class=s>multi-user.target</span>
</span></span></code></pre></div><h3 id=服务配置文件参数>服务配置文件参数<a hidden class=anchor aria-hidden=true href=#服务配置文件参数>#</a></h3><p>配置文件通常分为三个区块：</p><ol><li><strong><code>[Unit]</code></strong>：描述服务的元数据和依赖关系（启动顺序）。</li><li><strong><code>[Service]</code></strong>：核心区块，描述如何启动、停止、重启以及运行时的环境。</li><li><strong><code>[Install]</code></strong>：描述如何“安装”这个服务（即 <code>systemctl enable</code> 时挂载到哪个目标）。</li></ol><p>以下是常用的参数详解：</p><h3 id=unit-区块依赖与顺序><code>[Unit]</code> 区块（依赖与顺序）<a hidden class=anchor aria-hidden=true href=#unit-区块依赖与顺序>#</a></h3><p>这一块决定了服务“什么时候”启动。</p><table><thead><tr><th>参数名</th><th>意思</th><th>说明</th></tr></thead><tbody><tr><td><strong>Description</strong></td><td>描述</td><td><code>systemctl status</code> 时显示的文本，可写可不写，给自己看的。</td></tr><tr><td><strong>Documentation</strong></td><td>文档链接</td><td>可选，http 链接或 man 页面。</td></tr><tr><td><strong>After</strong></td><td><strong>在谁之后启动</strong></td><td>仅控制启动顺序，不代表强依赖。例如 <code>After=network.target</code> 表示网络栈初始化后再启动我。</td></tr><tr><td><strong>Before</strong></td><td><strong>在谁之前启动</strong></td><td>仅控制启动顺序，不代表强依赖。</td></tr><tr><td><strong>Requires</strong></td><td><strong>强依赖</strong></td><td>如果这里列出的服务启动失败，那么我也不会启动；如果它中途停了，我也会被停止。</td></tr><tr><td><strong>Wants</strong></td><td><strong>弱依赖</strong></td><td>我“想要”它启动，但如果它启动失败了，并不影响我继续运行。最常用的依赖方式。</td></tr></tbody></table><h3 id=service-区块><code>[Service]</code> 区块<a hidden class=anchor aria-hidden=true href=#service-区块>#</a></h3><p>这是你最关心的部分，决定了服务怎么跑、挂了怎么救。</p><table><thead><tr><th>参数名</th><th>意思与常见值</th><th>说明</th></tr></thead><tbody><tr><td><strong>Type</strong></td><td><strong>启动类型</strong></td><td><code>simple</code>: （默认）启动的主进程就是服务本身（适合绝大多数程序）。<br><code>forking</code>: 程序启动后会派生子进程并在后台运行（如 Nginx）。<br><code>oneshot</code>: 执行一次就结束（适合运行脚本）。</td></tr><tr><td><strong>ExecStart</strong></td><td><strong>启动命令</strong></td><td><strong>必须使用绝对路径</strong>（例如 <code>/usr/bin/python3</code> 而不是 <code>python3</code>）。</td></tr><tr><td><strong>ExecStop</strong></td><td><strong>停止命令</strong></td><td>Systemd 默认会发 <code>SIGTERM</code> 信号杀进程。如果你需要执行特定的清理命令或脚本，可以在这里定义。</td></tr><tr><td><strong>ExecReload</strong></td><td><strong>重载命令</strong></td><td>执行 <code>systemctl reload</code> 时运行的命令。</td></tr><tr><td><strong>ExecStartPre</strong></td><td><strong>启动前执行</strong></td><td>在 <code>ExecStart</code> 之前运行。常用于清理环境、检查配置或数据库迁移。</td></tr><tr><td><strong>Restart</strong></td><td><strong>重启策略</strong></td><td><code>no</code>: （默认）退出后不重启。<br><code>always</code>: 无论怎么退出，总是重启（适合守护进程）。<br><code>on-failure</code>: 只有非正常退出（退出码非0）才重启。<br>生产环境常用 <code>on-failure</code> 或 <code>always</code>。</td></tr><tr><td><strong>RestartSec</strong></td><td><strong>重启间隔</strong></td><td>挂掉后等待多久再尝试重启。例如 <code>5s</code>。防止进程疯狂闪退导致 CPU 飙升。</td></tr><tr><td><strong>User / Group</strong></td><td><strong>运行用户/组</strong></td><td>默认是 <code>root</code>。</td></tr><tr><td><strong>WorkingDirectory</strong></td><td><strong>工作目录</strong></td><td>进程启动时的当前目录。对于 <code>docker-compose</code> 很重要，因为它要找当前目录下的 <code>.yml</code> 文件。</td></tr><tr><td><strong>Environment</strong></td><td><strong>环境变量</strong></td><td>设置环境变量，如 <code>Environment="ENV=production"</code>。</td></tr><tr><td><strong>EnvironmentFile</strong></td><td><strong>环境变量文件</strong></td><td>从文件中读取环境变量（类似 <code>.env</code>），如 <code>EnvironmentFile=/etc/default/myapp</code>。</td></tr><tr><td><strong>TimeoutStartSec</strong></td><td><strong>启动超时时间</strong></td><td>如果服务启动太慢，超过这个时间 Systemd 会杀掉它。默认 90s。如果是初始化很慢的服务），可以设为 <code>0</code> (无限) 或更大值。</td></tr></tbody></table><link rel=stylesheet href=/css/vendors/admonitions.4fd9a0b8ec8899f2ca952048d255a569f433f77dfb3f52f5bc87e7d65cdce449.css integrity="sha256-T9mguOyImfLKlSBI0lWlafQz9337P1L1vIfn1lzc5Ek=" crossorigin=anonymous><div class="admonition note"><div class=admonition-header><svg viewBox="0 0 576 512"><path d="M0 64C0 28.7 28.7.0 64 0H224v128c0 17.7 14.3 32 32 32h128v125.7l-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3.0-64-28.7-64-64V64zm384 64H256V0L384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9.0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6.0zM311.9 417 441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z"/></svg>
<span>笔记</span></div><div class=admonition-content><p><strong>Service.Type 的区别</strong></p><p>主要在于 systemd 如何判断服务已经启动成功：</p><ul><li><code>simple</code>：systemd 认为服务一启动就成功。</li><li><code>forking</code>：systemd 认为当主进程派生出子进程后，服务就成功启动了。</li><li><code>oneshot</code>：systemd 认为当程序执行完毕并返回时，服务就成功启动了。</li></ul></div></div><h3 id=install-区块><code>[Install]</code> 区块<a hidden class=anchor aria-hidden=true href=#install-区块>#</a></h3><p>这一块决定了 <code>systemctl enable</code> 的行为。</p><table><thead><tr><th>参数名</th><th>意思</th><th>说明</th></tr></thead><tbody><tr><td><strong>WantedBy</strong></td><td><strong>挂载目标</strong></td><td>通常填 <code>multi-user.target</code>。意思是“当系统进入多用户模式（正常启动后的状态）时，请启动我”。</td></tr><tr><td><strong>Alias</strong></td><td>别名</td><td>给服务起个别名，比如 <code>systemctl start myapp</code> 也可以用 <code>systemctl start shortname</code>。</td></tr></tbody></table><h3 id=service-示例>service 示例<a hidden class=anchor aria-hidden=true href=#service-示例>#</a></h3><p>下面是一个完整的 systemd 服务配置文件示例，假设我们需要开机自启动一个 Docker Compose 管理的服务：</p><p>直接创建文件 <code>vim /etc/systemd/system/example.service</code>，内容如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=k>[Unit]</span>
</span></span><span class=line><span class=cl><span class=na>Description</span><span class=o>=</span> <span class=s>My Example Service</span>
</span></span><span class=line><span class=cl><span class=c1># 强依赖 docker 服务</span>
</span></span><span class=line><span class=cl><span class=na>Requires</span><span class=o>=</span><span class=s>docker.service</span>
</span></span><span class=line><span class=cl><span class=c1># 弱依赖 nginx 服务</span>
</span></span><span class=line><span class=cl><span class=na>Wants</span><span class=o>=</span><span class=s>nginx.service</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Service]</span>
</span></span><span class=line><span class=cl><span class=na>Type</span><span class=o>=</span><span class=s>simple</span>
</span></span><span class=line><span class=cl><span class=na>WorkingDirectory</span><span class=o>=</span><span class=s>/root/dev-service/example-service</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 启动前先停止</span>
</span></span><span class=line><span class=cl><span class=na>ExecStartPre</span><span class=o>=</span><span class=s>/usr/bin/docker-compose down</span>
</span></span><span class=line><span class=cl><span class=c1># 启动命令</span>
</span></span><span class=line><span class=cl><span class=na>ExecStart</span><span class=o>=</span><span class=s>/usr/bin/docker-compose up</span>
</span></span><span class=line><span class=cl><span class=c1># 停止命令</span>
</span></span><span class=line><span class=cl><span class=na>ExecStop</span><span class=o>=</span><span class=s>/usr/bin/docker-compose down</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 无论如何都重启</span>
</span></span><span class=line><span class=cl><span class=na>Restart</span><span class=o>=</span><span class=s>always</span>
</span></span><span class=line><span class=cl><span class=c1># 重启间隔 5 秒</span>
</span></span><span class=line><span class=cl><span class=na>RestartSec</span><span class=o>=</span><span class=s>5s</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Install]</span>
</span></span><span class=line><span class=cl><span class=c1># 挂载到多用户目标</span>
</span></span><span class=line><span class=cl><span class=na>WantedBy</span><span class=o>=</span><span class=s>multi-user.target</span>
</span></span></code></pre></div><p>配置好服务文件后，执行以下命令使其生效：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl daemon-reload
</span></span><span class=line><span class=cl>sudo systemctl <span class=nb>enable</span> --now example
</span></span></code></pre></div><p>这样，每次系统启动时，<code>example</code> 服务都会自动启动。查看日志的话可以使用 <code>sudo journalctl -u example -f</code>。</p><h2 id=日志相关>日志相关<a hidden class=anchor aria-hidden=true href=#日志相关>#</a></h2><p>我通常会设置日志最大大小，防止日志把我的小水桶服务器塞满了。</p><p>这个配置文件位于 <code>/etc/systemd/journald.conf</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=k>[Journal]</span>
</span></span><span class=line><span class=cl><span class=c1># 设置日志最大大小为 500M</span>
</span></span><span class=line><span class=cl><span class=na>SystemMaxUse</span><span class=o>=</span><span class=s>500M</span>
</span></span><span class=line><span class=cl><span class=c1># 设置日志保留时间为 2 周</span>
</span></span><span class=line><span class=cl><span class=na>MaxRetentionSec</span><span class=o>=</span><span class=s>2week</span>
</span></span><span class=line><span class=cl><span class=c1># 启用压缩以节省空间</span>
</span></span><span class=line><span class=cl><span class=na>Compress</span><span class=o>=</span><span class=s>yes</span>
</span></span></code></pre></div><p>下面详细介绍一下可配置的参数：</p><ol><li><p><strong>存储策略</strong></p><table><thead><tr><th>参数名</th><th>含义</th><th>选项</th><th>备注</th></tr></thead><tbody><tr><td><strong>Storage</strong></td><td>日志存储位置</td><td><code>auto</code>、<code>persistent</code>、<code>volatile</code>、<code>none</code></td><td><code>auto</code>：自动选择存储位置。<br><code>persistent</code>：存储在 <code>/var/log/journal/</code>。<br><code>volatile</code>：存储在 <code>/run/log/journal/</code>（重启后丢失）。<br><code>none</code>：不存储日志。</td></tr><tr><td><strong>Compress</strong></td><td>启用日志压缩</td><td><code>yes</code>、<code>no</code></td><td>启用后，日志会被压缩以节省空间。可以节省磁盘空间，建议开启。</td></tr><tr><td><strong>Seal</strong></td><td>启用日志完整性保护</td><td><code>yes</code>、<code>no</code></td><td>启用后，日志文件会被加密签名以防篡改。一般只有在高安全需求环境下才需要开启。</td></tr><tr><td><strong>SplitMode</strong></td><td>日志拆分模式</td><td><code>uid</code>、<code>none</code></td><td><code>uid</code>：按用户 ID 拆分日志文件。<br><code>none</code>：不拆分日志文件，这样所有用户的日志就会混在一起。</td></tr></tbody></table></li><li><p><strong>磁盘占用限制</strong></p><table><thead><tr><th>参数名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td><strong>SystemMaxUse</strong></td><td>系统日志最大占用空间</td><td>定义系统日志文件的最大总大小。超过后会删除旧日志。</td></tr><tr><td><strong>SystemKeepFree</strong></td><td>系统日志保留空间</td><td>定义系统日志文件保留的最小可用空间。</td></tr><tr><td><strong>SystemMaxFileSize</strong></td><td>单个系统日志文件最大大小</td><td>定义单个系统日志文件的最大大小。</td></tr><tr><td><strong>SystemMaxFiles</strong></td><td>系统日志文件最大数量</td><td>定义系统日志文件的最大数量。</td></tr></tbody></table><p>单位可以是 <code>K</code>（千字节）、<code>M</code>（兆字节）、<code>G</code>（千兆字节）等。</p></li><li><p><strong>内存占用限制</strong></p><p>这部分配置决定了日志文件在内存中的限制。 逻辑同上，只是把 System 换成了 Runtime。</p><table><thead><tr><th>参数名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td><strong>RuntimeMaxUse</strong></td><td>运行时日志最大占用空间</td><td>定义运行时日志文件的最大总大小。超过后会删除旧日志。</td></tr><tr><td><strong>RuntimeKeepFree</strong></td><td>运行时日志保留空间</td><td>定义运行时日志文件保留的最小可用空间。</td></tr><tr><td><strong>RuntimeMaxFileSize</strong></td><td>单个运行时日志文件最大大小</td><td>定义单个运行时日志文件的最大大小。</td></tr><tr><td><strong>RuntimeMaxFiles</strong></td><td>运行时日志文件最大数量</td><td>定义运行时日志文件的最大数量。</td></tr></tbody></table></li><li><p><strong>速率限制</strong></p><table><thead><tr><th>参数名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td><strong>RateLimitIntervalSec</strong></td><td>速率限制时间间隔</td><td>定义日志速率限制的时间窗口。</td></tr><tr><td><strong>RateLimitBurst</strong></td><td>速率限制突发值</td><td>定义在时间窗口内允许的最大日志条数。超过后会丢弃日志。</td></tr></tbody></table><p>这两个参数是一对，简单来说就是在 RateLimitIntervalSec 时间内，允许最多 RateLimitBurst 条日志记录，超过的日志会被丢弃，直到下一个时间窗口开始。</p><p>RateLimitIntervalSec 的默认值是 30s，单位可以是 s（秒）、m（分钟）、h（小时）等。RateLimitBurst 的默认值是 10000 条。</p><p>作用是防止某个服务疯狂输出日志（例如报错，或死循环 log），瞬间写满磁盘或沾满 CPU。</p></li><li><p><strong>时间轮转与同步</strong></p><table><thead><tr><th>参数名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td><strong>SyncIntervalSec</strong></td><td>日志同步间隔</td><td>定义日志数据从内存同步到磁盘的时间间隔。journald 会先把日志写到内存中，然后定期同步到磁盘。减少磁盘 I/O 压力。</td></tr><tr><td><strong>MaxRetentionSec</strong></td><td>最大保留时间</td><td>定义日志文件的最大保留时间，超过后会被删除。</td></tr><tr><td><strong>MaxFileSec</strong></td><td>单个日志文件最大时间</td><td>定义单个日志文件的最大时间长度，超过后会创建新文件。</td></tr></tbody></table></li><li><p><strong>转发配置</strong></p><p>Journald 收集到日志后，可以转发给其他地方。</p><table><thead><tr><th>参数名</th><th>含义</th><th>选项</th><th>备注</th></tr></thead><tbody><tr><td><strong>ForwardToSyslog</strong></td><td>是否转发到 syslog</td><td><code>yes</code>、<code>no</code></td><td>是否将日志转发到传统的 syslog 系统。</td></tr><tr><td><strong>ForwardToKMsg</strong></td><td>是否转发到内核日志缓冲区</td><td><code>yes</code>、<code>no</code></td><td>一般不开。</td></tr><tr><td><strong>ForwardToConsole</strong></td><td>是否转发到控制台</td><td><code>yes</code>、 <code>no</code></td><td>一般不开。</td></tr><tr><td><strong>ForwardToWall</strong></td><td>是否转发到所有登录用户终端</td><td><code>yes</code>、<code>no</code></td><td>只要有 <code>Emerg</code> 级别的日志，就会广播到所有登录用户的终端。</td></tr></tbody></table></li><li><p><strong>其他配置</strong></p><table><thead><tr><th>参数名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td><strong>TTYPath</strong></td><td>控制台设备路径</td><td>定义日志输出的控制台设备路径。默认是 <code>/dev/console</code>。</td></tr><tr><td><strong>MaxLevelStore</strong></td><td>存储的最大日志级别</td><td>定义存储到磁盘的最大日志级别。</td></tr><tr><td><strong>MaxLevelSyslog</strong></td><td>转发到 syslog 的最大日志级别</td><td>定义转发到 syslog 的最大日志级别。</td></tr><tr><td><strong>MaxLevelKMsg</strong></td><td>转发到内核日志缓冲区的最大日志级别</td><td>定义转发到内核日志缓冲区的最大日志级别。</td></tr><tr><td><strong>MaxLevelConsole</strong></td><td>转发到控制台的最大日志级别</td><td>定义转发到控制台的最大日志级别。</td></tr><tr><td><strong>MaxLevelWall</strong></td><td>转发到所有登录用户终端的最大日志级别</td><td>定义转发到所有登录用户终端的最大日志级别。</td></tr><tr><td><strong>LineMax</strong></td><td>单行日志最大长度</td><td>定义单行日志的最大长度，超过后会被截断。默认是 48K 字节。</td></tr><tr><td><strong>ReadKMsg</strong></td><td>读取内核消息缓冲区</td><td>定义是否读取内核消息缓冲区的日志。默认是 <code>yes</code>。</td></tr><tr><td><strong>Audit</strong></td><td>审计日志支持</td><td>定义是否启用审计日志支持。默认是 <code>no</code>。</td></tr></tbody></table></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.cassdev.com/tags/linux/>Linux</a></li><li><a href=https://blog.cassdev.com/tags/systemd/>Systemd</a></li><li><a href=https://blog.cassdev.com/tags/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/>服务管理</a></li><li><a href=https://blog.cassdev.com/tags/%E8%87%AA%E5%90%AF%E5%8A%A8/>自启动</a></li></ul></footer></article></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>