<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Cassius0924 的博客</title><meta name=keywords content><meta name=description content="Posts - Cassius0924 的博客"><meta name=author content><link rel=canonical href=https://blog.cassdev.com/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.4f5249ac184c033613d94c5267209e90161d3a93365c2feb0ad3960a4bbb6393.css integrity="sha256-T1JJrBhMAzYT2UxSZyCekBYdOpM2XC/rCtOWCku7Y5M=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.cassdev.com/posts/index.xml><link rel=alternate hreflang=zh href=https://blog.cassdev.com/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/posts/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.cassdev.com/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title="Cassius0924 的博客"><span>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://blog.cassdev.com/>首页</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用 Certbot 申请泛域名 SSL 证书指南</h2></header><div class=entry-content><p>使用 Certbot 申请泛域名证书并不复杂，几个月前搞过，但是又忘了，今天重新搞了一遍，记录一下步骤。
前提条件 你需要有一个域名，并且可以管理该域名的 DNS 记录。 一般我们都是在 阿里云 或 火山引擎 等云服务商购买的域名，这里以阿里云为例。
申请泛域名证书安装 Certbot先用 certbot --version 检查是否已经安装 Certbot，如果没有安装，下面一句话安装一下：
sudo apt install certbot -y 申请证书泛域名证书需要通过 DNS-01 验证域名所有权，使用以下命令申请，注意将 *.cassdev.com 和 cassdev.com 替换为你的域名，example@google.com 替换为你的邮箱。
笔记 什么是 DNS-01 验证？
...</p></div><footer class=entry-footer><span title='2026-01-28 20:23:00 +0800 +0800'>2026年01月28日</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to 使用 Certbot 申请泛域名 SSL 证书指南" href=https://blog.cassdev.com/posts/%E4%BD%BF%E7%94%A8-certbot-%E7%94%B3%E8%AF%B7%E6%B3%9B%E5%9F%9F%E5%90%8D-ssl-%E8%AF%81%E4%B9%A6%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LLM 参数之 Temperature 和 Top-p</h2></header><div class=entry-content><p>大家在使用 LLM 生成内容时，不知道有没有注意到 LLM 的一些可配置参数，比如 Temperature 和 Top-p，是否关注过这些参数的作用？
无论是在 OpenAI 的 API 文档、Google 的 AI Studio、以及各种的 AI 平台，你都能看到它的身影。
什么是 Temperature 和 Top-p？在与 LLM 聊天时，大家可能已经注意到，有的 Agent 十分有创造力，有的 Agent 又十分严谨。这其中除了 Prompt 的影响外，还有一个重要的因素就是 LLM 的采样参数，包括 Temperature 和 Top-p。
提示 TL;DR
...</p></div><footer class=entry-footer><span title='2025-07-31 00:00:00 +0000 UTC'>2025年07月31日</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to LLM 参数之 Temperature 和 Top-p" href=https://blog.cassdev.com/posts/llm-param-temeprature-and-top-p/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s2.loli.net/2025/07/29/2tPIjcy5MbA7K9f.png alt="The Response Format of LLM parameter"></figure><header class=entry-header><h2 class=entry-hint-parent>LLM 参数之 Response Format</h2></header><div class=entry-content><p>如果想让 LLM 输出 JSON 格式的内容，大家第一反应会是什么？可能大多数人和我一样，直接在提示词中写上"请输出 JSON 格式的内容，格式为 { “key”: “value” }"。但其实，这种方式并不是最优的。
从之前我们也了解到了，LLM 的输出是一个概率性的文本补全器。单纯依靠提示词工程来控制 LLM 的输出格式并不可靠。用自然语言去描述一个复杂的 JSON 结构本就不易，再加上当提示词很长时，LLM 的注意力可能会分散，这些因素都容易导致它输出不符合预期的格式，甚至根本不输出 JSON。
具体来说，这种方式可能会遇到以下三个主要问题：
混入无关文本：模型可能在 JSON 对象前后添加对话式的"口水话"，如"好的，这是您要的 JSON：…"，这给后续的程序化解析带来了困难。
结构性错误：生成的 JSON 可能存在语法错误，例如缺少逗号、括号不匹配或引号使用不当，导致解析失败。
内容幻觉：模型可能"幻觉"出指令中未要求的字段，或遗漏必要的字段，破坏了数据模式的一致性。
让 LLM 生成符合预期的 JSON 格式内容的最佳实践是使用 response_format 参数，在程序算法的层面上去干预 LLM 的输出格式。这个参数允许我们让 LLM 进行结构化内容输出，确保 LLM 生成的内容符合预期的结构和语法。
Response Format 参数response_format 参数在绝大多数现代 LLM API 中都可用，允许开发者指定模型输出的格式。
DeepSeek API Response Format
OpenAI API Response Format
DouBao API Response Format
通过这个参数，我们可以明确要求 LLM 生成特定格式的内容，如 JSON 对象、纯文本或符合 JSON Schema 的数据结构。
response_format 参数支持以下三个模式：
...</p></div><footer class=entry-footer><span title='2025-07-29 00:00:00 +0000 UTC'>2025年07月29日</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to LLM 参数之 Response Format" href=https://blog.cassdev.com/posts/llm-param-response-format/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s2.loli.net/2025/03/16/mQydfgXDYCuKPLo.png alt="Textmate 语法高亮规则运行机制"></figure><header class=entry-header><h2 class=entry-hint-parent>浅析 Textmate 语法高亮规则运行机制</h2></header><div class=entry-content><p>1. 语法高亮简介语法高亮是指在IDE或编辑器中，对文本进行分词，即将文本拆解为 Token（标记），每个 Token 都有对应的名称（作用域）进行标记。再配合主题样式规则，对不同名称的 Token 的进行主题化，以提高代码的可读性。
程序员离不开语法高亮，就像作家离不开标点符号一样。（你可以代入一下使用 txt 文本编辑器写代码的场景）
语法高亮由两个部分组成：
分词（Tokenization）：将文本拆解为一系列 Token。 主题化（Theming）：对 Token 进行样式渲染，如字体颜色、背景色、加粗等。 我们以 JSON 的语法为例，简单介绍一下语法高亮的过程。
首先分词引擎会对 JSON 文本进行分词，下图是将 JSON 文本进行分词后的结果，其中每个矩形所包括的文本都是一个 Token，每个 Token 都有一个作用域名称，例如 null 对应的是 constant.language.json 作用域。
然后主题化引擎会根据 Token 的作用域名称，对 Token 进行样式渲染，例如将 constant.language.json 作用域映射为蓝色不加粗字体。那么 null 就会被渲染为蓝色不加粗字体。
2. 分词的实现方式目前主流的分词实现方式大致有有以下三种：
基于正则表达式的分词：Textmate 基于词法分析的分词：Highlight.js 基于语法树的分词：Tree-sitter (如果有其他，欢迎补充) 本文只讨论 Textmate 的语法高亮规则编写。
Textmate 原是 MacOS 下的一款文本编辑器，其语法高亮规则是基于正则表达式的，但由于其规则简单易懂，且支持多种语言，因此被广泛应用于各种编辑器和IDE中，如 VSCode、Sublime Text 等。JetBrains 的 IDE 也集成了 Textmate Bundle 插件，可以直接导入 Textmate 的语法高亮规则。
...</p></div><footer class=entry-footer><span title='2025-07-20 15:47:58 +0800 +0800'>2025年07月20日</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 浅析 Textmate 语法高亮规则运行机制" href=https://blog.cassdev.com/posts/%E6%B5%85%E6%9E%90-textmate-%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E8%A7%84%E5%88%99%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Vim 技能补全计划</h2></header><div class=entry-content><p>适合已经熟悉 Vim 基础操作，希望提高编辑技能的开发者的实用技巧集合</p></div><footer class=entry-footer><span title='2025-07-19 00:00:00 +0000 UTC'>2025年07月19日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Vim 技能补全计划" href=https://blog.cassdev.com/posts/vim-skill-completion-plan/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Socket 编程之 epoll 源码分析学习笔记</h2></header><div class=entry-content><p>本文基于 Linux 6.9 内核源码进行分析。
几个数据结构
eventpoll这是 epoll 的主要数据结构，它用于存储 epoll 的相关信息，包括等待队列、就绪队列、红黑树等。
struct eventpoll { wait_queue_head_t wq; // epoll 的等待队列：用于存储等待的进程/线程，指向等待队列头 wait_queue_head_t poll_wait;// 这个 poll_wait 等待队列只有在 epoll 嵌套的情况下才会用到 struct list_head rdllist; // 就绪队列：用于存储就绪的 fd，指向就绪队列头 struct rb_root_cached rbr; // 红黑树：用于存储所有的 fd，指向红黑树根节点 struct wakeup_source *ws; // 一个唤醒源，用于唤醒进程 }; epitemepitem 的作用是将 fd、就绪队列、红黑树节点等信息封装在一起。
struct epitem { union { struct rb_node rbn; // 红黑树节点，用于存储 fd，指向红黑树节点 struct rcu_head rcu; // 用于释放 epitem }; struct list_head rdllink; // 就绪队列节点，用于存储就绪的 fd，指向就绪队列节点 struct eventpoll *ep; // 指向 eventpoll struct epoll_filefd ffd; // epoll 文件描述符 struct wakeup_source *ws; // 一个唤醒源，用于唤醒进程 struct epoll_event event; // 监听的事件 }; ep_pqueue给 poll 队列封装的结构体，用于存储 poll_table 和 epitem。
...</p></div><footer class=entry-footer><span title='2024-06-30 15:31:40 +0800 +0800'>2024年06月30日</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Socket 编程之 epoll 源码分析学习笔记" href=https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-epoll-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ 内存模型学习笔记</h2></header><div class=entry-content><p>C++ 内存模型从上（高地址）到下（低地址）可以分为以下几个部分：
栈区：由编译器自动分配释放，存放函数的参数值、局部变量的值等。
堆区：由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收。
全局/静态区：分为 .data 段（全局初始化区）和 .bss 段（全局未初始化区），.data 段存放 已初始化 了的全局变量和静态变量，.bss 段存放 未初始化 的变量。
常量区：就是 .rodata 段，存放常量。
代码区：存放函数体的代码。</p></div><footer class=entry-footer><span title='2024-06-29 16:44:14 +0800 +0800'>2024年06月29日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to C++ 内存模型学习笔记" href=https://blog.cassdev.com/posts/c++-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ delete ptr 和 ptr = nullptr 的区别</h2></header><div class=entry-content><p>delete ptrdelete ptr 是释放 ptr 所指向的对象资源，而 ptr 依然存在，且依然指向那片内存地址。
ptr = nullptrptr = nullptr 是将 ptr 指向空指针，和其所指向的对象没关系。
试着实现一个 unique_ptrtemplate &lt;typename T> class UniquePtr { private: T *_ptr; public: // 默认构造 UniquePtr() : _ptr(nullptr) { } explicit UniquePtr(T *ptr) : _ptr(ptr) { } ~UniquePtr() { delete _ptr; // 无需置 nullptr，因为析构函数会被调用，_ptr 会被销毁 // 置空无意义 } // 拷贝构造 删除 UniquePtr(const UniquePtr &) = delete; UniquePtr &amp;operator=(const UniquePtr &) = delete; // 移动构造 UniquePtr(UniquePtr &&amp;p) noexcept : _ptr(p._ptr) { // 至于这里为什么不需要 delete _ptr // 是因为这是移动构造函数，是个构造函数！_ptr 本来就没有资源 p._ptr = nullptr; } UniquePtr &amp;operator=(UniquePtr &&amp;p) noexcept { if (p != *this) { delete _ptr; // 第一步，释放当前资源 _ptr = p._ptr; // 第二步，将当前指针指向新的资源 p._ptr = nullptr; // 第三步，将原来的指针置空 } return *this; } T *get() const { // 返回指针 return _ptr; } T *operator->() const { // 返回指针 return _ptr; } T &amp;operator*() const { // 解引用 return *_ptr; } T *release() { // 这里不能 delete _ptr // 因为 release 只是解除 UniquePtr 对资源的所有权，但资源还是存在的 T *tmp = _ptr; _ptr = nullptr; return tmp; } void reset(T *newptr = nullptr) { if (_ptr != newptr) { delete _ptr; // 释放当前资源 _ptr = newptr; // 指向新资源 // 这里不需要置空 newptr // 是否置空 new ptr 由用户决定 } } }; UniquePtr &amp;operator=(UniquePtr &&amp;p) 移动赋值运算符的原理如下图：
...</p></div><footer class=entry-footer><span title='2024-06-29 14:42:02 +0800 +0800'>2024年06月29日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to C++ delete ptr 和 ptr = nullptr 的区别" href=https://blog.cassdev.com/posts/c++-delete-ptr-%E5%92%8C-ptr--nullptr-%E7%9A%84%E5%8C%BA%E5%88%AB/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>哈希冲突解决方法学习笔记</h2></header><div class=entry-content><p>链地址法链地址法也叫做拉链法，它的基本思想是，将哈希表中的每个槽位都指向一个链表，当发生哈希冲突时，将数据插入到链表中。
很好理解，如图所示：
开放定址法开放定址法是一种解决哈希冲突的方法，它的基本思想是，当发生哈希冲突时，不是将数据直接插入到哈希表中，而是寻找哈希表中的空槽位，将数据插入到空槽位中。
线性探测线性探测采用固定步长的线性搜索来进行探测。
插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 1），直至找到空桶，将元素插入其中。 查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 value 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 None 。 注意，我们不能在开放寻址哈希表中直接删除元素。因为删除元素会在数组内产生一个空桶 None ，当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在。
为了解决该问题，我们可以采用懒删除（ lazy deletion ）机制，不直接从哈希表中移除元素，而是利用一个常量 TOMBSTONE 来标记这个桶。
None 和 TOMBSTONE 都代表空桶，都可以放置键值对。线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。在线性探测中记录遇到的首个 TOMBSTONE 的索引，并将搜索到的目标元素与该 TOMBSTONE 交换位置，这样可以优化效率。
线性探测容易产生 聚集现象，为了缓解这个问题，就有了平方探测和双重散列。
平方探测平方探测思想与线性探测类似，不同之处在于探测的步长是平方级别的。即当发生哈希冲突时，探测的步长为 1，4，9，…步。
平方探测可以缓解线性探测的聚集现象，但不能彻底解决。
多次哈希多次哈希的基本思想是，当发生哈希冲突时，尝试其他的哈希函数，直到找到空槽位。
与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。
警告 以上三种方法，线性探测、平方探测和多次哈希哈希表都存在 不能直接删除元素 的问题。
...</p></div><footer class=entry-footer><span title='2024-06-29 10:16:12 +0800 +0800'>2024年06月29日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 哈希冲突解决方法学习笔记" href=https://blog.cassdev.com/posts/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ STL 常用容器和迭代器学习笔记</h2></header><div class=entry-content><p>常用容器 序列容器
vector: 动态数组，随机插入/删除 O(n)，随机访问 O(1)，尾插 O(1)
array: 静态数组，不支持插入/删除，随机访问 O(1)
deque: 双端队列，头尾插入/删除 O(1)，随机访问 O(1)，中间插入/删除 O(n)
list: 双向链表，插入/删除 O(1)，不支持随机访问
forward_list: 单向链表，插入/删除 O(1)，不支持随机访问
关联容器（底层实现为 红黑树 ）
set: 有序集合，插入/删除/查找 O(logn)
map: 有序映射，插入/删除/查找 O(logn)
multiset: 有序多重集合，插入/删除/查找 O(logn)
multimap: 有序多重映射，插入/删除/查找 O(logn)
无序容器（底层实现为 哈希表 ）
unordered_set: 无序集合，插入/删除/查找 O(1)
unordered_map: 无序映射，插入/删除/查找 O(1)
unordered_multiset: 无序多重集合，插入/删除/查找 O(1)
unordered_multimap: 无序多重映射，插入/删除/查找 O(1)
容器适配器
stack: 栈，后进先出，只能在栈顶插入/删除元素
queue: 队列，先进先出，只能在队尾插入，在队头删除元素
priority_queue: 优先队列，元素按照一定规则排序，每次取出的是最大/最小元素，底层实现为堆
vector#include &lt;iostream> #include &lt;vector> using namespace std; // vector使用示例 int main() { vector&lt;int> vec = {1, 2, 3, 4, 5}; // 尾部插入元素：复杂度为O(1) vec.push_back(6); // 尾部删除元素：复杂度为O(1) vec.pop_back(); // 随机插入和删除元素：复杂度为O(n) vec.insert(vec.begin() + 1, 3); vec.erase(vec.begin() + 1); // vector的大小 cout &lt;&lt; vec.size() &lt;&lt; endl; // 获取vector的容量 cout &lt;&lt; vec.capacity() &lt;&lt; endl; // 判断vector是否为空 cout &lt;&lt; vec.empty() &lt;&lt; endl; // 获取vector的第一个元素和最后一个元素 cout &lt;&lt; vec.front() &lt;&lt; endl; cout &lt;&lt; vec.back() &lt;&lt; endl; // 访问指定位置的元素 cout &lt;&lt; vec[2] &lt;&lt; endl; cout &lt;&lt; vec.at(2) &lt;&lt; endl; // at函数会检查索引是否越界，更安全 vector&lt;int> vec2 = {7, 8, 9, 10}; vec.swap(vec2); // 交换两个vector的元素 // 清空vector vec.clear(); } vector 常用的成员函数：
...</p></div><footer class=entry-footer><span title='2024-06-28 19:50:50 +0800 +0800'>2024年06月28日</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to C++ STL 常用容器和迭代器学习笔记" href=https://blog.cassdev.com/posts/c++-stl-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://blog.cassdev.com/posts/page/2/>下一页 »&nbsp;2/9&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>