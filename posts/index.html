<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Cassius0924 的博客</title><meta name=keywords content><meta name=description content="Posts - Cassius0924 的博客"><meta name=author content><link rel=canonical href=https://blog.cassdev.com/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.4f5249ac184c033613d94c5267209e90161d3a93365c2feb0ad3960a4bbb6393.css integrity="sha256-T1JJrBhMAzYT2UxSZyCekBYdOpM2XC/rCtOWCku7Y5M=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.cassdev.com/posts/index.xml><link rel=alternate hreflang=zh href=https://blog.cassdev.com/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/posts/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.cassdev.com/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title="Cassius0924 的博客"><span>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://blog.cassdev.com/>首页</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>烧录树莓派系统镜像指南</h2></header><div class=entry-content><p>我把尘封已久的 树莓派4B 拿出来，准备重新使用它，结果发现我进不去系统了 😇。。。
因为忘记了 Hostname 和 Password，手上没有 TTL 转串口线，也没有 micro HDMI 转 HDMI 线，无法通过串口或者显示器进行恢复。
不过正好有一个 micro SD 卡读卡器，可以通过重新烧录系统镜像的方式来恢复树莓派的使用。
准备工作 一台 macOS/Linux/Windows 电脑，我这里以 macOS 为例 一个 micro SD 卡读卡器 如果你是 MacBook，你多半没有 USB-A 接口，需要一个 USB-A（母）转 USB-C（公）的转接头。 步骤下载树莓派官方烧录工具前往树莓派官网下载官方烧录工具 Raspberry Pi Imager，根据你的操作系统选择对应的版本进行下载和安装。这里不赘述。
将 SD 卡插入读卡器并连接电脑这很简单吧，怎么插就不展示了。
烧录配置打开安装好的 Raspberry Pi Imager。
选择设备型号
选择你的树莓派的型号，我是树莓派 4B，我这里选择 Raspberry Pi 4。
不知道树莓派型号的话，看看你的板子，找找板上的小字，一般会有型号标识。
选择操作系统
选择你想要烧录的操作系统，一般都选择 Raspberry Pi OS (64-bit)。
选择存储设备
选择你插入的 SD 卡读卡器对应的存储设备。如果你的电脑只插了
配置 Hostname
...</p></div><footer class=entry-footer><span title='2026-02-02 18:47:58 +0800 +0800'>2026年02月02日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 烧录树莓派系统镜像指南" href=https://blog.cassdev.com/posts/%E7%83%A7%E5%BD%95%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s2.loli.net/2026/01/31/Zrlvk4jgiQbsVy3.jpg alt="使用 systemd 优雅的管理自启动服务"></figure><header class=entry-header><h2 class=entry-hint-parent>使用 systemd 优雅的管理自启动服务</h2></header><div class=entry-content><p>systemd 是现代 Linux 发行版中广泛使用的初始化系统和服务管理器。它不仅提供了强大的功能来管理系统服务，还允许用户轻松地配置和管理自启动服务。
systemd 中的字母 d 表示 （daemon）守护进程，相信学过操作系统的同学都知道守护进程是指在后台运行的进程。
systemd 作为守护进程管理器，负责启动、停止和管理系统中的各种服务。
systemd 操作命令systemctlsystemctl（system control）是 systemd 的主要命令行工具。它用于检查和控制 systemd 系统和服务管理器的状态。
刷新配置文件
sudo systemctl daemon-reload 但你修改了服务的配置文件后，需要运行这个命令来让 systemd 重新加载配置文件。否则 systemd 不会识别你的更改。
启动服务
sudo systemctl start &lt;service_name> 这个命令用于启动指定的服务，当系统重启后，服务不会自动启动。
停止服务
sudo systemctl stop &lt;service_name> 这个命令用于停止指定的服务。
重启服务
sudo systemctl restart &lt;service_name> 这个命令用于重启指定的服务。
重新加载服务配置
sudo systemctl reload &lt;service_name> 这个命令用于重新加载指定服务的配置，而不停止服务。它与 restart 的区别在于，reload 不会中断服务的运行，适用于支持热加载配置的服务。
查看服务状态
sudo systemctl status &lt;service_name> 这个命令用于查看指定服务的当前状态。
启用服务自启动
sudo systemctl enable &lt;service_name> 这个命令用于使指定的服务在系统启动时自动启动。但是不会立即启动服务，如果想立即启动服务，可以加上 --now 选项： sudo systemctl enable --now &lt;service_name>
...</p></div><footer class=entry-footer><span title='2026-01-31 01:40:00 +0800 +0800'>2026年01月31日</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 使用 systemd 优雅的管理自启动服务" href=https://blog.cassdev.com/posts/%E4%BD%BF%E7%94%A8-systemd-%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用 Certbot 申请泛域名 SSL 证书指南</h2></header><div class=entry-content><p>使用 Certbot 申请泛域名证书并不复杂，几个月前搞过，但是又忘了，今天重新搞了一遍，记录一下步骤。
前提条件 你需要有一个域名，并且可以管理该域名的 DNS 记录。 一般我们都是在 阿里云 或 火山引擎 等云服务商购买的域名，这里以阿里云为例。
申请泛域名证书安装 Certbot先用 certbot --version 检查是否已经安装 Certbot，如果没有安装，下面一句话安装一下：
sudo apt install certbot -y 申请证书泛域名证书需要通过 DNS-01 验证域名所有权，使用以下命令申请，注意将 *.cassdev.com 和 cassdev.com 替换为你的域名，example@google.com 替换为你的邮箱。
笔记 什么是 DNS-01 验证？
...</p></div><footer class=entry-footer><span title='2026-01-28 20:23:00 +0800 +0800'>2026年01月28日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 使用 Certbot 申请泛域名 SSL 证书指南" href=https://blog.cassdev.com/posts/%E4%BD%BF%E7%94%A8-certbot-%E7%94%B3%E8%AF%B7%E6%B3%9B%E5%9F%9F%E5%90%8D-ssl-%E8%AF%81%E4%B9%A6%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LLM 参数之 Temperature 和 Top-p</h2></header><div class=entry-content><p>大家在使用 LLM 生成内容时，不知道有没有注意到 LLM 的一些可配置参数，比如 Temperature 和 Top-p，是否关注过这些参数的作用？
无论是在 OpenAI 的 API 文档、Google 的 AI Studio、以及各种的 AI 平台，你都能看到它的身影。
什么是 Temperature 和 Top-p？在与 LLM 聊天时，大家可能已经注意到，有的 Agent 十分有创造力，有的 Agent 又十分严谨。这其中除了 Prompt 的影响外，还有一个重要的因素就是 LLM 的采样参数，包括 Temperature 和 Top-p。
提示 TL;DR
...</p></div><footer class=entry-footer><span title='2025-07-31 00:00:00 +0000 UTC'>2025年07月31日</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to LLM 参数之 Temperature 和 Top-p" href=https://blog.cassdev.com/posts/llm-param-temeprature-and-top-p/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s2.loli.net/2025/07/29/2tPIjcy5MbA7K9f.png alt="The Response Format of LLM parameter"></figure><header class=entry-header><h2 class=entry-hint-parent>LLM 参数之 Response Format</h2></header><div class=entry-content><p>如果想让 LLM 输出 JSON 格式的内容，大家第一反应会是什么？可能大多数人和我一样，直接在提示词中写上"请输出 JSON 格式的内容，格式为 { “key”: “value” }"。但其实，这种方式并不是最优的。
从之前我们也了解到了，LLM 的输出是一个概率性的文本补全器。单纯依靠提示词工程来控制 LLM 的输出格式并不可靠。用自然语言去描述一个复杂的 JSON 结构本就不易，再加上当提示词很长时，LLM 的注意力可能会分散，这些因素都容易导致它输出不符合预期的格式，甚至根本不输出 JSON。
具体来说，这种方式可能会遇到以下三个主要问题：
混入无关文本：模型可能在 JSON 对象前后添加对话式的"口水话"，如"好的，这是您要的 JSON：…"，这给后续的程序化解析带来了困难。
结构性错误：生成的 JSON 可能存在语法错误，例如缺少逗号、括号不匹配或引号使用不当，导致解析失败。
内容幻觉：模型可能"幻觉"出指令中未要求的字段，或遗漏必要的字段，破坏了数据模式的一致性。
让 LLM 生成符合预期的 JSON 格式内容的最佳实践是使用 response_format 参数，在程序算法的层面上去干预 LLM 的输出格式。这个参数允许我们让 LLM 进行结构化内容输出，确保 LLM 生成的内容符合预期的结构和语法。
Response Format 参数response_format 参数在绝大多数现代 LLM API 中都可用，允许开发者指定模型输出的格式。
DeepSeek API Response Format
OpenAI API Response Format
DouBao API Response Format
通过这个参数，我们可以明确要求 LLM 生成特定格式的内容，如 JSON 对象、纯文本或符合 JSON Schema 的数据结构。
response_format 参数支持以下三个模式：
...</p></div><footer class=entry-footer><span title='2025-07-29 00:00:00 +0000 UTC'>2025年07月29日</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to LLM 参数之 Response Format" href=https://blog.cassdev.com/posts/llm-param-response-format/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s2.loli.net/2025/03/16/mQydfgXDYCuKPLo.png alt="Textmate 语法高亮规则运行机制"></figure><header class=entry-header><h2 class=entry-hint-parent>浅析 Textmate 语法高亮规则运行机制</h2></header><div class=entry-content><p>1. 语法高亮简介语法高亮是指在IDE或编辑器中，对文本进行分词，即将文本拆解为 Token（标记），每个 Token 都有对应的名称（作用域）进行标记。再配合主题样式规则，对不同名称的 Token 的进行主题化，以提高代码的可读性。
程序员离不开语法高亮，就像作家离不开标点符号一样。（你可以代入一下使用 txt 文本编辑器写代码的场景）
语法高亮由两个部分组成：
分词（Tokenization）：将文本拆解为一系列 Token。 主题化（Theming）：对 Token 进行样式渲染，如字体颜色、背景色、加粗等。 我们以 JSON 的语法为例，简单介绍一下语法高亮的过程。
首先分词引擎会对 JSON 文本进行分词，下图是将 JSON 文本进行分词后的结果，其中每个矩形所包括的文本都是一个 Token，每个 Token 都有一个作用域名称，例如 null 对应的是 constant.language.json 作用域。
然后主题化引擎会根据 Token 的作用域名称，对 Token 进行样式渲染，例如将 constant.language.json 作用域映射为蓝色不加粗字体。那么 null 就会被渲染为蓝色不加粗字体。
2. 分词的实现方式目前主流的分词实现方式大致有有以下三种：
基于正则表达式的分词：Textmate 基于词法分析的分词：Highlight.js 基于语法树的分词：Tree-sitter (如果有其他，欢迎补充) 本文只讨论 Textmate 的语法高亮规则编写。
Textmate 原是 MacOS 下的一款文本编辑器，其语法高亮规则是基于正则表达式的，但由于其规则简单易懂，且支持多种语言，因此被广泛应用于各种编辑器和IDE中，如 VSCode、Sublime Text 等。JetBrains 的 IDE 也集成了 Textmate Bundle 插件，可以直接导入 Textmate 的语法高亮规则。
...</p></div><footer class=entry-footer><span title='2025-07-20 15:47:58 +0800 +0800'>2025年07月20日</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 浅析 Textmate 语法高亮规则运行机制" href=https://blog.cassdev.com/posts/%E6%B5%85%E6%9E%90-textmate-%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E8%A7%84%E5%88%99%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Vim 技能补全计划</h2></header><div class=entry-content><p>适合已经熟悉 Vim 基础操作，希望提高编辑技能的开发者的实用技巧集合</p></div><footer class=entry-footer><span title='2025-07-19 00:00:00 +0000 UTC'>2025年07月19日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Vim 技能补全计划" href=https://blog.cassdev.com/posts/vim-skill-completion-plan/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Socket 编程之 epoll 源码分析学习笔记</h2></header><div class=entry-content><p>本文基于 Linux 6.9 内核源码进行分析。
几个数据结构
eventpoll这是 epoll 的主要数据结构，它用于存储 epoll 的相关信息，包括等待队列、就绪队列、红黑树等。
struct eventpoll { wait_queue_head_t wq; // epoll 的等待队列：用于存储等待的进程/线程，指向等待队列头 wait_queue_head_t poll_wait;// 这个 poll_wait 等待队列只有在 epoll 嵌套的情况下才会用到 struct list_head rdllist; // 就绪队列：用于存储就绪的 fd，指向就绪队列头 struct rb_root_cached rbr; // 红黑树：用于存储所有的 fd，指向红黑树根节点 struct wakeup_source *ws; // 一个唤醒源，用于唤醒进程 }; epitemepitem 的作用是将 fd、就绪队列、红黑树节点等信息封装在一起。
struct epitem { union { struct rb_node rbn; // 红黑树节点，用于存储 fd，指向红黑树节点 struct rcu_head rcu; // 用于释放 epitem }; struct list_head rdllink; // 就绪队列节点，用于存储就绪的 fd，指向就绪队列节点 struct eventpoll *ep; // 指向 eventpoll struct epoll_filefd ffd; // epoll 文件描述符 struct wakeup_source *ws; // 一个唤醒源，用于唤醒进程 struct epoll_event event; // 监听的事件 }; ep_pqueue给 poll 队列封装的结构体，用于存储 poll_table 和 epitem。
...</p></div><footer class=entry-footer><span title='2024-06-30 15:31:40 +0800 +0800'>2024年06月30日</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Socket 编程之 epoll 源码分析学习笔记" href=https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-epoll-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ 内存模型学习笔记</h2></header><div class=entry-content><p>C++ 内存模型从上（高地址）到下（低地址）可以分为以下几个部分：
栈区：由编译器自动分配释放，存放函数的参数值、局部变量的值等。
堆区：由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收。
全局/静态区：分为 .data 段（全局初始化区）和 .bss 段（全局未初始化区），.data 段存放 已初始化 了的全局变量和静态变量，.bss 段存放 未初始化 的变量。
常量区：就是 .rodata 段，存放常量。
代码区：存放函数体的代码。</p></div><footer class=entry-footer><span title='2024-06-29 16:44:14 +0800 +0800'>2024年06月29日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to C++ 内存模型学习笔记" href=https://blog.cassdev.com/posts/c++-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ delete ptr 和 ptr = nullptr 的区别</h2></header><div class=entry-content><p>delete ptrdelete ptr 是释放 ptr 所指向的对象资源，而 ptr 依然存在，且依然指向那片内存地址。
ptr = nullptrptr = nullptr 是将 ptr 指向空指针，和其所指向的对象没关系。
试着实现一个 unique_ptrtemplate &lt;typename T> class UniquePtr { private: T *_ptr; public: // 默认构造 UniquePtr() : _ptr(nullptr) { } explicit UniquePtr(T *ptr) : _ptr(ptr) { } ~UniquePtr() { delete _ptr; // 无需置 nullptr，因为析构函数会被调用，_ptr 会被销毁 // 置空无意义 } // 拷贝构造 删除 UniquePtr(const UniquePtr &) = delete; UniquePtr &amp;operator=(const UniquePtr &) = delete; // 移动构造 UniquePtr(UniquePtr &&amp;p) noexcept : _ptr(p._ptr) { // 至于这里为什么不需要 delete _ptr // 是因为这是移动构造函数，是个构造函数！_ptr 本来就没有资源 p._ptr = nullptr; } UniquePtr &amp;operator=(UniquePtr &&amp;p) noexcept { if (p != *this) { delete _ptr; // 第一步，释放当前资源 _ptr = p._ptr; // 第二步，将当前指针指向新的资源 p._ptr = nullptr; // 第三步，将原来的指针置空 } return *this; } T *get() const { // 返回指针 return _ptr; } T *operator->() const { // 返回指针 return _ptr; } T &amp;operator*() const { // 解引用 return *_ptr; } T *release() { // 这里不能 delete _ptr // 因为 release 只是解除 UniquePtr 对资源的所有权，但资源还是存在的 T *tmp = _ptr; _ptr = nullptr; return tmp; } void reset(T *newptr = nullptr) { if (_ptr != newptr) { delete _ptr; // 释放当前资源 _ptr = newptr; // 指向新资源 // 这里不需要置空 newptr // 是否置空 new ptr 由用户决定 } } }; UniquePtr &amp;operator=(UniquePtr &&amp;p) 移动赋值运算符的原理如下图：
...</p></div><footer class=entry-footer><span title='2024-06-29 14:42:02 +0800 +0800'>2024年06月29日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to C++ delete ptr 和 ptr = nullptr 的区别" href=https://blog.cassdev.com/posts/c++-delete-ptr-%E5%92%8C-ptr--nullptr-%E7%9A%84%E5%8C%BA%E5%88%AB/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://blog.cassdev.com/posts/page/2/>下一页 »&nbsp;2/9&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>