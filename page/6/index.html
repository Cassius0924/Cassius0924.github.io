<!doctype html><html lang=zh dir=auto><head><meta name=generator content="Hugo 0.148.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cassius0924 的博客</title><meta name=description content><meta name=author content><link rel=canonical href=https://blog.cassdev.com/><link crossorigin=anonymous href=/assets/css/stylesheet.4f5249ac184c033613d94c5267209e90161d3a93365c2feb0ad3960a4bbb6393.css integrity="sha256-T1JJrBhMAzYT2UxSZyCekBYdOpM2XC/rCtOWCku7Y5M=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.cassdev.com/index.xml><link rel=alternate type=application/json href=https://blog.cassdev.com/index.json><link rel=alternate hreflang=zh href=https://blog.cassdev.com/><link rel=alternate hreflang=en href=https://blog.cassdev.com/en/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="Cassius0924 的博客"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cassius0924 的博客"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Cassius0924 的博客","url":"https://blog.cassdev.com/","description":"","logo":"https://blog.cassdev.com/favicon.ico","sameAs":["https://github.com/Cassius0924","https://space.bilibili.com/12873865","mailto:cassius0924@qq.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title="Cassius0924 的博客"><span class=active>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YOLO 目标检测算法学习笔记（二）</h2></header><div class=entry-content><p>可以说，YOLO各代升级的改进点都是提升检测效果mAP和速度FPS。
Precision精度与Recall召回率要计算精度与召回率（查全率），我们需要先了解四个值：
TP（True Positives） FP（False Positives） FN（False Negatives） TN（True Negatives） 相关（Relevant），正类 无关（NonRelevant），负类 被检索到（Retrieved） TP，正类判定为正类。 FP，负类判定为正类 未被检索到（Not Retrieved） FN，正类判定为负类 TN，负类判断为负类 记忆方法我们只需要记住这里面的四个单词的中文意思方可推断出四个值的含义。True 正确的、False 错误的、Positives 正类以及 Negatives 负类。
True Positives（➕➕）——正确的判断为正类，即将正类判定为正类。
False Positives（➖➕）——错误的判定为正类，即将负类判定为正类。
False Negatives（➕➖）——错误的判定为负类，即将正类判定为正类。
True Negatives（➖➖）——正确的判定为负类，即将负类判定为负类。
计算公式$$ Precision = \frac{TP}{TP+FP} $$
$$ Recall = \frac{TP}{TP + FN} $$
为了方便理解，我画了一个草图，以格子为单位。其中蓝色框代表实际值，橙色框代表预测值。
真正的正类（蓝色框内）共20个格子，真正的负类（蓝色框外）共10个格子。判定的正类（橙色框内），判定的负类（橙色框外）
TP值（正确的判断为正类），真正的正类与判定的正类的交集，即涂黄色的格子，共9个格子。
FP值（错误的判定为正类），真正的负类与判定的正类的交集，即涂绿色的格子，共6个格子。
FN值（错误的判定为负类），真正的正类与判定的负类的交集，即涂蓝色的格子，共11个格子。
TN值（正确的判定为负类），真正的负类与判定的负类的交集，即涂红色的格子，共4个格子。
例子已知条件：班级总人数100人，其中男生80人，女生20人。 目标：找出所有的女生。 结果：从班级中选择了50人，其中20人是女生，还错误的把30名男生挑选出来了。
TP = 20; FP = 30; FN = 0; TN = 50
mAP指标目标检测不可单看精度（Precision）或召回率（Recall），因为两者为此消彼长的关系。所以需要一个新的指标用于综合的衡量目标检测的效果。
mAP（mean Average Precision）指标，又名全类平均精度，用于综合衡量目标检测的效果。
...</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to YOLO 目标检测算法学习笔记（二）" href=https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YOLO 目标检测算法学习笔记（三）</h2></header><div class=entry-content><p>YOLO-V1YOLO，全称 You Only Look Once。名字已经说明了一切！
YOLO 这是一个经典的 one-stage 方法，把检测问题转换为回归问题，一个CNN就可以搞定。
YOLO 相比于 Faster R-CNN 虽然在 mAP 值上略逊一筹，但其 FPS 值是远远高于 Faster R-CNN 的，因此2016年的时，YOLO爆火。
核心思想
将输入图像分割成 SxS 个网格（如7x7），每个网格负责检测本身区域是否含有物体。
每个网格会预测 B 个边界框（在YOLO-V1中，B值等于2），边界框由四个变量表示 x、y、w、h，以及每个边界框的置信度，置信度用 c 表示。置信度表示边界框包含物体的概率。
过滤掉置信度低的边界框。
由于整个检测只需要一个前向传播，没有区域提议生成候选框的过程，所以速度非常快。
网络架构
将输入图像（在YOLO-V1中限制了输入图像的大小）进行通过卷积神经网络进行特征提取，获得 7x7x1024 的特征图，再进入全连接层，得到 1470 个特征，随后 Reshape 成 7x7x30 的特征图。
下面解释一下 7x7x30 的含义。
7x7 表示输入图像最后分割的网格大小。
30 分为 5+5+20，其中前两个5代表两个边界框的 x、y、w、h和c；最后的20表示当前格子属于数据集中的各个类别的概率。
注意，这里三个值都不是固定不变的，会由于YOLO版本的更新和训练数据集的变化而改变。
总结一下 ，如上图所示，输入图像最后会被分割成许多个网格，每个网格都包含了若干值。
S：网格边长；B：预测边界框数量；C：数据集中的类别个数。 $$ (S * S) * (B * 5 + C) $$
...</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to YOLO 目标检测算法学习笔记（三）" href=https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YOLO 目标检测算法学习笔记（四）</h2></header><div class=entry-content><p>YOLO-V2下图为YOLO-V2相较于YOLO-V1的改进点，以及改进后 mAP 值的变化。
Batch NormalizationV2 版本舍弃了 Dropout，不再有全连接层（Fully connected layers，FC）。每次卷积后都加入 Batch Normalization，对网络的每一层的输入都进行归一化，使收敛更容易。
经过 Batch Normalization 处理后的网络会提升2%的mAP值。
从现在的角度来看，Batch Normatlization 已经称为卷积神经网络处理必备处理了。
High Resolution ClassifierHigh Resolution Classifier，即高分辨率分类器，高分辨率分类器。
在 V1 版本，训练时用的是224*224分辨率的图片，测试时又使用448*448分辨率的图片，这会导致模型“水土不服”。
针对这一问题，V2 版本在模型训练时额外进行了10次448*448的微调。经过微调后，V2 版本的 mAP 值提升了约4%。
Convolutional</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to YOLO 目标检测算法学习笔记（四）" href=https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YOLO 目标检测算法学习笔记（一）</h2></header><div class=entry-content><p>深度学习经典检测方法 one-stage（单阶段）：YOLO系列
two-stage（双阶段）：Faster-Rcnn、Mask-Rcnn系列
Faster-Rcnn：物体检测开山之作。
one-stage 单阶段检测优势：速度快，适合做实时检测任务。
缺点：效果不佳。
目标检测的两个主要指标：mAP和FPS。
mAP：检测效果的综合指标。（mAP值越大效果越好）
two-stage 双阶段检测优势：效果较好。
缺点：速度较慢、不适合用于视频流的实时检测。
Mask-Rcnn是一个非常实用的通用框架（建议了解）。</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to YOLO 目标检测算法学习笔记（一）" href=https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>基于 L2CAP 协议的蓝牙 BLE 设备通信指南</h2></header><div class=entry-content><p>蓝牙 BLE 是什么蓝牙BLE，即蓝牙低功耗 （Bluetooth Lower Energy）是一种蓝牙通信标准，设计用于短距离通信和低功耗应用。
相比经典蓝牙，BLE 更加节能，传输距离更远，连接更快。BLE 主要用于健身设备、医疗设备、家居自动化等场景。
蓝牙 BLE 设备的连接信道L2CAP的基本概念是信道（Signaling Channel）。信道是个抽象概念，表示两个设备某个协议层之间的通道。每个信道分配一个2字节的信道ID——CID（Channel ID），每个信道功用不同，比如CID=0x0004的信道表示属性协议（Attribute Protocol）专用信道。对于BLE协议，L2CAP共有三个信道ID：
0x0004 – 属性协议 0x0005 – 低功耗信令信道 0x0006 – 安全管理协议 其他信道则用于经典蓝牙。协议复用可以理解为，不同的协议走不同的信道，互不干扰。
代码#define ATT_CID 4; // 创建 L2CAP socket int s = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP); // 绑定 L2CAP socket struct sockaddr_l2 bind_addr = {0}; bind_addr.l2_family = AF_BLUETOOTH; bind_addr.l2_cid = htobs(ATT_CID); // ATT 信道 CID bdaddr_t any_addr = {{0, 0, 0, 0, 0, 0}}; bacpy(&amp;bind_addr.l2_bdaddr, &amp;any_addr); bind_addr.l2_bdaddr_type = BDADDR_LE_PUBLIC; int err = bind(s, (struct sockaddr *)&amp;bind_addr, sizeof(bind_addr)); if (err) { return -1; } // 连接 L2CAP socket struct sockaddr_l2 conn_addr = {0}; conn_addr.l2_family = AF_BLUETOOTH; conn_addr.l2_cid = htobs(ATT_CID); // ATT CID str2ba(mac_address.c_str(), &amp;conn_addr.l2_bdaddr); conn_addr.l2_bdaddr_type = BDADDR_LE_PUBLIC; err = connect(s, (struct sockaddr *)&amp;conn_addr, sizeof(conn_addr)); if (err) { exit(-1); } L2CAP 数据包解析L2CAP（Logical Linked Control and Adaptation Protocol 逻辑链路控制与适配协议）工作在链路层,为上层协议提供数据通道。它支持数据分片与重组,确保数据完整可靠地传输。
...</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 基于 L2CAP 协议的蓝牙 BLE 设备通信指南" href=https://blog.cassdev.com/posts/%E5%9F%BA%E4%BA%8E-l2cap-%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%93%9D%E7%89%99-ble-%E8%AE%BE%E5%A4%87%E9%80%9A%E4%BF%A1%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>解决VScode远程开发C++项目时无代码提示问题</h2></header><div class=entry-content><p>简单粗暴，给本地主机和远程主机都安装上C/C++插件即可。</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 解决VScode远程开发C++项目时无代码提示问题" href=https://blog.cassdev.com/posts/%E8%A7%A3%E5%86%B3vscode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91c++%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%97%A0%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA%E9%97%AE%E9%A2%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>三维重建笔记——从变换矩阵中提取并分析平移量</h2></header><div class=entry-content><p>在编写点云变换和姿态估计代码时，我们经常需要从结果的变换矩阵中提取平移信息，并分析平移量的大小，帮助判断结果的准确性。
本文将介绍如何从变换矩阵中提取平移向量，并计算其欧几里得长度。
提取平移向量假设我们通过某种姿态估计算法得到了一个4x4的变换矩阵 result.transformation_ ,其中包含了旋转和平移信息。
我们可以通过以下代码提取出平移部分:（以Open3D为例）
core::Tensor translation = result.transformation_.Slice(0, 0, 3).Slice(1, 3, 4); Slice(0,0,3);表示从矩阵的第0维(行)，第0行开始，取3行，即前3行；Slice(1,3,4);表示从矩阵的第1维(列)，第3列开始，取1列，即第4列。 最后获得一个3x1的平移向量，包含x、y、z三个方向的平移量。
计算欧几里得长度有了平移向量后,我们可以计算其欧几里得长度,表示平移量的大小:
double translation_norm = std::sqrt((translation * translation).Sum({0, 1}).Item&lt;double>()); std::sqrt计算平方根，translation * translation 计算向量每个元素的平方，Sum 聚合，最终得到平移向量的L2范数，即欧几里得长度。
分析平移量通过提取并计算平移向量的模长，我们可以分析相机或物体的移动距离，以及姿态估计结果的准确性。
如果 translation_norm 的值过大，可能表示估计存在误差，需要反复优化算法。
设置不同的阈值可以根据实际场景需求，判断平移量是否在允许的范围内。
以上是从变换矩阵中提取和利用平移信息的简单示例，可以提供点云变换和姿态估计任务有用的辅助分析。</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 三维重建笔记——从变换矩阵中提取并分析平移量" href=https://blog.cassdev.com/posts/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%AC%94%E8%AE%B0%E4%BB%8E%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%8F%90%E5%8F%96%E5%B9%B6%E5%88%86%E6%9E%90%E5%B9%B3%E7%A7%BB%E9%87%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>通过 frp 内网穿透实现异地 SSH 连接（反向代理）</h2></header><div class=entry-content><p>起因是我放假回家，想在家里通过 SSH 连接放在学校的无显示器的 Linux，但是学校的 Linux 是内网，无法直接连接，且无显示器无法使用向日葵等远程桌面软件，所以想到了使用 frp 的反向代理功能实现内网穿透，进而实现异地 SSH 连接。
前提 一台具有公网 IP 的服务器（阿里云、腾讯云等） 配置远程主机我们需要有三台主机，分别是：自己的电脑、远程 Linux 主机和具有公网 IP 的服务器。
只需要在远程 Linux 和具有公网 IP 的服务器上配置 frp 即可。
首先在远程 Linux 上下载 frp，Github 下载地址。下载远程主机对应的版本，我这里是 ARM64 架构的 Linux，所以下载 frp_0.51.2_linux_arm64.tar.gz。
下载完毕后解压：
tar -xvf frp_0.51.2_linux_arm64.tar.gz cd frp_0.51.2_linux_arm64 远程 Linux 为客户端，所以只需要保留 frpc* 文件即可，frps可以删除。
rm frps* 修改frpc.ini，只需要将server_addr修改为服务器的 IP 地址即可，local_ip不变。server_port和remote_port一般不变，若与其他服务冲突了可以修改。
vim frpc.ini #:wq 退出 配置服务器同样下载好对应系统版本的 frp，解压后删除frpc*文件。
rm frpc* 修改frpc.ini，确保bind_port与 frpc 客户端，即远程主机的server_port一致。
再前往阿里云或腾讯云官网配置服务器防火墙规则，开放服务器的 6000 和 7000 端口（若修改了则开放修改后的端口）。
...</p></div><footer class=entry-footer><span title='2024-06-16 11:20:31 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 通过 frp 内网穿透实现异地 SSH 连接（反向代理）" href=https://blog.cassdev.com/posts/%E9%80%9A%E8%BF%87-frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%9C%B0-ssh-%E8%BF%9E%E6%8E%A5%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ Copy&amp;Swap 惯用法指南</h2></header><div class=entry-content><p>Copy&amp;Swap 是什么Copy&amp;Swap 是一种 C++ 中常用的编程技巧，用于实现类的赋值运算符（operator=）。
实现传统写法先看看未使用 Copy&amp;Swap 的赋值运算符写法：
#include &lt;iostream> #include &lt;vector> class OldAClass { private: int _count; std::string _str; std::vector&lt;int> _vec; public: OldAClass() : _count(0), _vec(10) {} // 拷贝构造函数 和 拷贝赋值运算符 OldAClass(OldAClass &amp;a) : _count(a._count), _str(a._str), _vec(a._vec) { std::cout &lt;&lt; "Copy constructor called\n"; } OldAClass &amp;operator=(OldAClass &amp;a) { std::cout &lt;&lt; "Copy Assignment operator called\n"; if (this != &amp;a) { //判断传入的 a 是否是自己 _count = a._count; _str = a._str; _vec = a._vec; } return *this; } // 移动构造函数 和 移动赋值运算符 OldAClass(OldAClass &&amp;a) noexcept : _count(a._count), _str(std::move(a._str)), _vec(std::move(a._vec)) { std::cout &lt;&lt; "Move constructor called\n"; } OldAClass &amp;operator=(OldAClass &&amp;a) noexcept { std::cout &lt;&lt; "Move Assignment operator called\n"; if (this != &amp;a) { _count = a._count; _str = std::move(a._str); _vec = std::move(a._vec); } return *this; } }; 可以看到，这种写法需要重复写两次赋值运算符，并且每次都需要判断传入的参数是否是自己，而且代码重复度高。
Copy&amp;Swap 写法class AClass { private: int _count; std::string _str; std::vector&lt;int> _vec; public: AClass() : _count(0), _vec(10) {} static void swap(AClass &amp;a, AClass &amp;b) { std::swap(a._count, b._count); std::swap(a._str, b._str); std::swap(a._vec, b._vec); } // 拷贝构造函数 AClass(AClass &amp;a) : _count(a._count), _str(a._str), _vec(a._vec) { std::cout &lt;&lt; "Copy constructor called\n"; } // 移动构造函数 AClass(AClass &&amp;a) noexcept { std::cout &lt;&lt; "Move constructor called\n"; swap(*this, a); } // 赋值运算符 AClass &amp;operator=(AClass a) { // 注意这里的参数是值传递，会调用拷贝构造函数 std::cout &lt;&lt; "Assignment operator called\n"; swap(*this, a); return *this; } }; 这种写法只需要写一次赋值运算符，代码更简洁，而且不需要判断传入的参数是否是自己。
...</p></div><footer class=entry-footer><span title='2024-01-15 10:00:00 +0800 +0800'>2024年01月15日</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to C++ Copy&Swap 惯用法指南" href=https://blog.cassdev.com/posts/c++-copyswap-%E6%83%AF%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Jetson (Ubuntu Arm64) 安装 Bazel</h2></header><div class=entry-content><p>简介本文旨在帮助用户在 Jetson 上的 Ubuntu Arm64 系统上安装 Bazel。Bazel 是一个开源的构建工具，它专注于构建和测试大型软件项目，并且被广泛应用于机器学习和深度学习领域。通过使用 Bazel，您可以更高效地管理和构建您的项目。
步骤 1：安装OpenJDK在开始安装 Bazel 之前，我们需要安装 OpenJDK。在终端中执行以下命令：
sudo add-apt-repository ppa:webupd8team/java sudo apt-get update sudo apt-get install openjdk-11-jdk 步骤 2：下载 Bazel 安装包在安装 OpenJDK 之后，我们需要下载 Bazel 的安装包。在终端中执行以下命令：
wget https://github.com/bazelbuild/bazel/releases/download/6.2.1/bazel-6.2.1-dist.zip 或者，您也可以从 Bazel 的 Github 仓库下载最新版本的安装包。（必须下载dist.zip文件）
步骤 3：安装 Bazel下载完成后，我们可以使用以下命令来安装 Bazel：
unzip bazel-6.2.1-dist.zip -d bazel-6.2.1 bash./compile.sh sudo cp output/bazel /usr/local/bin 步骤 4：验证安装安装完成后，我们可以验证 Bazel 是否成功安装。在终端中执行以下命令：
bazel version 如果一切正常，您应该能够看到如下输出：</p></div><footer class=entry-footer><span title='2023-06-14 10:00:00 +0800 +0800'>2023年06月14日</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Jetson (Ubuntu Arm64) 安装 Bazel" href=https://blog.cassdev.com/posts/jetson-ubuntu-arm64-%E5%AE%89%E8%A3%85-bazel/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.cassdev.com/page/5/>«&nbsp;« 上一页&nbsp;5/9
</a><a class=next href=https://blog.cassdev.com/page/7/>下一页 »&nbsp;7/9&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>