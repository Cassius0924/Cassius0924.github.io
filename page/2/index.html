<!doctype html><html lang=zh dir=auto><head><meta name=generator content="Hugo 0.148.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cassius0924 的博客</title><meta name=description content><meta name=author content><link rel=canonical href=https://blog.cassdev.com/><link crossorigin=anonymous href=/assets/css/stylesheet.4f5249ac184c033613d94c5267209e90161d3a93365c2feb0ad3960a4bbb6393.css integrity="sha256-T1JJrBhMAzYT2UxSZyCekBYdOpM2XC/rCtOWCku7Y5M=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.cassdev.com/index.xml><link rel=alternate type=application/json href=https://blog.cassdev.com/index.json><link rel=alternate hreflang=zh href=https://blog.cassdev.com/><link rel=alternate hreflang=en href=https://blog.cassdev.com/en/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="Cassius0924 的博客"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cassius0924 的博客"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Cassius0924 的博客","url":"https://blog.cassdev.com/","description":"","logo":"https://blog.cassdev.com/favicon.ico","sameAs":["https://github.com/Cassius0924","https://space.bilibili.com/12873865","mailto:cassius0924@qq.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title="Cassius0924 的博客"><span class=active>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>TCP 的常见拥塞控制算法学习笔记</h2></header><div class=entry-content><p>TCP 的拥塞控制算法有几种：
Tahoe
Reno
NewReno
SACK
BIC
CUBIC
BBR
笔记 MSS: Maximum Segment Size，最大分段大小。
...</p></div><footer class=entry-footer><span title='2024-06-27 13:54:31 +0800 +0800'>2024年06月27日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to TCP 的常见拥塞控制算法学习笔记" href=https://blog.cassdev.com/posts/tcp-%E7%9A%84%E5%B8%B8%E8%A7%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ 智能指针学习笔记</h2></header><div class=entry-content><p>智能指针简介智能指针是一种 RAII（Resource Acquisition Is Initialization）技术，用于管理动态分配的内存。智能指针的优点是可以自动释放内存，避免内存泄漏。
C++11 标准引入了三种智能指针：std::unique_ptr、std::shared_ptr 和 std::weak_ptr。
它们都定义在头文件 &lt;memory> 中。
unique_ptrunique_ptr 是一种独占所有权的智能指针，它保证同一时间只有一个指针可以指向对象。
unique_ptr 的创建#include &lt;iostream> #include &lt;memory> int main() { // 使用 new 创建 unique_ptr std::unique_ptr&lt;int> up1(new int(10)); std::cout &lt;&lt; *up1 &lt;&lt; std::endl; // 使用裸指针创建 unique_ptr int count = 20; std::unique_ptr&lt;int> up2(&amp;count); std::cout &lt;&lt; *up2 &lt;&lt; std::endl; // 使用 make_unique 创建 unique_ptr auto up2 = std::make_unique&lt;int>(20); std::cout &lt;&lt; *up2 &lt;&lt; std::endl; return 0; } unique_ptr 的拷贝和赋值unique_ptr 不能拷贝，但可以移动。
#include &lt;iostream> int main() { std::unique_ptr&lt;int> up1(new int(10)); std::unique_ptr&lt;int> up2 = std::move(up1); std::cout &lt;&lt; *up2 &lt;&lt; std::endl; return 0; } unique_ptr 的释放unique_ptr 会在离开作用域时自动释放内存。
#include &lt;iostream> int main() { std::unique_ptr&lt;int> up1(new int(10)); std::cout &lt;&lt; *up1 &lt;&lt; std::endl; return 0; } unique_ptr 的自定义删除器unique_ptr 支持自定义删除器，可以用于释放动态分配的内存。
...</p></div><footer class=entry-footer><span title='2024-06-26 17:24:42 +0800 +0800'>2024年06月26日</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to C++ 智能指针学习笔记" href=https://blog.cassdev.com/posts/c++-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Redis 为什么采用单线程，为什么性能好</h2></header><div class=entry-content><p>Redis 采用单线程的原因是因为在 内存中 进行读写操作，CPU不是Redis的性能瓶颈，而是内存和带宽，所以采用单线程可以避免 线程切换和锁的开销。
Redis 是什么？Redis 是一个开源的内存数据库，它可以存储键值对，支持多种数据结构，如字符串（string）、哈希（hash）、列表（list）、集合（set）、有序集合（zset）等。
Redis 是不是单线程？实际上，Redis 是多线程的，其内部有以下几个线程：
redis-server：主线程，负责接收客户端的连接，读取请求，发送响应。
bio-close-file：负责异步关闭大文件。
bio-aof-fsync：负责将 AOF 文件异步刷到磁盘。
bio-lasy-free：负责异步释放大内存。
jemalloc-bg-thread：负责内存碎片整理。
io-thread：IO 线程，负责 read/write，decode/encode。
笔记 AOF（Append Only File） 是 Redis 的一种持久化方式，将所有写操作追加到文件末尾，重启时重新执行 AOF 文件中的命令即可恢复数据。实时硬盘操作，不会丢失数据，但是会影响性能。
...</p></div><footer class=entry-footer><span title='2024-06-26 15:40:01 +0800 +0800'>2024年06月26日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Redis 为什么采用单线程，为什么性能好" href=https://blog.cassdev.com/posts/redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E5%A5%BD/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>堆排序学习笔记</h2></header><div class=entry-content><p>在学习堆排序之前，我们先来了解一下堆这种数据结构。
堆的概念堆是一种特殊的树形数据结构，它满足以下性质：
堆必须是一个 完全二叉树 。 堆序性：堆中任意节点的值总是不大于或不小于其子节点的值。 根据堆序性，我们可以将堆分为两种类型：
大顶堆：每个节点的值都大于或等于其子节点的值
小顶堆：每个节点的值都小于或等于其子节点的值
所以，如果一个完全二叉树的一个节点即大于其父节点，又大于其子节点，那么这个树就不是一个堆。小于同理。
笔记 完全二叉树的性质
...</p></div><footer class=entry-footer><span title='2024-06-26 10:20:13 +0800 +0800'>2024年06月26日</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 堆排序学习笔记" href=https://blog.cassdev.com/posts/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ 类的运算符为什么要使用引用返回</h2></header><div class=entry-content><p>代码class AClass { private: int _count; public: AClass() : _count(0) { std::cout &lt;&lt; "Default constructor called\n"; } // 赋值运算符，返回引用 AClass &amp;operator=(int cnt) { _count = cnt;k return *this; } // 后置自增运算符，返回引用 int &amp;operator++(int) { ++_count; return *this; } }; 如果不使用引用返回，其实也是可以运行的，只不过会在返回时调用拷贝构造函数，生成临时对象，然后再调用析构函数释放临时对象，这样会多出一次拷贝构造和析构的开销。而使用引用返回，可以直接返回对象的引用，避免了这个开销。
需要注意的是，如果我们返回值类型，我们是不能直接修改返回值的：
class AClass { private: int _count; public: // 省略构造函数 // 赋值运算符，返回引用 AClass operator=(int cnt) { _count = cnt; return *this; } // 后置自增运算符，返回引用 int operator++(int) { ++_count; return *this; } void print() const { std::cout &lt;&lt; "AClass: count = " &lt;&lt; _count &lt;&lt; '\n'; } }; int main() { AClass a; a.print(); // 输出 AClass: count = 0 (a++) = 10; a.print(); // 输出 AClass: count = 1 (a++)++; a.print(); // 输出 AClass: count = 2 } 可以看到，如果我们返回值类型，我们是不能直接修改返回值的。虽然 a++ 已经修改了 a 的值，但是 a++ 返回的是一个修改后的 a 对象的拷贝，所以 (a++) = 10; 或者 (a++)++; 修改的是这个拷贝对象，而不是原对象 a。
...</p></div><footer class=entry-footer><span title='2024-06-25 22:41:04 +0800 +0800'>2024年06月25日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to C++ 类的运算符为什么要使用引用返回" href=https://blog.cassdev.com/posts/c++-%E7%B1%BB%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ 类的流插入和流提取运算符为什么要声明为友元函数</h2></header><div class=entry-content><p>友元函数版代码class AClass { private: int _count; std::string _str; std::vector&lt;int> _vec; public: friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const AClass &amp;a) { os &lt;&lt; "AClass: count = " &lt;&lt; a._count &lt;&lt; ", str = " &lt;&lt; a._str &lt;&lt; ", vec size = " &lt;&lt; a._vec.size(); return os; } }; 为什么要声明为友元函数先理解一下友元函数，它实际上是一个普通函数，不属于类成员，但它又是一个特殊的普通函数，因为它可以访问类的私有成员。因此 operator&lt;&lt; 和 operator>> 声明为友元函数的目的很明显，就是为了能够访问类的私有成员。
实际上，如果它们不声明为友元函数，也是可以实现的，例如下面代码：
class AClass { private: int _count; std::string _str; std::vector&lt;int> _vec; public: std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os) { os &lt;&lt; "AClass: count = " &lt;&lt; _count &lt;&lt; ", str = " &lt;&lt; _str &lt;&lt; ", vec size = " &lt;&lt; _vec.size(); return os; } }; 但是这样就需要特殊的方法来调用这个 operator&lt;&lt; 函数，因为它不再是一个普通函数，而是一个类成员函数：
int main() { AClass a; a &lt;&lt; std::cout; // 错误，不能这样调用 a.operator&lt;&lt;(std::cout); // 正确 return 0; } 这样显然不够直观，不是一个正常人类写的代码：）
所以，为了代码的可读性和可维护性，我们将 operator&lt;&lt; 和 operator>> 声明为友元函数，这样就可以直接使用 &lt;&lt; 和 >> 运算符来操作类的对象了。
...</p></div><footer class=entry-footer><span title='2024-06-25 21:35:40 +0800 +0800'>2024年06月25日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to C++ 类的流插入和流提取运算符为什么要声明为友元函数" href=https://blog.cassdev.com/posts/c++-%E7%B1%BB%E7%9A%84%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Socket 编程之 IO 多路复用学习笔记</h2></header><div class=entry-content><p>什么是 IO 多路复用？阻塞 IO 与 非阻塞 IO我们先了解一下阻塞 IO，阻塞 IO 是指应用程序在读写数据时，如果没有数据可读或者写，应用程序会一直 阻塞在那里 ，直到有数据可读或者写。
与它相反的是非阻塞 IO，是指应用程序在读写数据时，无论是否有数据可读写，都 立即返回 ，若没有数据可读写将会返回一个错误码，通过不断轮询来检查是否有数据可读或者写。
IO 多路复用由于 Scoket 默认是阻塞 IO，所以很多初学者在处理多个连接时，会为每个连接创建一个线程来处理，但这样做会引起 CPU 的上下文切换，降低系统的性能。
有一种更“优雅”的方式，那就是 IO 多路复用，也称为事件驱动模型（Event-driven IO）。IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 事件已经就绪，就通知该进程。IO 多路复用模型中，只需要一个线程就可以同时处理多个连接。
通俗易懂的说，IO 多路复用就是将多个 IO 事件交给内核，内核帮我们监听这些 IO 事件，当有 IO 事件就绪时，内核会通知我们，我们只需要处理就绪的 IO 事件即可。
IO 多路复用的优点 一个线程可以同时处理多个连接，减少线程的创建和销毁
降低了系统开销，提高了系统的并发性能
IO 多路复用的实现方式 select
poll
epoll (Linux)
kqueue (FreeBSD)
IOCP（Windows）
其中 epoll 是 Linux 下的 IO 多路复用机制，kqueue 是 FreeBSD（macOS 就属于 FreeBSD）下的 IO 多路复用机制。
下面的伪代码是 IO 多路复用的最基本实现方式：
...</p></div><footer class=entry-footer><span title='2024-06-24 21:36:55 +0800 +0800'>2024年06月24日</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Socket 编程之 IO 多路复用学习笔记" href=https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>搭建自动化部署的 GitHub.io 个人静态博客指南</h2></header><div class=entry-content><p>本文章主要介绍如何使用 GitHub Actions 实现基于 MkDocs 的 GitHub.io 个人静态博客的自动化部署。
本指南主要分为以下几个部分：
创建 GitHub 仓库 创建 MkDocs 项目 配置 GitHub Actions 部署到 GitHub Pages 创建 GitHub 仓库由于我们的博客是托管在 GitHub io 上的，所以我们需要一个 GitHub 仓库来存放我们的 MkDocs 博客。
创建仓库首先，我们需要在 GitHub 上创建一个新的仓库，仓库名可以是 &lt;username>.github.io，其中 &lt;username> 是你的 GitHub 用户名。
克隆仓库然后，我们需要将这个仓库克隆到本地：
git clone &lt;repository-url> cd &lt;repository-name> 创建 MkDocs 项目安装 MkDocsMkDocs 是一个 Python 项目使用 pip 安装：
pip install mkdocs 我们需要创建一个 MkDocs 项目，可以使用 MkDocs 官方提供的模板来创建。直接在仓库根目录执行以下命令即可：
mkdocs new . 然后，我们需要安装 MkDocs Material 主题。当然我们也可以选择其他主题，可以在 MkDocs 的 WiKi 查看更多主题。
...</p></div><footer class=entry-footer><span title='2024-06-17 21:11:04 +0800 +0800'>2024年06月17日</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 搭建自动化部署的 GitHub.io 个人静态博客指南" href=https://blog.cassdev.com/posts/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%9A%84-github.io-%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Windows Socket API 和 Linux Socket API</h2></header><div class=entry-content><p>本文章主要介绍 Windows 下和 Linux 下的 Socket 编程区别，即 Windows Socket API 和 Linux Socket API 的区别。
头文件Windows 环境下的 Socket 编程需要以下头文件:
&lt;WinSock2.h> &lt;WS2tcpip.h> 笔记 如果使用 MSVC 编译器，那么还需要使用预处理指令 #pragma comment(lib, "Ws2_32.lib") 来链接 Ws2_32.lib 库。
...</p></div><footer class=entry-footer><span title='2024-06-16 19:13:10 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Windows Socket API 和 Linux Socket API" href=https://blog.cassdev.com/posts/windows-socket-api-%E5%92%8C-linux-socket-api/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Windows VSCode 使用 JetBrians Mono 字体</h2></header><div class=entry-content><p>本文主要介绍如何在 Windows 系统下的 Visual Studio Code 中使用 JetBrians Mono 字体。
下载字体可能你跟着网上很多教程一样，一上来就在 VS Code 中设置字体，结果发现设置不生效，这是因为你没有安装 JetBrians Mono 字体。
JetBrians Mono 字体下载地址：JetBrainsMono
安装字体下载字体后，解压缩，进入 ttf 文件夹，找到 JetBrainsMono-Regular.ttf 文件，双击打开，点击安装即可。当然你也可以全部字体都安装 :)
设置 VS Code打开 VS Code 的设置，搜索 editor.fontFamily，将其值设置为 JetBrains Mono，如下图所示：
重启 VS Code最后一步，重启 VS Code 即可。</p></div><footer class=entry-footer><span title='2024-06-16 19:13:10 +0800 +0800'>2024年06月16日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Windows VSCode 使用 JetBrians Mono 字体" href=https://blog.cassdev.com/posts/windows-vscode-%E4%BD%BF%E7%94%A8-jetbrians-mono-%E5%AD%97%E4%BD%93/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.cassdev.com/>«&nbsp;上一页&nbsp;1/8
</a><a class=next href=https://blog.cassdev.com/page/3/>下一页&nbsp;3/8&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>