[{"content":"systemd 是现代 Linux 发行版中广泛使用的初始化系统和服务管理器。它不仅提供了强大的功能来管理系统服务，还允许用户轻松地配置和管理自启动服务。\nsystemd 中的字母 d 表示 （daemon）守护进程，相信学过操作系统的同学都知道守护进程是指在后台运行的进程。\nsystemd 作为守护进程管理器，负责启动、停止和管理系统中的各种服务。\nsystemd 操作命令systemctlsystemctl（system control）是 systemd 的主要命令行工具。它用于检查和控制 systemd 系统和服务管理器的状态。\n刷新配置文件\nsudo systemctl daemon-reload 但你修改了服务的配置文件后，需要运行这个命令来让 systemd 重新加载配置文件。否则 systemd 不会识别你的更改。\n启动服务\nsudo systemctl start \u0026lt;service_name\u0026gt; 这个命令用于启动指定的服务，当系统重启后，服务不会自动启动。\n停止服务\nsudo systemctl stop \u0026lt;service_name\u0026gt; 这个命令用于停止指定的服务。\n重启服务\nsudo systemctl restart \u0026lt;service_name\u0026gt; 这个命令用于重启指定的服务。\n重新加载服务配置\nsudo systemctl reload \u0026lt;service_name\u0026gt; 这个命令用于重新加载指定服务的配置，而不停止服务。它与 restart 的区别在于，reload 不会中断服务的运行，适用于支持热加载配置的服务。\n查看服务状态\nsudo systemctl status \u0026lt;service_name\u0026gt; 这个命令用于查看指定服务的当前状态。\n启用服务自启动\nsudo systemctl enable \u0026lt;service_name\u0026gt; 这个命令用于使指定的服务在系统启动时自动启动。但是不会立即启动服务，如果想立即启动服务，可以加上 --now 选项： sudo systemctl enable --now \u0026lt;service_name\u0026gt;\n禁用服务自启动\nsudo systemctl disable \u0026lt;service_name\u0026gt; 这个命令用于禁止指定的服务在系统启动时自动启动。\n查询服务是否启用自启动\nsudo systemctl is-enabled \u0026lt;service_name\u0026gt; 这个命令用于检查指定的服务是否设置为自启动。\n注销服务\nsudo systemctl mask \u0026lt;service_name\u0026gt; 这个命令用于禁止指定的服务被启动，包括手动启动和自动启动。应用场景如：某些服务存在安全隐患时，可以使用该命令彻底禁止其运行。\n取消注销服务\nsudo systemctl unmask \u0026lt;service_name\u0026gt; 这个命令用于取消对指定服务的禁止启动设置。\n查看所有正在运行的服务\nsudo systemctl list-units --type=service --state=running 这个命令用于列出所有当前正在运行的服务。\njournalctljournalctl 是 systemd 的日志查看工具。它用于查看和管理由 systemd 记录的日志信息。\n查看指定服务的日志\nsudo journalctl -u \u0026lt;service_name\u0026gt; 加上 -f 参数可以实时查看日志输出。\n如果你也不想输入 journalctl 这么长的命令，可以用下面 bash 函数简化：\nsrvlog() { sudo journalctl -u \u0026#34;$@\u0026#34; } 我使用 srvlog \u0026lt;service_name\u0026gt; 来查看服务日志，这里使用了 $@，表示传递给函数的所有参数，所以 -f 等参数也可以传递进去。当然你也可以把 srvlog 改成你喜欢的名字。\nsystemd-analyzesystemd-analyze 是 systemd 的性能分析工具。它用于分析系统启动时间和服务启动时间。\n查看系统启动时间\nsystemd-analyze 这个命令显示系统启动所花费的总时间以及内核、initrd 和用户空间的时间。\n查看各个服务的启动时间\nsystemd-analyze blame 这个命令列出所有服务及其启动时间，按时间长短排序，帮助识别启动缓慢的服务。\n查看启动过程的可视化图表\nsystemd-analyze plot \u0026gt; boot.svg 这个命令生成一个 SVG 文件，显示系统启动过程的可视化图表，便于分析启动过程中的瓶颈。\n服务配置文件systemd 的服务配置文件通常位于 /etc/systemd/system/ 或 /lib/systemd/system/ 目录下，文件扩展名为 .service。这些文件定义了服务的启动方式、依赖关系等信息。\n一个简单的服务配置文件示例如下：\n[Unit] Description=My Custom Service After=network.target [Service] ExecStart=/usr/bin/my_custom_service Restart=always [Install] WantedBy=multi-user.target 服务配置文件参数配置文件通常分为三个区块：\n[Unit]：描述服务的元数据和依赖关系（启动顺序）。 [Service]：核心区块，描述如何启动、停止、重启以及运行时的环境。 [Install]：描述如何“安装”这个服务（即 systemctl enable 时挂载到哪个目标）。 以下是常用的参数详解：\n[Unit] 区块（依赖与顺序）这一块决定了服务“什么时候”启动。\n参数名 意思 说明 Description 描述 systemctl status 时显示的文本，可写可不写，给自己看的。 Documentation 文档链接 可选，http 链接或 man 页面。 After 在谁之后启动 仅控制启动顺序，不代表强依赖。例如 After=network.target 表示网络栈初始化后再启动我。 Before 在谁之前启动 仅控制启动顺序，不代表强依赖。 Requires 强依赖 如果这里列出的服务启动失败，那么我也不会启动；如果它中途停了，我也会被停止。 Wants 弱依赖 我“想要”它启动，但如果它启动失败了，并不影响我继续运行。最常用的依赖方式。 [Service] 区块这是你最关心的部分，决定了服务怎么跑、挂了怎么救。\n参数名 意思与常见值 说明 Type 启动类型 simple: （默认）启动的主进程就是服务本身（适合绝大多数程序）。 forking: 程序启动后会派生子进程并在后台运行（如 Nginx）。\noneshot: 执行一次就结束（适合运行脚本）。 ExecStart 启动命令 必须使用绝对路径（例如 /usr/bin/python3 而不是 python3）。 ExecStop 停止命令 Systemd 默认会发 SIGTERM 信号杀进程。如果你需要执行特定的清理命令或脚本，可以在这里定义。 ExecReload 重载命令 执行 systemctl reload 时运行的命令。 ExecStartPre 启动前执行 在 ExecStart 之前运行。常用于清理环境、检查配置或数据库迁移。 Restart 重启策略 no: （默认）退出后不重启。\nalways: 无论怎么退出，总是重启（适合守护进程）。\non-failure: 只有非正常退出（退出码非0）才重启。 生产环境常用 on-failure 或 always。 RestartSec 重启间隔 挂掉后等待多久再尝试重启。例如 5s。防止进程疯狂闪退导致 CPU 飙升。 User / Group 运行用户/组 默认是 root。 WorkingDirectory 工作目录 进程启动时的当前目录。对于 docker-compose 很重要，因为它要找当前目录下的 .yml 文件。 Environment 环境变量 设置环境变量，如 Environment=\u0026quot;ENV=production\u0026quot;。 EnvironmentFile 环境变量文件 从文件中读取环境变量（类似 .env），如 EnvironmentFile=/etc/default/myapp。 TimeoutStartSec 启动超时时间 如果服务启动太慢，超过这个时间 Systemd 会杀掉它。默认 90s。如果是初始化很慢的服务），可以设为 0 (无限) 或更大值。 笔记 Service.Type 的区别\n主要在于 systemd 如何判断服务已经启动成功：\nsimple：systemd 认为服务一启动就成功。 forking：systemd 认为当主进程派生出子进程后，服务就成功启动了。 oneshot：systemd 认为当程序执行完毕并返回时，服务就成功启动了。 [Install] 区块这一块决定了 systemctl enable 的行为。\n参数名 意思 说明 WantedBy 挂载目标 通常填 multi-user.target。意思是“当系统进入多用户模式（正常启动后的状态）时，请启动我”。 Alias 别名 给服务起个别名，比如 systemctl start myapp 也可以用 systemctl start shortname。 service 示例下面是一个完整的 systemd 服务配置文件示例，假设我们需要开机自启动一个 Docker Compose 管理的服务：\n直接创建文件 vim /etc/systemd/system/example.service，内容如下：\n[Unit] Description= My Example Service # 强依赖 docker 服务 Requires=docker.service # 弱依赖 nginx 服务 Wants=nginx.service [Service] Type=simple WorkingDirectory=/root/dev-service/example-service # 启动前先停止 ExecStartPre=/usr/bin/docker-compose down # 启动命令 ExecStart=/usr/bin/docker-compose up # 停止命令 ExecStop=/usr/bin/docker-compose down # 无论如何都重启 Restart=always # 重启间隔 5 秒 RestartSec=5s [Install] # 挂载到多用户目标 WantedBy=multi-user.target 配置好服务文件后，执行以下命令使其生效：\nsudo systemctl daemon-reload sudo systemctl enable --now example 这样，每次系统启动时，example 服务都会自动启动。查看日志的话可以使用 sudo journalctl -u example -f。\n","permalink":"https://blog.cassdev.com/posts/%E4%BD%BF%E7%94%A8-systemd-%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/","summary":"\u003cp\u003esystemd 是现代 Linux 发行版中广泛使用的初始化系统和服务管理器。它不仅提供了强大的功能来管理系统服务，还允许用户轻松地配置和管理自启动服务。\u003c/p\u003e\n\u003cp\u003esystemd 中的字母 d 表示 \u003cstrong\u003e（daemon）守护进程\u003c/strong\u003e，相信学过操作系统的同学都知道守护进程是指在后台运行的进程。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003esystemd 作为守护进程管理器，负责启动、停止和管理系统中的各种服务。\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"systemd-操作命令\"\u003esystemd 操作命令\u003c/h2\u003e\u003ch3 id=\"systemctl\"\u003esystemctl\u003c/h3\u003e\u003cp\u003esystemctl（system control）是 systemd 的主要命令行工具。它用于检查和控制 systemd 系统和服务管理器的状态。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e刷新配置文件\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e但你修改了服务的配置文件后，需要运行这个命令来让 systemd 重新加载配置文件。否则 systemd 不会识别你的更改。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e启动服务\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo systemctl start \u0026lt;service_name\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个命令用于启动指定的服务，当系统重启后，服务不会自动启动。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e停止服务\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo systemctl stop \u0026lt;service_name\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个命令用于停止指定的服务。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e重启服务\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo systemctl restart \u0026lt;service_name\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个命令用于重启指定的服务。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e重新加载服务配置\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo systemctl reload \u0026lt;service_name\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个命令用于重新加载指定服务的配置，而不停止服务。它与 \u003ccode\u003erestart\u003c/code\u003e 的区别在于，\u003ccode\u003ereload\u003c/code\u003e 不会中断服务的运行，适用于支持热加载配置的服务。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e查看服务状态\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo systemctl status \u0026lt;service_name\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个命令用于查看指定服务的当前状态。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e启用服务自启动\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo systemctl \u003cspan class=\"nb\"\u003eenable\u003c/span\u003e \u0026lt;service_name\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个命令用于使指定的服务在系统启动时自动启动。但是不会立即启动服务，如果想立即启动服务，可以加上 \u003ccode\u003e--now\u003c/code\u003e 选项： \u003ccode\u003esudo systemctl enable --now \u0026lt;service_name\u0026gt;\u003c/code\u003e\u003c/p\u003e","title":"使用 systemd 优雅的管理自启动服务"},{"content":"使用 Certbot 申请泛域名证书并不复杂，几个月前搞过，但是又忘了，今天重新搞了一遍，记录一下步骤。\n前提条件 你需要有一个域名，并且可以管理该域名的 DNS 记录。 一般我们都是在 阿里云 或 火山引擎 等云服务商购买的域名，这里以阿里云为例。\n申请泛域名证书安装 Certbot先用 certbot --version 检查是否已经安装 Certbot，如果没有安装，下面一句话安装一下：\nsudo apt install certbot -y 申请证书泛域名证书需要通过 DNS-01 验证域名所有权，使用以下命令申请，注意将 *.cassdev.com 和 cassdev.com 替换为你的域名，example@google.com 替换为你的邮箱。\n笔记 什么是 DNS-01 验证？\nDNS-01 验证是通过在域名的 DNS 记录中添加一个特定的 TXT 记录来证明你对该域名的所有权。Certbot 会生成这个 TXT 记录的值，你需要将其添加到你的 DNS 提供商的管理控制台中。N\n为什么需要验证？\n这是为了确保只有域名的合法所有者才能申请和使用该域名的 SSL/TLS 证书，从而防止恶意用户冒充域名所有者获取证书。\ncertbot certonly --manual --preferred-challenges dns -d \u0026#34;*.cassdev.com\u0026#34; -d \u0026#34;cassdev.com\u0026#34; --email example@google.com --agree-tos 命令执行后会返回一个字符串，先别急着回车，需要先将该字符串添加到你的域名的 DNS 记录中。\n添加 DNS 记录去到域名控制台，找到 DNS 解析，添加一个 TXT 记录， 将上一步返回的字符串复制到 TXT 记录的值中，主机记录填写 _acme-challenge。\n阿里云的用户请点击跳转：阿里云云解析 DNS\n等待 DNS 记录生效如命令返回的提示所言，添加完 TXT 记录后，需要等待一段时间让 DNS 记录生效。\n我们可以访问 https://toolbox.googleapps.com/apps/dig/#TXT/_acme-challenge.yourdomain.com 来检查你的域名的 acme-challenge TXT 记录是否生效。\n注意将 yourdomain.com 替换为你的域名。\n记录生效后，回到命令行按回车继续。成功的话可以看到如下提示：\n查找证书文件证书文件默认存放在 /etc/letsencrypt/live/yourdomain.com/ 目录下，里面包含以下文件：\nfullchain.pem：包含服务器证书和中间证书的文件，通常用于配置服务器。 privkey.pem：私钥文件，必须妥善保管，不能泄露给他人。 至此，泛域名 SSL 证书申请完成，可以在服务器上配置使用了。\n证书续期泛域名证书的过期时间为 90 天，不过 Certbot 提供了自动续期功能，可以通过以下命令手动续期：\ncertbot renew 我相信没人想每三个月手动续期一次，所以建议使用 cron 定时任务来自动续期证书。\n编辑 crontab 文件：\ncrontab -e 添加以下内容，每三个月的第一天凌晨 3 点执行续期命令，续期成功后重载 Nginx 配置：\n0 3 1 */3 * certbot renew --quiet --post-hook \u0026#34;nginx -s reload\u0026#34; 简单解释一下这个 cron 表达式：\n分 时 日 月 周 命令 0 3 1 */3 * certbot renew \u0026ndash;quiet \u0026ndash;post-hook \u0026ldquo;nginx -s reload\u0026rdquo; Nginx 使用泛域名证书示例下面是一个 Nginx 配置示例，假设你的泛域名是 *.cassdev.com，你想为子域名 abcd.cassdev.com 配置 SSL：\nserver { listen 443 ssl http2; listen [::]:443 ssl http2; server_name abcd.cassdev.com; # SSL 证书路径 ssl_certificate /etc/letsencrypt/live/cassdev.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/cassdev.com/privkey.pem; # 前端静态文件根目录 (请修改为您的实际路径) root /var/www/abcd.cassdev.com; index index.html; location / { try_files $uri $uri/ /index.html; } # 您可以添加其他配置，例如日志、gzip压缩等 access_log /var/log/nginx/abcd.access.log; error_log /var/log/nginx/abcd.error.log; } ","permalink":"https://blog.cassdev.com/posts/%E4%BD%BF%E7%94%A8-certbot-%E7%94%B3%E8%AF%B7%E6%B3%9B%E5%9F%9F%E5%90%8D-ssl-%E8%AF%81%E4%B9%A6%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e使用 Certbot 申请泛域名证书并不复杂，几个月前搞过，但是又忘了，今天重新搞了一遍，记录一下步骤。\u003c/p\u003e\n\u003ch2 id=\"前提条件\"\u003e前提条件\u003c/h2\u003e\u003col\u003e\n\u003cli\u003e你需要有一个域名，并且可以管理该域名的 DNS 记录。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e一般我们都是在 \u003cem\u003e阿里云\u003c/em\u003e 或 \u003cem\u003e火山引擎\u003c/em\u003e 等云服务商购买的域名，这里以阿里云为例。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"申请泛域名证书\"\u003e申请泛域名证书\u003c/h2\u003e\u003ch3 id=\"安装-certbot\"\u003e安装 Certbot\u003c/h3\u003e\u003cp\u003e先用 \u003ccode\u003ecertbot --version\u003c/code\u003e 检查是否已经安装 Certbot，如果没有安装，下面一句话安装一下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install certbot -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"申请证书\"\u003e申请证书\u003c/h3\u003e\u003cp\u003e泛域名证书需要通过 DNS-01 验证域名所有权，使用以下命令申请，注意将 \u003ccode\u003e*.cassdev.com\u003c/code\u003e 和 \u003ccode\u003ecassdev.com\u003c/code\u003e 替换为你的域名，\u003ccode\u003eexample@google.com\u003c/code\u003e 替换为你的邮箱。\u003c/p\u003e\n\n    \u003cdiv class=\"admonition note\"\u003e\n      \u003cdiv class=\"admonition-header\"\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 576 512\"\u003e\u003cpath d=\"M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 125.7-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9 0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6 0zM311.9 417L441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z\"/\u003e\u003c/svg\u003e\n        \u003cspan\u003e笔记\u003c/span\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"admonition-content\"\u003e\n        \u003cp\u003e\u003cstrong\u003e什么是 DNS-01 验证？\u003c/strong\u003e\u003c/p\u003e","title":"使用 Certbot 申请泛域名 SSL 证书指南"},{"content":"大家在使用 LLM 生成内容时，不知道有没有注意到 LLM 的一些可配置参数，比如 Temperature 和 Top-p，是否关注过这些参数的作用？\n无论是在 OpenAI 的 API 文档、Google 的 AI Studio、以及各种的 AI 平台，你都能看到它的身影。\n什么是 Temperature 和 Top-p？在与 LLM 聊天时，大家可能已经注意到，有的 Agent 十分有创造力，有的 Agent 又十分严谨。这其中除了 Prompt 的影响外，还有一个重要的因素就是 LLM 的采样参数，包括 Temperature 和 Top-p。\n提示 TL;DR\n二者都是用于控制 LLM 生成内容随机性的参数。它们就像旋钮，通过调节它们来决定 LLM 输出的“保守”程度或“冒险”程度。\ntemperature 通过调整 token 生成的概率分布来控制输出的随机性 top_p 通过限制 LLM 考虑的 token 范围来控制输出的随机性 一个简单的例子为了更好地理解 temperature 和 top_p 如何影响概率，让我们想象一个场景：\n假设 LLM 正在生成一句话：“我想吃___。”，下面是 LLM 待选的 token 列表：\n水果 (60%) 零食 (20%) 饺子 (10%) \u0026hellip; 大蒜 (0.01%) 螺丝 (0.001%) 汽油 (0.0001%) Temperature: 在默认情况下（temperature=1），LLM 很可能会选择“水果”或“零食”。但如果我们提高 temperature -\u0026gt; 1.7，那些低概率的选项，如“大蒜”或“螺丝”，被选中的可能性就会增加，从而让句子变得出人意料。反之，如果我们降低 temperature -\u0026gt; 0.2，LLM 几乎只会选择“水果”，输出会更为确定。\nTop-p: 默认 top_p=1 时，LLM 会考虑所有 token 的概率分布，也就是说 LLM 存在选择“汽油”或“螺丝”的可能性。但如果我们设置 top_p=0.85，LLM 只会考虑累计概率达到 85% 的最小 token 集合，也就是“水果”+“零食”+“饺子”=90% \u0026gt;= 85%，这样 LLM 就只会在这三个选项中进行选择，输出更加符合常理。\nTransformer 的 Linear 层和 Softmax 层 在介绍 temperature 和 top_p 的工作原理前，我们需要简单了解一下 Transformer 模型（大多数现代 LLM 的基础架构）的内部机制。\n想必大家都见过这张 Transformer 的架构图，它自 LLM 的开山鼻祖论文 Attention Is All You Need。可以看到在架构图的输出端最后接了一个 Linear 层和 Softmax 层，这就是模型生成每个词的概率分布的地方。\nLinear 层解码器的输出会经过 Linear 层，由 Linear 层将 LLM 的内部表示翻译每个 token 的原始分数，称为 Logits。每个 logit 值代表了 LLM 对于相应 token 是句子中下一个正确 token 的置信度（该词作为下一个词的“合理性”）。该层有效地将模型内部的、抽象的语义表征“翻译”为在整个 token 词汇表上的具体预测。\nSoftmax 层Softmax 主要是将 Linear 层输出的 logits 转换为一个概率分布。这一转换过程分为两个步骤：\n指数化：对每个 logit 应用指数函数，得到一个非负值。 归一化：将所有指数化后的值进行归一化处理，使得它们的总和为 1，从而形成一个概率分布。 Softmax 的具体数学模型如下：\n$$ P(token_i) = softmax(logit_i) = \\frac{e^{logit_i}}{\\sum_{j} e^{logit_j}} $$\n其中：\n$P(token_i)$ 是第 $i$ 个词的最终概率。 $logit_i$ 是第 $i$ 个词的原始分数。 笔记 插曲：Softmax 为什么叫 Softmax？\n除了 Softmax 函数，还有一种叫 Hardmax 的函数。\nHardmax（严格 argmax）：会将最大元素对应位置输出 1，其它位置输出 0； Softmax（平滑 argmax）：最大元素会获得更高但不绝对的概率，其它元素也会有一定概率。 所以 Softmax 的意思是“平滑的最大化参数”，它允许模型在生成时考虑多个可能的选项，而不是仅仅选择一个最可能的选项。\n只有使用 Softmax 函数，才能将原始分数转换为概率分布。而 Hardmax 函数则会将最大分数对应的词的概率设为 1，其它词的概率设为 0，这样就没有随机性了。\nTemperature 和 Top-p 的工作原理Temperature 的工作原理现在我们了解了 Logits 是什么，以及 Softmax 函数的作用。那么就可以来看看 temperature 是起作用的了。\n从上面的例子中了解到 temperature 参数影响着概率分布的平滑程度。它的实现方式就是对 logits 进行缩放。引入 temperature 参数后，Softmax 函数的公式变为：\n$$ P(token_i) = softmax(\\frac{logit_i}{T}) $$\n其中 $T$ 是 temperature 参数。\nSoftmax 函数能够反映出 logits 的差异程度。而 logits 除以 temperature 后，由于除法的特性，若 $T \u0026lt; 1$，则会放大 logits 的差异，使得高分词的概率更高，低分词的概率更低；若 $T \u0026gt; 1$，则会缩小 logits 的差异，使得低分词的概率被提升。\n笔记 Temperature 的范围是 (0, 2]\n所以这就能看出为什么 temperature 值大小范围是在 (0, 2] 之间，因为使用的是除法，只有当 T 小于 1 时，才会使得高分词的概率更高，而当 T 大于 1 时，低分词的概率才会被提升。但又不能让 T 无限制增大，否则就会导致输出完全随机，LLM 也就失去了意义。\nTop-p 的工作原理top_p 的实现方式显而易见了，分为以下几个步骤：\n排序：将所有 token 按照概率从高到低排序。 累加：从概率最高的 token 开始，逐个累加它们的概率，直到累计概率大于等于 top_p 的值。 截断：只保留那些累计概率在 top_p 范围内的 token（包括最后一个超过 top_p 的 token）。 重新归一化：对保留的 token 的概率进行归一化处理，使它们的总和为 1。 Temperature 和 Top-p 设置参考不同的任务需要不同的创造力 or 保守程度。以下是一些常见的 temperature 和 top_p 设置建议：\n用例 Temperature Top-p 描述 代码生成 0.2 0.1 生成符合既定模式和约定的代码。输出更具确定性和针对性。有助于生成语法正确的代码。 创意写作 0.7 0.8 生成富有创意且多样化的叙事文本。输出更具探索性，且不受模式限制。 聊天机器人回复 0.5 0.5 生成兼顾连贯性和多样性的对话回复。输出结果更加自然、引人入胜。 代码注释生成 0.3 0.2 生成更简洁、更相关的代码注释。输出更具确定性，并符合规范。 数据分析脚本 0.2 0.1 生成更准确、更高效的数据分析脚本。输出结果更具确定性和针对性。 表格参考自 Cheat Sheet: Mastering Temperature and Top-p in ChatGPT API\n二者的执行顺序网络上很少关于 temperature 和 top_p 的执行顺序的资料。所以直接找到 Transformer 源码老家，看看具体实现。\n定位到 _get_logits_warper 函数，这个函数负责处理 logits 的变换，这里按顺序往一个 warper（TFLogitsProcessorList 的实例）中插入了 temperature、top_k 和 top_p 的处理器（TF***LogitsWarper）。\n接着看一下 TFLogitsProcessorList 这个类的方法，发现只有 __call__ 方法，也就是可以将该 warper 进行调用，具体逻辑是使用 for 循环按序调用每个处理器。\n所以，temperature 和 top_p 两个参数的应用顺序为：先应用 temperature，再应用 top_p。\n对业务的思考在实际业务中，作为 LLM 应用层开发者的我们不只有 All in Prompt Engineering 这条路来提升模型表现，也可以利用 temperature 这类采样参数进行精细化调控。像 LangChain、Eino 等框架，都提供了调整 temperature、top_p 等参数的能力（详见文档）。 在构建多 Agent 系统时，我们要对每个 Agent 的职责进行明确划分，并对其采样参数进行量身定制，做到控制 Agent 的输出风格和内容质量。\n其他常用参数 除了以上，大语言模型的 API 还提供了其他一些的参数：\nmax_tokens: 控制生成文本的最大长度（以 token 计）。这是一个非常实用的参数，可以用来防止模型生成过长的、不必要的文本，同时也能帮助控制 API 的成本。 高max_tokens：LLM 输出长度⬆︎ 低max_tokens：LLM 输出长度⬇︎ presence_penalty: 存在惩罚。通过对已经出现过的 token 施加惩罚，来鼓励模型引入新的话题和概念，降低重复性。数值越高，模型越倾向于谈论新内容。 高 presence_penalty（p -\u0026gt; 2）：多元化⬆︎，重复度⬇︎ 低 presence_penalty（p -\u0026gt; -2）：多元化⬇︎，重复度⬆︎ frequency_penalty: 频率惩罚。与存在惩罚类似，但它是根据 token 出现的频率来施加惩罚的。一个词出现的次数越多，受到的惩罚就越大，这能有效减少模型重复使用相同的词语。 高 presence_penalty（p -\u0026gt; 2）：多元化⬆︎，重复度⬇︎ 低 presence_penalty（p -\u0026gt; -2）：多元化⬇︎，重复度⬆︎ stop (或 stop_sequences): 指定一个或多个字符串序列。当模型生成这些序列时，会立即停止输出。这对于控制生成内容的结束点非常有用，比如在生成列表或对话时。 参考 https://www.mdrk.io/temperature-samplig-in-ai/ https://community.openai.com/t/cheat-sheet-mastering-temperature-and-top-p-in-chatgpt-api/172683 https://www.bilibili.com/video/BV1xmA2eMEFF/?spm_id_from=333.337.search-card.all.click\u0026amp;vd_source=77e39221f40d20651d3556c53a9c7622 ","permalink":"https://blog.cassdev.com/posts/llm-param-temeprature-and-top-p/","summary":"\u003cp\u003e大家在使用 LLM 生成内容时，不知道有没有注意到 LLM 的一些可配置参数，比如 Temperature 和 Top-p，是否关注过这些参数的作用？\u003c/p\u003e\n\u003cp\u003e无论是在 OpenAI 的 API 文档、Google 的 AI Studio、以及各种的 AI 平台，你都能看到它的身影。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"OpenAI Doc\" loading=\"lazy\" src=\"https://s2.loli.net/2025/07/22/ofLOVJnXuImeW3Z.png\"\u003e\n\u003cimg alt=\"Google AI Studio\" loading=\"lazy\" src=\"https://s2.loli.net/2025/07/22/1jlwDWpBJ6kxefu.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"什么是-temperature-和-top-p\"\u003e什么是 Temperature 和 Top-p？\u003c/h2\u003e\u003cp\u003e在与 LLM 聊天时，大家可能已经注意到，有的 Agent 十分有创造力，有的 Agent 又十分严谨。这其中除了 Prompt 的影响外，还有一个重要的因素就是 LLM 的\u003cstrong\u003e采样参数\u003c/strong\u003e，包括 Temperature 和 Top-p。\u003c/p\u003e\n\n    \u003cdiv class=\"admonition tip\"\u003e\n      \u003cdiv class=\"admonition-header\"\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\"\u003e\u003cpath d=\"M272 384c9.6-31.9 29.5-59.1 49.2-86.2c0 0 0 0 0 0c5.2-7.1 10.4-14.2 15.4-21.4c19.8-28.5 31.4-63 31.4-100.3C368 78.8 289.2 0 192 0S16 78.8 16 176c0 37.3 11.6 71.9 31.4 100.3c5 7.2 10.2 14.3 15.4 21.4c0 0 0 0 0 0c19.8 27.1 39.7 54.4 49.2 86.2l160 0zM192 512c44.2 0 80-35.8 80-80l0-16-160 0 0 16c0 44.2 35.8 80 80 80zM112 176c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-61.9 50.1-112 112-112c8.8 0 16 7.2 16 16s-7.2 16-16 16c-44.2 0-80 35.8-80 80z\"/\u003e\u003c/svg\u003e\n        \u003cspan\u003e提示\u003c/span\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"admonition-content\"\u003e\n        \u003cp\u003e\u003cstrong\u003eTL;DR\u003c/strong\u003e\u003c/p\u003e","title":"LLM 参数之 Temperature 和 Top-p"},{"content":"如果想让 LLM 输出 JSON 格式的内容，大家第一反应会是什么？可能大多数人和我一样，直接在提示词中写上\u0026quot;请输出 JSON 格式的内容，格式为 { \u0026ldquo;key\u0026rdquo;: \u0026ldquo;value\u0026rdquo; }\u0026quot;。但其实，这种方式并不是最优的。\n从之前我们也了解到了，LLM 的输出是一个概率性的文本补全器。单纯依靠提示词工程来控制 LLM 的输出格式并不可靠。用自然语言去描述一个复杂的 JSON 结构本就不易，再加上当提示词很长时，LLM 的注意力可能会分散，这些因素都容易导致它输出不符合预期的格式，甚至根本不输出 JSON。\n具体来说，这种方式可能会遇到以下三个主要问题：\n混入无关文本：模型可能在 JSON 对象前后添加对话式的\u0026quot;口水话\u0026quot;，如\u0026quot;好的，这是您要的 JSON：\u0026hellip;\u0026quot;，这给后续的程序化解析带来了困难。\n结构性错误：生成的 JSON 可能存在语法错误，例如缺少逗号、括号不匹配或引号使用不当，导致解析失败。\n内容幻觉：模型可能\u0026quot;幻觉\u0026quot;出指令中未要求的字段，或遗漏必要的字段，破坏了数据模式的一致性。\n让 LLM 生成符合预期的 JSON 格式内容的最佳实践是使用 response_format 参数，在程序算法的层面上去干预 LLM 的输出格式。这个参数允许我们让 LLM 进行结构化内容输出，确保 LLM 生成的内容符合预期的结构和语法。\nResponse Format 参数response_format 参数在绝大多数现代 LLM API 中都可用，允许开发者指定模型输出的格式。\nDeepSeek API Response Format\nOpenAI API Response Format\nDouBao API Response Format\n通过这个参数，我们可以明确要求 LLM 生成特定格式的内容，如 JSON 对象、纯文本或符合 JSON Schema 的数据结构。\nresponse_format 参数支持以下三个模式：\n模式 描述 备注 text 生成纯文本内容。适用于需要自然语言回复的场景。 默认模式，不会对输出格式进行约束。 json_object 生成 JSON 对象。适用于需要结构化数据的场景。 早期的 JSON 模式，只能保证输出为 JSON 格式，但不能 JSON 结构符合预期 json_schema 生成符合指定 JSON Schema 的 JSON 对象。适用于需要严格数据格式的场景。 结构化输出模式，这是官方推荐的模式，可以确保输出的 JSON 符合预定义的结构和类型约束。 使用 json_schema 模式时，需编写符合 JSON Schema 规范的模式定义，点击即刻学习 JSON Schema :)\njson_object 和 json_schema 的差别，前者会能够保证输出为 JSON 格式，但具体字段和类型需要通过 Prompt 来引导。后者则可以通过 JSON Schema 来定义输出 JSON 的结构和类型，Prompt 只需要关注任务本身，而不需要关心格式。\n工作原理我们都知道，Transformer 是大多数现代 LLM 的基础架构。但 response_format 参数并不作用于 Transformer 模型的内部，而是在其生成流程中加入了一个约束步骤。这个约束步骤发生在 Transformer 的 Linear 层之后、Softmax 层之前。\n下面是 Transformer 生成每个词（token）的过程：\nLinear 层 → Logits 原始分数 → Softmax 层 → 概率 -\u0026gt; token 采样 -\u0026gt; 输出 在 Transformer 生成每个词（token）的过程中，LLM 首先通过 Linear 层计算出每个可能词的原始分数（logits），然后通过 Softmax 层将这些分数转换为概率分布。接下来，LLM 会根据这个概率分布进行随机采样。\n如果使用了 response_format 参数，LLM 会对 Logits 原始分数进行一轮处理，这个过程交给了 LogitsProcessor 来完成。加上 LogitsProcessor 后，Transformer 的生成流程变为：\nLinear 层 → Logits 原始分数 → Logits 处理器 -\u0026gt; 处理后的 Logits 分数 → Softmax 层 → 概率 -\u0026gt; token 采样 -\u0026gt; 输出 在约束生成算法的实现上，主要使用两种类型的语法：\n正则表达式（Regular Expression）：用于定义输出内容必须遵循的字符模式。通过正则表达式，我们可以精确描述诸如 JSON 对象结构等复杂格式要求。 BNF（Backus-Naur Form）：这是一种标准的上下文无关文法表示法，广泛应用于编程语言语法的精确定义，能够描述更复杂的层次化结构。 这里用大家更熟悉的正则表达式来举例说明，在应用了 response_format 参数后，LLM 输出 token 的过程如下：\nLogits 计算：Transformer 的 Linear 层为词汇表中的每个候选 token 计算出原始分数（logits）。 约束过滤：LogitsProcessor 根据预定义的正则表达式对这些分数进行筛选，将候选 token 分为两类：符合格式要求的\u0026quot;合法 token\u0026quot;和不符合要求的\u0026quot;非法 token\u0026quot;。 分数调整：LogitsProcessor 保持合法 token 的原始分数不变，但将所有非法 token 的分数设置为负无穷（-∞）。 概率归一化：Softmax 层处理调整后的分数。由于非法 token 的分数为 -∞，经过指数函数和归一化后，它们的概率会趋近于 0。 token 采样：采样器根据最终的概率分布选择输出，此时只有合法 token 具有非零概率，从而确保输出符合预期格式。 下图展示了使用 Response Format 参数后，LLM 生成 token 的流程：\n笔记 更多关于 Response Format 参数的细节，可以参考 OpenAI 的官方文档 OpenAI API Structured Outputs。\n使用示例在不使用 response_format 参数的情况下，我们可能会使用如下的 Prompt 去引导 LLM 生成符合特定格式的内容：\n# 角色 你是一位专业的数学题解答者，擅长解答各种数学问题，并能提供详细的解题步骤。 ## 任务 请解答以下数学题，并将答案以 JSON 格式返回，格式如下： { \u0026#34;answer\u0026#34;: \u0026#34;答案\u0026#34;, \u0026#34;steps\u0026#34;: [ { \u0026#34;explanation\u0026#34;: \u0026#34;该步骤的解释说明，描述该步骤的计算过程和逻辑\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;该步骤的计算方程式，只允许包含数字、运算符、等号和括号，不允许包含其他字符\u0026#34;, \u0026#34;operation\u0026#34;: \u0026#34;该步骤的数学运算类型，枚举值为 add, sub, mul, div, pow\u0026#34; } ] } ## 例子 ### Prompt \u0026#34;请解答以下数学题：10-(1^2 + 34) = ?\u0026#34; ### 你的回答 { \u0026#34;answer\u0026#34;: \u0026#34;-25\u0026#34;, \u0026#34;steps\u0026#34;: [ { \u0026#34;explanation\u0026#34;: \u0026#34;计算 1 的平方\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;1^2\u0026#34;, \u0026#34;operation\u0026#34;: \u0026#34;pow\u0026#34; }, { \u0026#34;explanation\u0026#34;: \u0026#34;计算 1^2 + 34\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;(1^2 + 34)\u0026#34;, \u0026#34;operation\u0026#34;: \u0026#34;add\u0026#34; } ] } ## 限制 1. 输出内容必须严格遵循 JSON 格式，不能包含任何多余的文本。 2. 生成的 JSON 对象必须包含 `answer` 和 `steps` 两个字段。 3. `steps` 字段必须是一个数组，包含解题的每个步骤。 4. 每个步骤必须包含 `explanation`、`output` 和 `operation` 三个字段。 5. `operation` 字段的值必须是 \u0026#34;add\u0026#34;、\u0026#34;sub\u0026#34;、\u0026#34;mul\u0026#34;、\u0026#34;div\u0026#34; 或 \u0026#34;pow\u0026#34; 中的一个。 6. `output` 字段的值只能包含数字、运算符、等号和括号，不允许包含其他字符。 在上下文较短时，上述提示词能够有效引导模型生成符合预期的 JSON 内容，足以应对聊天应用中的日常问答场景（比如作为 Chat 应用中的一个角色）。\n但在开发者视角上，在实际应用场景中，调用 API 时需要遵循最佳实践，使用 response_format 参数来确保 LLM 输出符合预定义的 JSON 结构。\n下面以 Go 语言为例，展示如何使用 OpenAI API 的 response_format 参数来生成符合 JSON Schema 的响应格式。\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/openai/openai-go\u0026#34; \u0026#34;github.com/openai/openai-go/option\u0026#34; ) const jsonSchema = ` { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;steps\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;explanation\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;该步骤的解释说明，描述该步骤的计算过程和逻辑\u0026#34; }, \u0026#34;output\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;该步骤的计算方程式，只允许包含数字、运算符、等号和括号，不允许包含其他字符\u0026#34; }, \u0026#34;operation\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;该步骤的数学运算类型\u0026#34;, \u0026#34;enum\u0026#34;: [\u0026#34;add\u0026#34;, \u0026#34;sub\u0026#34;, \u0026#34;mul\u0026#34;, \u0026#34;div\u0026#34;, \u0026#34;pow\u0026#34;] } }, \u0026#34;required\u0026#34;: [ \u0026#34;explanation\u0026#34;, \u0026#34;result\u0026#34;, \u0026#34;hard_level\u0026#34; ], \u0026#34;additionalProperties\u0026#34;: false } }, \u0026#34;answer\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;steps\u0026#34;, \u0026#34;answer\u0026#34; ], \u0026#34;additionalProperties\u0026#34;: false } ` func main() { var jsonSchemaMap map[string]any if err := json.Unmarshal([]byte(jsonSchema), \u0026amp;jsonSchemaMap); err != nil { fmt.Println(\u0026#34;Error parsing JSON schema:\u0026#34;, err) return } client := openai.NewClient( option.WithAPIKey(\u0026#34;\u0026lt;YOUR-API-KEY\u0026gt;\u0026#34;), ) prompt := \u0026#34;请解答以下数学题：10-(2^2 + 34) = ?\u0026#34; jsonSchema := openai.ResponseFormatJSONSchemaJSONSchemaParam{ Name: \u0026#34;answer_response\u0026#34;, Description: openai.String(\u0026#34;解答数学题的响应格式\u0026#34;), Schema: jsonSchemaMap, Strict: openai.Bool(true), } ctx := context.Background() response, err := client.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{ Model: \u0026#34;gpt-4o-mini\u0026#34;, Messages: []openai.ChatCompletionMessageParamUnion{ openai.SystemMessage(prompt), }, ResponseFormat: openai.ChatCompletionNewParamsResponseFormatUnion{ OfJSONSchema: \u0026amp;openai.ResponseFormatJSONSchemaParam{ JSONSchema: jsonSchema, }, }, }) if err != nil { fmt.Println(\u0026#34;Error:\u0026#34;, err) return } fmt.Println(response.Choices[0].Message.Content) } 可以看到我们的 Prompt 长度被大大缩短了，能够把 Prompt 聚焦在任务本身，而不是格式上。\n这里使用的是手写 JSON Schema 的方式来约束输出格式。对于 Python 语言，可以直接使用 pydantic 库来定义数据结构，能够自动生成 JSON Schema，具体参考 Structured Outputs。对于 Go 语言，可以使用 invopop/jsonschema 库来生成 JSON Schema。\n快速生成 JSON Schema笔者在摸索的过程中发现了 OpenAI 官方文档里有一个功能可以利用 GPT 快速生成 JSON Schema。只需要丢给 GPT 一个 JSON 示例，它就能自动生成对应的 JSON Schema。我们可以利用这个功能快速生成符合预期的 JSON Schema 初稿，然后在这基础上进行修改和完善。\n进入 OpenAI 官方文档的 Structured Outputs 页面，点击 \u0026ldquo;Generate\u0026rdquo; 按钮，然后粘贴上 JSON 示例，过一会就会在下面生成对应的 JSON Schema。\n参考 Guiding LLMs The Right Way: Fast, Non-Invasive Constrained Generation\nControlling your LLM: Deep dive into Constrained Generation\nOpenAI API Response Format\n结构化输出\n","permalink":"https://blog.cassdev.com/posts/llm-param-response-format/","summary":"\u003cp\u003e如果想让 LLM 输出 JSON 格式的内容，大家第一反应会是什么？可能大多数人和我一样，直接在提示词中写上\u0026quot;请输出 JSON 格式的内容，格式为 { \u0026ldquo;key\u0026rdquo;: \u0026ldquo;value\u0026rdquo; }\u0026quot;。但其实，这种方式并不是最优的。\u003c/p\u003e\n\u003cp\u003e从之前我们也了解到了，LLM 的输出是一个\u003cstrong\u003e概率性\u003c/strong\u003e的文本补全器。单纯依靠提示词工程来控制 LLM 的输出格式并不可靠。用自然语言去描述一个\u003cstrong\u003e复杂的 JSON 结构\u003c/strong\u003e本就不易，再加上当提示词很长时，LLM 的\u003cstrong\u003e注意力可能会分散\u003c/strong\u003e，这些因素都容易导致它输出不符合预期的格式，甚至根本不输出 JSON。\u003c/p\u003e\n\u003cp\u003e具体来说，这种方式可能会遇到以下三个主要问题：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e混入无关文本\u003c/strong\u003e：模型可能在 JSON 对象前后添加对话式的\u0026quot;口水话\u0026quot;，如\u0026quot;好的，这是您要的 JSON：\u0026hellip;\u0026quot;，这给后续的程序化解析带来了困难。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e结构性错误\u003c/strong\u003e：生成的 JSON 可能存在语法错误，例如缺少逗号、括号不匹配或引号使用不当，导致解析失败。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e内容幻觉\u003c/strong\u003e：模型可能\u0026quot;幻觉\u0026quot;出指令中未要求的字段，或遗漏必要的字段，破坏了数据模式的一致性。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e让 LLM 生成符合预期的 JSON 格式内容的最佳实践是使用 \u003ccode\u003eresponse_format\u003c/code\u003e 参数，在程序算法的层面上去干预 LLM 的输出格式。这个参数允许我们让 LLM 进行\u003cstrong\u003e结构化内容\u003c/strong\u003e输出，确保 LLM 生成的内容符合预期的结构和语法。\u003c/p\u003e\n\u003ch2 id=\"response-format-参数\"\u003eResponse Format 参数\u003c/h2\u003e\u003cp\u003e\u003ccode\u003eresponse_format\u003c/code\u003e 参数在绝大多数现代 LLM API 中都可用，允许开发者指定模型输出的格式。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://api-docs.deepseek.com/zh-cn/api/create-chat-completion#request\"\u003eDeepSeek API Response Format\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://platform.openai.com/docs/api-reference/chat/create#chat-create-response_format\"\u003eOpenAI API Response Format\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.volcengine.com/docs/82379/1494384\"\u003eDouBao API Response Format\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e通过这个参数，我们可以明确要求 LLM 生成特定格式的内容，如 JSON 对象、纯文本或符合 JSON Schema 的数据结构。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eresponse_format\u003c/code\u003e 参数支持以下三个模式：\u003c/p\u003e","title":"LLM 参数之 Response Format"},{"content":"1. 语法高亮简介语法高亮是指在IDE或编辑器中，对文本进行分词，即将文本拆解为 Token（标记），每个 Token 都有对应的名称（作用域）进行标记。再配合主题样式规则，对不同名称的 Token 的进行主题化，以提高代码的可读性。\n程序员离不开语法高亮，就像作家离不开标点符号一样。（你可以代入一下使用 txt 文本编辑器写代码的场景）\n语法高亮由两个部分组成：\n分词（Tokenization）：将文本拆解为一系列 Token。 主题化（Theming）：对 Token 进行样式渲染，如字体颜色、背景色、加粗等。 我们以 JSON 的语法为例，简单介绍一下语法高亮的过程。\n首先分词引擎会对 JSON 文本进行分词，下图是将 JSON 文本进行分词后的结果，其中每个矩形所包括的文本都是一个 Token，每个 Token 都有一个作用域名称，例如 null 对应的是 constant.language.json 作用域。\n然后主题化引擎会根据 Token 的作用域名称，对 Token 进行样式渲染，例如将 constant.language.json 作用域映射为蓝色不加粗字体。那么 null 就会被渲染为蓝色不加粗字体。\n2. 分词的实现方式目前主流的分词实现方式大致有有以下三种：\n基于正则表达式的分词：Textmate 基于词法分析的分词：Highlight.js 基于语法树的分词：Tree-sitter (如果有其他，欢迎补充) 本文只讨论 Textmate 的语法高亮规则编写。\nTextmate 原是 MacOS 下的一款文本编辑器，其语法高亮规则是基于正则表达式的，但由于其规则简单易懂，且支持多种语言，因此被广泛应用于各种编辑器和IDE中，如 VSCode、Sublime Text 等。JetBrains 的 IDE 也集成了 Textmate Bundle 插件，可以直接导入 Textmate 的语法高亮规则。\n3. 语法高亮规则的编写VSCode 官方有一套关于编写 Textmate 语法高亮规则的文档，包含分词和主题化，详见：Syntax Highlight Guide。\n本文不会介绍如何编写 Textmate 分词规则，只会浅析其工作原理。\n4. Textmate 的分词规则运行机制Textmate 的语法高亮规则是基于正则表达式的，Textmate 的语法高亮引擎会根据我们定义好的语法高亮规则对文本进行分词。分词的过程是从文本的开头开始，逐个字符地匹配规则，直到匹配到一个规则为止，然后将匹配到的字符标记为某种语法类型，然后继续匹配下一个字符，直到匹配到文本的末尾。\n以下面的语法高亮规则为例：\n{ \u0026#34;patterns\u0026#34;: [ { \u0026#34;match\u0026#34;: \u0026#34;\\\\bhello\\\\b\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;keyword.hello.jtgo\u0026#34; }, { \u0026#34;match\u0026#34;: \u0026#34;\\\\w+\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;string.word.jtgo\u0026#34; }, { \u0026#34;begin\u0026#34;: \u0026#34;{{\u0026#34;, \u0026#34;beginCaptures\u0026#34;: { \u0026#34;0\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;expression.begin.jtgo\u0026#34; } }, \u0026#34;end\u0026#34;: \u0026#34;}}\u0026#34;, \u0026#34;endCaptures\u0026#34;: { \u0026#34;0\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;expression.end.jtgo\u0026#34; } }, \u0026#34;name\u0026#34;: \u0026#34;expression.jtgo\u0026#34;, \u0026#34;patterns\u0026#34;: [ { \u0026#34;match\u0026#34;: \u0026#34;\\\\b(len|panic|print|println|min|max)\\\\b(?=\\\\()\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;keyword.builtin-function.name.jtgo\u0026#34; } ] } ] } patterns 列表中的每一个 item 都是一个规则，在 Textmate 中被称为 Rule Key。\n当 Textmate 引擎匹配到 hello 时，会将其标记为 keyword.hello 作用域。 当 Textmate 引擎匹配到 \\\\w+，也就是任意单词字符时，会将其标记为 string.word.jtgo 作用域。 当 Textmate 引擎匹配到 {{ 时，接着会继续匹配直到匹配到 }}，并且将 {{ 和 }} 之间的内容使用子规则（嵌套规则）进行匹配。这个规则的作用域映射如下： {{ -\u0026gt; expression.begin.jtgo }} -\u0026gt; expression.end.jtgo {{ print(\u0026quot;OK\u0026quot;) }} -\u0026gt; expression.jtgo print -\u0026gt; keyword.builtin-function.name.jtgo 对于 {{ 和 }} 之间的内容，当 Textmate 引擎匹配到 \\\\b(len|panic|print|println|min|max)\\\\b(?=\\\\() 时，也就是 ( 之前的 len、panic、print、println、min 或 max 时，会将其标记为 keyword.builtin-function.name.jtgo 作用域。 例如下面的文本，经过 Textmate 引擎的分词后，会被标记为如下的 Token：\n# hello world! {{ print(\u0026#34;OK\u0026#34;) }} 4.1 JSON 的分词规则直接进阶到 JSON 的分词规则，详细规则内容以 VSCode 的内置 JSON 分词规则为例：\n整个文件内容默认会被最外层的 scopeName 匹配，既所有的内容都会被标记上 source.json 作用域。 整个 JSON 文件的作用域是 source.json\n引擎会将第一个字符从最外层的 patterns 数组开始匹配，从上至下按顺序匹配每一个规则，直到匹配到一个规则为止。 JSON 的最外层 patterns 只有一个规则 value 规则，第一个字符会使用 value 的规则进行匹配。\n对于每个规则，如果规则中未包含 match 或 begin 和 end，则会直接递归匹配 patterns 中的规则。反之分为两种情况： 只有 match 字段，会尝试匹配当前规则的 match 字段，如果匹配成功，则将匹配到的字符标记为 name 字段和 captures 字段中的作用域，并继续匹配下一个字符。若匹配失败，则会跳出规则，回到 patterns 中继续匹配下一个规则。 只有 begin 和 end 字段，会尝试匹配 begin 规则，匹配成功时会继续将匹配到字符标记为 beginCaptures 字段中的作用域（end 字段同理），如果规则中包含 patterns 字段，则下一个字符会使用 patterns 中的规则进行匹配，直到匹配到 end 规则为止。如果规则中未包含 patterns 字段，则会直接匹配 end 字段。匹配到 end 字段后，会将当前规则匹配到所有的字符都标记上 name 作用域，begin 所匹配字符和 end 所匹配字符之间的内容会额外标记上 contentName 作用域。最后会跳出当前递归规则，回到上一层规则继续匹配。 JSON 的 value 规则内只有一个 patterns 字段，则会直接递归匹配 patterns 中的规则。\nJSON 文件的第一个字符是 {，引擎会尝试匹配 constant 规则，其中只有一个 match 规则，但匹配失败，所以会跳出 constant 规则，回到 value 的 patterns 规则中继续匹配下一个规则。\n以此类推，number、string 和 array 规则都会匹配失败。\n接着会匹配 object 规则， { 字符会匹配成功其 begin 字段规则，接着下一个字符会使用 object 规则中的 patterns 规则进行匹配。\n若未匹配到 patterns 中的任何规则，则会继续匹配下一个字符。 下面是 Textmate 解析 JSON 内容过程一步步拆解后的示意图：\n5. 附录 正则表达式温习\n","permalink":"https://blog.cassdev.com/posts/%E6%B5%85%E6%9E%90-textmate-%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E8%A7%84%E5%88%99%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/","summary":"\u003ch2 id=\"1-语法高亮简介\"\u003e1. 语法高亮简介\u003c/h2\u003e\u003cp\u003e语法高亮是指在IDE或编辑器中，对文本进行\u003cstrong\u003e分词\u003c/strong\u003e，即将文本拆解为 Token（标记），每个 Token 都有对应的名称（作用域）进行标记。再配合主题样式规则，对不同名称的 Token 的进行\u003cstrong\u003e主题化\u003c/strong\u003e，以提高代码的可读性。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e程序员离不开语法高亮，就像作家离不开标点符号一样。（你可以代入一下使用 txt 文本编辑器写代码的场景）\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e语法高亮由两个部分组成：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e分词（Tokenization）：将文本拆解为一系列 Token。\u003c/li\u003e\n\u003cli\u003e主题化（Theming）：对 Token 进行样式渲染，如字体颜色、背景色、加粗等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们以 JSON 的语法为例，简单介绍一下语法高亮的过程。\u003c/p\u003e\n\u003cp\u003e首先分词引擎会对 JSON 文本进行分词，下图是将 JSON 文本进行分词后的结果，其中每个矩形所包括的文本都是一个 Token，每个 Token 都有一个作用域名称，例如 \u003ccode\u003enull\u003c/code\u003e 对应的是 \u003ccode\u003econstant.language.json\u003c/code\u003e 作用域。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://s2.loli.net/2025/03/16/mQydfgXDYCuKPLo.png\"\u003e\u003c/p\u003e\n\u003cp\u003e然后主题化引擎会根据 Token 的作用域名称，对 Token 进行样式渲染，例如将 \u003ccode\u003econstant.language.json\u003c/code\u003e 作用域映射为蓝色不加粗字体。那么 \u003ccode\u003enull\u003c/code\u003e 就会被渲染为蓝色不加粗字体。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"https://s2.loli.net/2025/03/16/cho7NWLtem1Evgf.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"2-分词的实现方式\"\u003e2. 分词的实现方式\u003c/h2\u003e\u003cp\u003e目前主流的分词实现方式大致有有以下三种：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e基于\u003cstrong\u003e正则表达式\u003c/strong\u003e的分词：Textmate\u003c/li\u003e\n\u003cli\u003e基于\u003cstrong\u003e词法分析\u003c/strong\u003e的分词：Highlight.js\u003c/li\u003e\n\u003cli\u003e基于\u003cstrong\u003e语法树\u003c/strong\u003e的分词：Tree-sitter\u003c/li\u003e\n\u003cli\u003e(如果有其他，欢迎补充)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e本文只讨论 Textmate 的语法高亮规则编写。\u003c/p\u003e\n\u003cp\u003eTextmate 原是 MacOS 下的一款文本编辑器，其语法高亮规则是基于正则表达式的，但由于其规则简单易懂，且支持多种语言，因此被广泛应用于各种编辑器和IDE中，如 VSCode、Sublime Text 等。JetBrains 的 IDE 也集成了 Textmate Bundle 插件，可以直接导入 Textmate 的语法高亮规则。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"alt text\" loading=\"lazy\" src=\"CleanShot%202025-03-12%20at%2017.23.49@2x.png\"\u003e\u003c/p\u003e","title":"浅析 Textmate 语法高亮规则运行机制"},{"content":"这篇文章适合于那些已经熟悉 Vim 基础操作，希望提高 Vim 编辑技能的开发者。\n技能移动到特定字符使用 f{character} 可以快速跳转到指定字符。之后，你可以使用 ; 跳转到该字符下一次出现的位置，或者用 , 跳转到上一次出现的位置。你可以把 ; 和 , 理解为重复执行字符搜索的快捷键。\n快速水平移动 0: 移动到行首的第一个字符 ^: 移动到行首的第一个非空白字符 $: 移动到行尾 g_: 移动到行尾的最后一个非空白字符 使用搜索进行精准垂直移动 /{pattern}: 在文件中向前搜索指定模式 ?{pattern}: 在文件中向后搜索指定模式 其他定位操作 %: 在成对的括号 ()、[]、{} 之间跳转。 操作符快捷语法 双击操作符可作用于整行: dd 删除整行，cc 修改整行，等等。 大写操作符可执行更强（或替代）的默认行为: D 删除从光标到行尾的内容，C 修改到行尾的内容，Y 复制整行（同 yy），P 在光标前粘贴。 使用文本对象提升编辑效率 daw: 删除一个单词（包括末尾的空格） ciw: 修改单词内容 das: 删除一个句子 (dis 则不包含句子末尾的空格) da\u0026quot;: 删除双引号内的内容，包括引号本身 (di\u0026quot; 只删除内容，保留引号) ci\u0026quot;: 修改双引号内的内容 dap: 删除一个段落 dab 或 da( 或 da): 删除 () 包围的代码块 daB 或 da{ 或 da}: 删除 {} 包围的代码块 dat: 删除整个 HTML 标签 cit: 修改 HTML 标签内的内容 实用的插入模式技巧 gi: 这个命令可以让你快速返回到上次编辑的位置并进入插入模式。如果你不小心退出了插入模式，想回到原位继续输入，这个功能会非常方便。（这与原生 Vim 略有不同，在 Vim 中，gi 会将你带到上次离开插入模式的位置。） 使用寄存器实现多次复制和剪切 \u0026quot;ayas 会复制一个句子并存入寄存器 a。之后，你可以通过 \u0026quot;ap 将其粘贴到任意位置。如果使用大写寄存器 A，则会将复制或剪切的内容追加到该寄存器中，而不是覆盖。 在插入模式下粘贴 CTRL-R \u0026quot;: 粘贴默认寄存器中的内容 CTRL-R a: 粘贴寄存器 a 中的内容 CTRL-R 0: 粘贴最近一次复制的内容 批量删除多行 使用行号: :10,12d 删除第 10、11 和 12 行。 使用偏移量: :10,+2d 从第 10 行开始，总共删除 3 行。 使用 . 代表当前行: :.,+2d 删除当前行及随后的两行。 使用 % 代表整个文件: :%d 删除所有行。 使用 0 代表文件开头: :0,+10d 删除文件的前 11 行（从第 0 行开始，再加 10 行）。 使用 $ 代表文件结尾: :.,$d 删除从当前行到文件末尾的所有内容。 在可视模式下操作: 当你选中一段文本后输入 :，命令行会自动填充为 :'\u0026lt;,'\u0026gt;，这代表当前选中的范围。例如，:'\u0026lt;,'\u0026gt;d 会删除所有选中的行。 Vim-Surround 插件操作 ds': 删除外围的 ' (格式: ds{char}) cs'\u0026quot;: 将外围的 ' 替换为 \u0026quot; (格式: cs{old}{new}) ysaptli\u0026gt;: 用 \u0026lt;li\u0026gt; 标签包裹整个段落 (格式: ys{motion}{char}) 你也可以在可视模式下选中一段文本，然后按 S{desired character}，这样就能用你希望的字符包裹选中的文本。 Vim-EasyMotion 插件操作 例如，输入 \u0026lt;leader\u0026gt;\u0026lt;leader\u0026gt;w，EasyMotion 会标记出光标前所有单词的开头，方便你快速跳转。 参考 Boost Your Coding Fu With VS Code and Vim ","permalink":"https://blog.cassdev.com/posts/vim-skill-completion-plan/","summary":"适合已经熟悉 Vim 基础操作，希望提高编辑技能的开发者的实用技巧集合","title":"Vim 技能补全计划"},{"content":"本文基于 Linux 6.9 内核源码进行分析。\n几个数据结构\neventpoll这是 epoll 的主要数据结构，它用于存储 epoll 的相关信息，包括等待队列、就绪队列、红黑树等。\nstruct eventpoll { wait_queue_head_t wq; // epoll 的等待队列：用于存储等待的进程/线程，指向等待队列头 wait_queue_head_t poll_wait;// 这个 poll_wait 等待队列只有在 epoll 嵌套的情况下才会用到 struct list_head rdllist; // 就绪队列：用于存储就绪的 fd，指向就绪队列头 struct rb_root_cached rbr; // 红黑树：用于存储所有的 fd，指向红黑树根节点 struct wakeup_source *ws; // 一个唤醒源，用于唤醒进程 }; epitemepitem 的作用是将 fd、就绪队列、红黑树节点等信息封装在一起。\nstruct epitem { union { struct rb_node rbn; // 红黑树节点，用于存储 fd，指向红黑树节点 struct rcu_head rcu; // 用于释放 epitem }; struct list_head rdllink; // 就绪队列节点，用于存储就绪的 fd，指向就绪队列节点 struct eventpoll *ep; // 指向 eventpoll struct epoll_filefd ffd; // epoll 文件描述符 struct wakeup_source *ws; // 一个唤醒源，用于唤醒进程 struct epoll_event event; // 监听的事件 }; ep_pqueue给 poll 队列封装的结构体，用于存储 poll_table 和 epitem。\nstruct ep_pqueue { poll_table pt; struct epitem *epi; }; poll_tablepoll_table 的作用是封装 poll 队列的处理函数和 key。\ntypedef struct poll_table_struct { poll_queue_proc _qproc; __poll_t _key; } poll_table; eppoll_entrystruct eppoll_entry { struct eppoll_entry *next; // 指向 epitem 的 epoll_entry struct epitem *base; // 指向 epitem wait_queue_entry_t wait; // 等待队列项 wait_queue_head_t *whead; // 指向 socket 等待队列头 }; wait_queue_entrywait_queue_entry 的作用是封装等待队列的相关信息。\nstruct wait_queue_entry { unsigned int\tflags; void\t*private; wait_queue_func_t\tfunc; struct list_head\tentry; }; epoll_create// 定义 epoll_create 系统调用 SYSCALL_DEFINE1(epoll_create, int, size) { if (size \u0026lt;= 0) return -EINVAL; return do_epoll_create(0); // 调用 do_epoll_create 函数，[[具体实现见下面]] } static int do_epoll_create(int flags) { int error, fd; struct eventpoll *ep = NULL; struct file *file; BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC); if (flags \u0026amp; ~EPOLL_CLOEXEC) return -EINVAL; error = ep_alloc(\u0026amp;ep); // 为 eventpoll 分配内存，[[具体实现见下面]] if (error \u0026lt; 0) return error; // 创建 eventpoll 所需的东东。也就是一个文件结构和一个空闲的文件描述符。 fd = get_unused_fd_flags(O_RDWR | (flags \u0026amp; O_CLOEXEC)); // 获取一个未使用的文件描述符 if (fd \u0026lt; 0) { error = fd; goto out_free_ep; } // 创建一个文件结构 file = anon_inode_getfile(\u0026#34;[eventpoll]\u0026#34;, \u0026amp;eventpoll_fops, ep, O_RDWR | (flags \u0026amp; O_CLOEXEC)); if (IS_ERR(file)) { error = PTR_ERR(file); goto out_free_fd; } ep-\u0026gt;file = file; // 将文件结构赋值给 eventpoll // 将文件描述符和文件结构关联起来 fd_install(fd, file); return fd; out_free_fd: put_unused_fd(fd); out_free_ep: ep_clear_and_put(ep); return error; } static int ep_alloc(struct eventpoll **pep) { struct eventpoll *ep; ep = kzalloc(sizeof(*ep), GFP_KERNEL); // 为 eventpoll 分配内存 if (unlikely(!ep)) return -ENOMEM; mutex_init(\u0026amp;ep-\u0026gt;mtx); // 初始化锁 rwlock_init(\u0026amp;ep-\u0026gt;lock); init_waitqueue_head(\u0026amp;ep-\u0026gt;wq); // 初始化等待队列 init_waitqueue_head(\u0026amp;ep-\u0026gt;poll_wait); // 初始化 poll 等待队列 INIT_LIST_HEAD(\u0026amp;ep-\u0026gt;rdllist); // 初始化就绪队列 ep-\u0026gt;rbr = RB_ROOT_CACHED; ep-\u0026gt;ovflist = EP_UNACTIVE_PTR; ep-\u0026gt;user = get_current_user(); refcount_set(\u0026amp;ep-\u0026gt;refcount, 1); // 引用计数初始化为 1 *pep = ep; // 将 eventpoll 赋值给 pep return 0; } epoll_ctl// 定义 epoll_ctl 系统调用 SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd, struct epoll_event __user *, event) { struct epoll_event epds; // ep_op_has_event 用于告诉 epoll_ctl 是否需要将 event 拷贝到内核空间 // ep_op_has_event 的实现就一行，return op != EPOLL_CTL_DEL; if (ep_op_has_event(op) \u0026amp;\u0026amp; copy_from_user(\u0026amp;epds, event, sizeof(struct epoll_event))) // 将 event 拷贝到内核空间，epds 是内核空间的 epoll_event return -EFAULT; return do_epoll_ctl(epfd, op, fd, \u0026amp;epds, false); // 调用 do_epoll_ctl 函数，[[具体实现见下面]] } int do_epoll_ctl(int epfd, int op, int fd, struct epoll_event *epds, bool nonblock) { int error; int full_check = 0; struct fd f, tf; struct eventpoll *ep; struct epitem *epi; struct eventpoll *tep = NULL; error = -EBADF; f = fdget(epfd); // 获取 epfd 对应的文件描述符 if (!f.file) goto error_return; tf = fdget(fd); // 获取 fd 对应的文件描述符 // f 为 epoll 文件描述符，tf 为我们要监听的文件描述符 if (!tf.file) goto error_fput; error = -EPERM; if (!file_can_poll(tf.file)) // 检查 tf 是否支持 poll，不支持直接返回 goto error_tgt_fput; if (ep_op_has_event(op)) // 如果 op 是 EPOLL_CTL_ADD 或 EPOLL_CTL_MOD ep_take_care_of_epollwakeup(epds); // 保持线程唤醒状态，防止线程被挂起 error = -EINVAL; // 如果 epfd 和 fd 是同一个文件描述符 // 或者 epfd 不是 epoll 文件描述符，直接返回 if (f.file == tf.file || !is_file_epoll(f.file)) goto error_tgt_fput; // 省略一段检查错误的代码 ep = f.file-\u0026gt;private_data; // 获取 epfd 中的 eventpoll 结构体 error = epoll_mutex_lock(\u0026amp;ep-\u0026gt;mtx, 0, nonblock); if (error) goto error_tgt_fput; // 此处省略了一坨用于处理 epoll 嵌套的情况的代码，不管 epi = ep_find(ep, tf.file, fd); // 在红黑树中查找 fd 对应的 epitem，可能找不到 error = -EINVAL; switch (op) { // 根据 op 的不同，执行不同的操作 // ADD case EPOLL_CTL_ADD: if (!epi) { // 红黑树里没有 fd 才插入 epds-\u0026gt;events |= EPOLLERR | EPOLLHUP; error = ep_insert(ep, epds, tf.file, fd, full_check); // 插入 fd 到红黑树，[[具体实现见下面]] } else error = -EEXIST; break; // DEL case EPOLL_CTL_DEL: if (epi) { ep_remove_safe(ep, epi); // 在红黑树删除 fd，[[具体实现见下面]] error = 0; } else { error = -ENOENT; } break; // MOD case EPOLL_CTL_MOD: if (epi) { if (!(epi-\u0026gt;event.events \u0026amp; EPOLLEXCLUSIVE)) { epds-\u0026gt;events |= EPOLLERR | EPOLLHUP; error = ep_modify(ep, epi, epds); // 修改 fd 的监听事件，[[具体实现见下面]] } } else error = -ENOENT; break; } mutex_unlock(\u0026amp;ep-\u0026gt;mtx); error_tgt_fput: if (full_check) { clear_tfile_check_list(); loop_check_gen++; mutex_unlock(\u0026amp;epnested_mutex); } fdput(tf); error_fput: fdput(f); error_return: return error; } ep_insertstatic int ep_insert(struct eventpoll *ep, const struct epoll_event *event, struct file *tfile, int fd, int full_check) { int error, pwake = 0; __poll_t revents; struct epitem *epi; struct ep_pqueue epq; // 一个 epitem 和回调函数的包装 struct eventpoll *tep = NULL; // 这个是用于处理 epoll 嵌套的情况 // 省略一段不重要的代码，问题不大 // 为 epitem 分配内存 if (!(epi = kmem_cache_zalloc(epi_cache, GFP_KERNEL))) { percpu_counter_dec(\u0026amp;ep-\u0026gt;user-\u0026gt;epoll_watches); return -ENOMEM; } // 构造 epitem INIT_LIST_HEAD(\u0026amp;epi-\u0026gt;rdllink); epi-\u0026gt;ep = ep; ep_set_ffd(\u0026amp;epi-\u0026gt;ffd, tfile, fd); epi-\u0026gt;event = *event; epi-\u0026gt;next = EP_UNACTIVE_PTR; // 省略不重要的代码 ep_rbtree_insert(ep, epi); // 将 epitem 插入红黑树 // 省略不重要的代码 epq.epi = epi; // 将 epitem 放入 ep_pqueue 这个队列 // 将 ep_ptable_queue_proc 函数赋值给 ep_pqueue.pt 的函数指针，用于处理 poll 队列，会在下一行的 ep_item_poll 函数中回调 init_poll_funcptr(\u0026amp;epq.pt, ep_ptable_queue_proc); revents = ep_item_poll(epi, \u0026amp;epq.pt, 1); // 调用 ep_item_poll 函数 [[具体实现见下面]] // 省略不重要的代码 // 如果 fd 已就绪，将其放入就绪队列 if (revents \u0026amp;\u0026amp; !ep_is_linked(epi)) { list_add_tail(\u0026amp;epi-\u0026gt;rdllink, \u0026amp;ep-\u0026gt;rdllist); // 加入到就绪队列尾部 ep_pm_stay_awake(epi); // 保持唤醒状态 if (waitqueue_active(\u0026amp;ep-\u0026gt;wq)) wake_up(\u0026amp;ep-\u0026gt;wq); // 唤醒 wq 等待队列 // 省略和 epoll 嵌套有关的代码 } write_unlock_irq(\u0026amp;ep-\u0026gt;lock); // 省略和 epoll 嵌套有关的代码 return 0; } static __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt, int depth) { struct file *file = epi_fget(epi); __poll_t res; if (!file) return 0; pt-\u0026gt;_key = epi-\u0026gt;event.events; if (!is_file_epoll(file)) // 如果不是 epoll fd，即普通 fd（socket fd），调用 vfs_poll 函数 // 大部分都是这一情况!!! res = vfs_poll(file, pt); else // 这种情况属于嵌套 epoll，调用 __ep_eventpoll_poll 函数 res = __ep_eventpoll_poll(file, pt, depth); // res 就是 socket 所有就绪的事件 fput(file); return res \u0026amp; epi-\u0026gt;event.events; // 这里才进一步判断是否是我们关心的事件（监听的事件） } // 普通 fd 的处理函数 static inline __poll_t vfs_poll(struct file *file, struct poll_table_struct *pt) { if (unlikely(!file-\u0026gt;f_op-\u0026gt;poll)) return DEFAULT_POLLMASK; // 这里实际上是调用了 socket 的 poll 函数，然后会根据 socket 类型调用不同的函数 // 如 tcp_poll、udp_poll 等 return file-\u0026gt;f_op-\u0026gt;poll(file, pt); // 先通过 sock_poll，然后这里以 tcp_poll 为例 [[具体实现见下面]] } static __poll_t sock_poll(struct file *file, poll_table *wait) { struct socket *sock = file-\u0026gt;private_data; const struct proto_ops *ops = READ_ONCE(sock-\u0026gt;ops); // 略一部分，flag 与 busy_poll 有关，不重要 return ops-\u0026gt;poll(file, sock, wait) | flag; // 调用 tcp_poll 函数 [[具体实现见下面]] } __poll_t tcp_poll(struct file *file, struct socket *sock, poll_table *wait) { __poll_t mask; struct sock *sk = sock-\u0026gt;sk; const struct tcp_sock *tp = tcp_sk(sk); u8 shutdown; int state; sock_poll_wait(file, sock, wait); // sock_poll_wait 函数 [[具体实现见下面]] state = inet_sk_state_load(sk); if (state == TCP_LISTEN) // 如果是监听状态，查看 accept 队列是否为空 return inet_csk_listen_poll(sk); // 具体实现是如果不为空，则返回 EPOLLIN | EPOLLRDNORM // 不是监听状态，就是连接状态，就有可能读写就绪 // 下面一大段就是根据连接状态、接收缓冲区、发送缓冲区等情况来判断是否可读可写 // 这里就省略了 // ... return mask; } static inline void sock_poll_wait(struct file *filp, struct socket *sock, poll_table *p) { if (!poll_does_not_wait(p)) { poll_wait(filp, \u0026amp;sock-\u0026gt;wq.wait, p); // [[具体实现见下面]] smp_mb(); } } static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p) { if (p \u0026amp;\u0026amp; p-\u0026gt;_qproc \u0026amp;\u0026amp; wait_address) p-\u0026gt;_qproc(filp, wait_address, p); // 到这，实际上是调用了 ep_ptable_queue_proc 函数 } // 重点是这个函数，这是用于将我们的等待队列添加到目标文件唤醒列表的回调。 static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead, poll_table *pt) { // container_of 是 Linux 的一个骚操作，用于通过结构体成员获取其所在的结构体的指针，有兴趣可以自行搜索 // 这里是通过 pt 获取 ep_pqueue 结构体的指针，进而获取 epitem struct ep_pqueue *epq = container_of(pt, struct ep_pqueue, pt); struct epitem *epi = epq-\u0026gt;epi; struct eppoll_entry *pwq; if (unlikely(!epi)) return; // 为 pwq 分配内存 pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL); if (unlikely(!pwq)) { epq-\u0026gt;epi = NULL; return; } init_waitqueue_func_entry(\u0026amp;pwq-\u0026gt;wait, ep_poll_callback); // 将我们的回调函数赋值给 wait pwq-\u0026gt;whead = whead; pwq-\u0026gt;base = epi; if (epi-\u0026gt;event.events \u0026amp; EPOLLEXCLUSIVE) add_wait_queue_exclusive(whead, \u0026amp;pwq-\u0026gt;wait); else add_wait_queue(whead, \u0026amp;pwq-\u0026gt;wait); // 将 pwq 加入到 socket 的等待队列 // 这个 pwq 会在 socket 网卡有数据时被中断程序调用，然后调用 pwq 里存的回调函数，即 ep_poll_callback pwq-\u0026gt;next = epi-\u0026gt;pwqlist; epi-\u0026gt;pwqlist = pwq; } ep_modifyep_remove_safeepoll_waitSYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events, int, maxevents, int, timeout) { struct timespec64 to; // 将 timeout 转换为 timespec64 结构体 // do_epoll_wait [[具体实现见下面]] return do_epoll_wait(epfd, events, maxevents, ep_timeout_to_timespec(\u0026amp;to, timeout)); } static int do_epoll_wait(int epfd, struct epoll_event __user *events, int maxevents, struct timespec64 *to) { int error; struct fd f; struct eventpoll *ep; // 这里的 EP_MAX_EVENTS = INT_MAX / sizeof(struct epoll_event) if (maxevents \u0026lt;= 0 || maxevents \u0026gt; EP_MAX_EVENTS) // maxevents 必须大于 0 且小于 EP_MAX_EVENTS return -EINVAL; // 验证用户传递的区域是否可写 if (!access_ok(events, maxevents * sizeof(struct epoll_event))) return -EFAULT; f = fdget(epfd); // 获取 epfd 对应的文件描述符 if (!f.file) return -EBADF; error = -EINVAL; if (!is_file_epoll(f.file)) // 确保 epfd 是 epoll 文件描述符 goto error_fput; ep = f.file-\u0026gt;private_data; // 取出 eventpoll 结构体 error = ep_poll(ep, events, maxevents, to); // 调用 ep_poll 函数，[[具体实现见下面]] error_fput: fdput(f); return error; } static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events, int maxevents, struct timespec64 *timeout) { int res, eavail, timed_out = 0; u64 slack = 0; wait_queue_entry_t wait; ktime_t expires, *to = NULL; lockdep_assert_irqs_enabled(); // 计算超时时间 if (timeout \u0026amp;\u0026amp; (timeout-\u0026gt;tv_sec | timeout-\u0026gt;tv_nsec)) { // 这里是用户指定了超时时间 slack = select_estimate_accuracy(timeout); to = \u0026amp;expires; *to = timespec64_to_ktime(*timeout); // 将时间转换为 ktime_t 结构体 } else if (timeout) { // 这里是用户没有指定超时时间，将会在检查一次事件后返回 timed_out = 1; } eavail = ep_events_available(ep); // 检查是否有事件可用 [[具体实现见下面]] while (1) { if (eavail) { // 有事件可用 // 尝试将事件传递给用户空间 res = ep_send_events(ep, events, maxevents); if (res) // 传递成功 return res; // 这里是有事件情况的函数出口 } if (timed_out) return 0; // 这里是超时情况的函数出口 // 这里省略了 busy loop 的代码 if (signal_pending(current)) // 如果有信号挂起，直接返回 return -EINTR; init_wait(\u0026amp;wait); // 初始化等待队列项，这里就和 ep.wq 有关了 // 设置回调函数，在唤醒进程后自动删除该进程在 ep.wq 中对应的项 wait.func = ep_autoremove_wake_function; write_lock_irq(\u0026amp;ep-\u0026gt;lock); __set_current_state(TASK_INTERRUPTIBLE); // 设置当前进程状态为 可中断睡眠 eavail = ep_events_available(ep); // 再次检查是否有事件可用 if (!eavail) // 没有事件可用，将当前进程加入到等待队列 __add_wait_queue_exclusive(\u0026amp;ep-\u0026gt;wq, \u0026amp;wait); write_unlock_irq(\u0026amp;ep-\u0026gt;lock); if (!eavail) // 没事件，将当前进程挂起，如果有中断信号，则会被唤醒，超时也会被唤醒。 // 如果是被有事件的中断信号唤醒的， // 则先会调用 epitem 的回调函数，即在 epoll_ctl 中注册的 ep_poll_callback 函数， // 将就绪的 fd 放入 rdllist 就绪队列，再唤醒刚刚加入到 ep-\u0026gt;wq 的线程。 // 然后再返回。 timed_out = !schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS); __set_current_state(TASK_RUNNING); // 设置当前进程状态为运行态 eavail = 1; if (!list_empty_careful(\u0026amp;wait.entry)) { write_lock_irq(\u0026amp;ep-\u0026gt;lock); if (timed_out) eavail = list_empty(\u0026amp;wait.entry); __remove_wait_queue(\u0026amp;ep-\u0026gt;wq, \u0026amp;wait); write_unlock_irq(\u0026amp;ep-\u0026gt;lock); } } } static inline int ep_events_available(struct eventpoll *ep) { return !list_empty_careful(\u0026amp;ep-\u0026gt;rdllist) || READ_ONCE(ep-\u0026gt;ovflist) != EP_UNACTIVE_PTR; } static int ep_send_events(struct eventpoll *ep, struct epoll_event __user *events, int maxevents) { struct epitem *epi, *tmp; LIST_HEAD(txlist); // txlist 是用来向用户空间拷贝数据的链表 poll_table pt; int res = 0; if (fatal_signal_pending(current)) return -EINTR; init_poll_funcptr(\u0026amp;pt, NULL); mutex_lock(\u0026amp;ep-\u0026gt;mtx); ep_start_scan(ep, \u0026amp;txlist); // 这个函数用于将 ep-\u0026gt;rdllist 拷贝到 txlist list_for_each_entry_safe(epi, tmp, \u0026amp;txlist, rdllink) { // 遍历 txlist struct wakeup_source *ws; __poll_t revents; if (res \u0026gt;= maxevents) break; // 确保进程唤醒 ws = ep_wakeup_source(epi); if (ws) { if (ws-\u0026gt;active) __pm_stay_awake(ep-\u0026gt;ws); __pm_relax(ws); } list_del_init(\u0026amp;epi-\u0026gt;rdllink); // 从就绪队列中删除 epi // 注意！rdllist 里的 epi 有事件就绪，但不一定是我们感兴趣的事件！ // 所以这里查询 socket 的具体事件，是否为我们感兴趣的事件！ // 也就是说，rdllist 只能告诉我们可能有任何事件发生， // 但具体是什么事件，是否是我们感兴趣的事件，需要通过 ep_item_poll 函数来判断 revents = ep_item_poll(epi, \u0026amp;pt, 1); if (!revents) continue; // 没有我们感兴趣事件，遍历下一个 epi // 有我们感兴趣的事件，将 revents 和 epi-\u0026gt;event.data 其拷贝到用户空间的 events 里 events = epoll_put_uevent(revents, epi-\u0026gt;event.data, events); // [[具体实现见下面]] if (!events) { list_add(\u0026amp;epi-\u0026gt;rdllink, \u0026amp;txlist); // 拷贝失败，将 epi 放回 txlist ep_pm_stay_awake(epi); if (!res) res = -EFAULT; break; } res++; if (epi-\u0026gt;event.events \u0026amp; EPOLLONESHOT) // 处理 EPOLLONESHOT 的情况 epi-\u0026gt;event.events \u0026amp;= EP_PRIVATE_BITS; else if (!(epi-\u0026gt;event.events \u0026amp; EPOLLET)) { // 处理 EPOLLET 的情况 // 如果是 水平触发 模式，将 epi 放回就绪队列，等待下一次事件 list_add_tail(\u0026amp;epi-\u0026gt;rdllink, \u0026amp;ep-\u0026gt;rdllist); ep_pm_stay_awake(epi); } } // 要理解这个函数，我们得知道，如果在扫描过程中有 fd 要加入就绪队列， // 由于 rdllist 已经被锁住了，所以会将这个 fd 放入 ovflist 中， // 这个函数就是将 ovflist 中的 fd 放回入 rdllist 中。 ep_done_scan(ep, \u0026amp;txlist); mutex_unlock(\u0026amp;ep-\u0026gt;mtx); return res; } epoll_put_uevent(__poll_t revents, __u64 data, struct epoll_event __user *uevent) { // 注意这里依然使用的是 __put_user 函数，即从内核空间拷贝到用户空间，并没有使用共享内存！ if (__put_user(revents, \u0026amp;uevent-\u0026gt;events) || __put_user(data, \u0026amp;uevent-\u0026gt;data)) return NULL; return uevent+1; } ep_poll_callback// 这是传递给等待队列唤醒机制的回调函数。当存储的文件描述符有事件要报告时，它会被调用。 // 其实就干两件事，一是将就绪的 fd 放入就绪队列，二是唤醒等待队列。 static int ep_poll_callback(wait_queue_entry_t *wait, unsigned mode, int sync, void *key) { int pwake = 0; struct epitem *epi = ep_item_from_wait(wait); struct eventpoll *ep = epi-\u0026gt;ep; __poll_t pollflags = key_to_poll(key); unsigned long flags; int ewake = 0; // 一通检查猛如虎 read_lock_irqsave(\u0026amp;ep-\u0026gt;lock, flags); ep_set_busy_poll_napi_id(epi); if (!(epi-\u0026gt;event.events \u0026amp; ~EP_PRIVATE_BITS)) goto out_unlock; if (pollflags \u0026amp;\u0026amp; !(pollflags \u0026amp; epi-\u0026gt;event.events)) goto out_unlock; if (READ_ONCE(ep-\u0026gt;ovflist) != EP_UNACTIVE_PTR) { if (chain_epi_lockless(epi)) ep_pm_stay_awake_rcu(epi); } else if (!ep_is_linked(epi)) { // 如果 epi 不在就绪队列 // fd 就绪，将其放入就绪队列 if (list_add_tail_lockless(\u0026amp;epi-\u0026gt;rdllink, \u0026amp;ep-\u0026gt;rdllist)) ep_pm_stay_awake_rcu(epi); } // 放入就绪队列后，唤醒等待队列 if (waitqueue_active(\u0026amp;ep-\u0026gt;wq)) { if ((epi-\u0026gt;event.events \u0026amp; EPOLLEXCLUSIVE) \u0026amp;\u0026amp; !(pollflags \u0026amp; POLLFREE)) { switch (pollflags \u0026amp; EPOLLINOUT_BITS) { case EPOLLIN: if (epi-\u0026gt;event.events \u0026amp; EPOLLIN) ewake = 1; break; case EPOLLOUT: if (epi-\u0026gt;event.events \u0026amp; EPOLLOUT) ewake = 1; break; case 0: ewake = 1; break; } } wake_up(\u0026amp;ep-\u0026gt;wq); // 唤醒进程 } // 省略和 epoll 嵌套有关的代码 out_unlock: read_unlock_irqrestore(\u0026amp;ep-\u0026gt;lock, flags); // 省略和 epoll 嵌套有关的代码 return ewake; } ","permalink":"https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-epoll-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003e本文基于 Linux 6.9 内核源码进行分析。\u003c/p\u003e\n\u003ch2 id=\"几个数据结构\"\u003e几个数据结构\u003c/h2\u003e\u003cp\u003e\u003cimg alt=\"数据结构\" loading=\"lazy\" src=\"https://s2.loli.net/2024/06/30/fPingVOd2YcEFUX.jpg\"\u003e\u003c/p\u003e\n\u003ch3 id=\"eventpoll\"\u003eeventpoll\u003c/h3\u003e\u003cp\u003e这是 epoll 的主要数据结构，它用于存储 epoll 的相关信息，包括等待队列、就绪队列、红黑树等。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eeventpoll\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kt\"\u003ewait_queue_head_t\u003c/span\u003e \u003cspan class=\"n\"\u003ewq\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e       \u003cspan class=\"c1\"\u003e// epoll 的等待队列：用于存储等待的进程/线程，指向等待队列头\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kt\"\u003ewait_queue_head_t\u003c/span\u003e \u003cspan class=\"n\"\u003epoll_wait\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"c1\"\u003e// 这个 poll_wait 等待队列只有在 epoll 嵌套的情况下才会用到\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003elist_head\u003c/span\u003e \u003cspan class=\"n\"\u003erdllist\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e   \u003cspan class=\"c1\"\u003e// 就绪队列：用于存储就绪的 fd，指向就绪队列头\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003erb_root_cached\u003c/span\u003e \u003cspan class=\"n\"\u003erbr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 红黑树：用于存储所有的 fd，指向红黑树根节点\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ewakeup_source\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ews\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e   \u003cspan class=\"c1\"\u003e// 一个唤醒源，用于唤醒进程\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"epitem\"\u003eepitem\u003c/h3\u003e\u003cp\u003eepitem 的作用是将 fd、就绪队列、红黑树节点等信息封装在一起。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eepitem\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eunion\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003erb_node\u003c/span\u003e \u003cspan class=\"n\"\u003erbn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e     \u003cspan class=\"c1\"\u003e// 红黑树节点，用于存储 fd，指向红黑树节点\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ercu_head\u003c/span\u003e \u003cspan class=\"n\"\u003ercu\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// 用于释放 epitem\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003elist_head\u003c/span\u003e \u003cspan class=\"n\"\u003erdllink\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e   \u003cspan class=\"c1\"\u003e// 就绪队列节点，用于存储就绪的 fd，指向就绪队列节点\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eeventpoll\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eep\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e       \u003cspan class=\"c1\"\u003e// 指向 eventpoll\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eepoll_filefd\u003c/span\u003e \u003cspan class=\"n\"\u003effd\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// epoll 文件描述符\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ewakeup_source\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ews\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e   \u003cspan class=\"c1\"\u003e// 一个唤醒源，用于唤醒进程\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eepoll_event\u003c/span\u003e \u003cspan class=\"n\"\u003eevent\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e   \u003cspan class=\"c1\"\u003e// 监听的事件\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"ep_pqueue\"\u003eep_pqueue\u003c/h3\u003e\u003cp\u003e给 poll 队列封装的结构体，用于存储 poll_table 和 epitem。\u003c/p\u003e","title":"Socket 编程之 epoll 源码分析学习笔记"},{"content":"C++ 内存模型从上（高地址）到下（低地址）可以分为以下几个部分：\n栈区：由编译器自动分配释放，存放函数的参数值、局部变量的值等。\n堆区：由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收。\n全局/静态区：分为 .data 段（全局初始化区）和 .bss 段（全局未初始化区），.data 段存放 已初始化 了的全局变量和静态变量，.bss 段存放 未初始化 的变量。\n常量区：就是 .rodata 段，存放常量。\n代码区：存放函数体的代码。\n","permalink":"https://blog.cassdev.com/posts/c++-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003eC++ 内存模型从上（高地址）到下（低地址）可以分为以下几个部分：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e栈区\u003c/strong\u003e：由编译器自动分配释放，存放函数的参数值、局部变量的值等。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e堆区\u003c/strong\u003e：由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e全局/静态区\u003c/strong\u003e：分为 .data 段（全局初始化区）和 .bss 段（全局未初始化区），.data 段存放 \u003cstrong\u003e已初始化\u003c/strong\u003e 了的全局变量和静态变量，.bss 段存放 \u003cstrong\u003e未初始化\u003c/strong\u003e 的变量。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e常量区\u003c/strong\u003e：就是 .rodata 段，存放常量。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e代码区\u003c/strong\u003e：存放函数体的代码。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://s2.loli.net/2024/06/29/kHdqTj5Y2Fh7Ea4.jpg\"\u003e\u003c/p\u003e","title":"C++ 内存模型学习笔记"},{"content":"delete ptrdelete ptr 是释放 ptr 所指向的对象资源，而 ptr 依然存在，且依然指向那片内存地址。\nptr = nullptrptr = nullptr 是将 ptr 指向空指针，和其所指向的对象没关系。\n试着实现一个 unique_ptrtemplate \u0026lt;typename T\u0026gt; class UniquePtr { private: T *_ptr; public: // 默认构造 UniquePtr() : _ptr(nullptr) { } explicit UniquePtr(T *ptr) : _ptr(ptr) { } ~UniquePtr() { delete _ptr; // 无需置 nullptr，因为析构函数会被调用，_ptr 会被销毁 // 置空无意义 } // 拷贝构造 删除 UniquePtr(const UniquePtr \u0026amp;) = delete; UniquePtr \u0026amp;operator=(const UniquePtr \u0026amp;) = delete; // 移动构造 UniquePtr(UniquePtr \u0026amp;\u0026amp;p) noexcept : _ptr(p._ptr) { // 至于这里为什么不需要 delete _ptr // 是因为这是移动构造函数，是个构造函数！_ptr 本来就没有资源 p._ptr = nullptr; } UniquePtr \u0026amp;operator=(UniquePtr \u0026amp;\u0026amp;p) noexcept { if (p != *this) { delete _ptr; // 第一步，释放当前资源 _ptr = p._ptr; // 第二步，将当前指针指向新的资源 p._ptr = nullptr; // 第三步，将原来的指针置空 } return *this; } T *get() const { // 返回指针 return _ptr; } T *operator-\u0026gt;() const { // 返回指针 return _ptr; } T \u0026amp;operator*() const { // 解引用 return *_ptr; } T *release() { // 这里不能 delete _ptr // 因为 release 只是解除 UniquePtr 对资源的所有权，但资源还是存在的 T *tmp = _ptr; _ptr = nullptr; return tmp; } void reset(T *newptr = nullptr) { if (_ptr != newptr) { delete _ptr; // 释放当前资源 _ptr = newptr; // 指向新资源 // 这里不需要置空 newptr // 是否置空 new ptr 由用户决定 } } }; UniquePtr \u0026amp;operator=(UniquePtr \u0026amp;\u0026amp;p) 移动赋值运算符的原理如下图：\n","permalink":"https://blog.cassdev.com/posts/c++-delete-ptr-%E5%92%8C-ptr--nullptr-%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"\u003ch2 id=\"delete-ptr\"\u003edelete ptr\u003c/h2\u003e\u003cp\u003e\u003ccode\u003edelete ptr\u003c/code\u003e 是释放 \u003ccode\u003eptr\u003c/code\u003e 所指向的对象资源，而 \u003ccode\u003eptr\u003c/code\u003e 依然存在，且依然指向那片内存地址。\u003c/p\u003e\n\u003ch2 id=\"ptr--nullptr\"\u003eptr = nullptr\u003c/h2\u003e\u003cp\u003e\u003ccode\u003eptr = nullptr\u003c/code\u003e 是将 \u003ccode\u003eptr\u003c/code\u003e 指向空指针，和其所指向的对象没关系。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"ptr\" loading=\"lazy\" src=\"https://s2.loli.net/2024/06/29/z8RCgt6krxTPZjU.jpg\"\u003e\u003c/p\u003e\n\u003ch2 id=\"试着实现一个-unique_ptr\"\u003e试着实现一个 unique_ptr\u003c/h2\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003etemplate\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"k\"\u003etypename\u003c/span\u003e \u003cspan class=\"n\"\u003eT\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eUniquePtr\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 默认构造\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003eUniquePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enullptr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eexplicit\u003c/span\u003e \u003cspan class=\"nf\"\u003eUniquePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eptr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eptr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e~\u003c/span\u003e\u003cspan class=\"n\"\u003eUniquePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003edelete\u003c/span\u003e \u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 无需置 nullptr，因为析构函数会被调用，_ptr 会被销毁\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// 置空无意义\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 拷贝构造 删除\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003eUniquePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003eUniquePtr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003edelete\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eUniquePtr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003eUniquePtr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003edelete\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 移动构造\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003eUniquePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eUniquePtr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003enoexcept\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 至于这里为什么不需要 delete _ptr\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// 是因为这是移动构造函数，是个构造函数！_ptr 本来就没有资源\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enullptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eUniquePtr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eUniquePtr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003enoexcept\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003edelete\u003c/span\u003e \u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// 第一步，释放当前资源\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e      \u003cspan class=\"c1\"\u003e// 第二步，将当前指针指向新的资源\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enullptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e   \u003cspan class=\"c1\"\u003e// 第三步，将原来的指针置空\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nf\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 返回指针\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 返回指针\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eT\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 解引用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nf\"\u003erelease\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 这里不能 delete _ptr\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// 因为 release 只是解除 UniquePtr 对资源的所有权，但资源还是存在的\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003eT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003etmp\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enullptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003etmp\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003ereset\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003enewptr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enullptr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003enewptr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003edelete\u003c/span\u003e \u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// 释放当前资源\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"n\"\u003e_ptr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enewptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e      \u003cspan class=\"c1\"\u003e// 指向新资源\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"c1\"\u003e// 这里不需要置空 newptr\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"c1\"\u003e// 是否置空 new ptr 由用户决定\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eUniquePtr \u0026amp;operator=(UniquePtr \u0026amp;\u0026amp;p)\u003c/code\u003e 移动赋值运算符的原理如下图：\u003c/p\u003e","title":"C++ delete ptr 和 ptr = nullptr 的区别"},{"content":"链地址法链地址法也叫做拉链法，它的基本思想是，将哈希表中的每个槽位都指向一个链表，当发生哈希冲突时，将数据插入到链表中。\n很好理解，如图所示：\n开放定址法开放定址法是一种解决哈希冲突的方法，它的基本思想是，当发生哈希冲突时，不是将数据直接插入到哈希表中，而是寻找哈希表中的空槽位，将数据插入到空槽位中。\n线性探测线性探测采用固定步长的线性搜索来进行探测。\n插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 1），直至找到空桶，将元素插入其中。 查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 value 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 None 。 注意，我们不能在开放寻址哈希表中直接删除元素。因为删除元素会在数组内产生一个空桶 None ，当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在。\n为了解决该问题，我们可以采用懒删除（ lazy deletion ）机制，不直接从哈希表中移除元素，而是利用一个常量 TOMBSTONE 来标记这个桶。\nNone 和 TOMBSTONE 都代表空桶，都可以放置键值对。线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。在线性探测中记录遇到的首个 TOMBSTONE 的索引，并将搜索到的目标元素与该 TOMBSTONE 交换位置，这样可以优化效率。\n线性探测容易产生 聚集现象，为了缓解这个问题，就有了平方探测和双重散列。\n平方探测平方探测思想与线性探测类似，不同之处在于探测的步长是平方级别的。即当发生哈希冲突时，探测的步长为 1，4，9，\u0026hellip;步。\n平方探测可以缓解线性探测的聚集现象，但不能彻底解决。\n多次哈希多次哈希的基本思想是，当发生哈希冲突时，尝试其他的哈希函数，直到找到空槽位。\n与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。\n警告 以上三种方法，线性探测、平方探测和多次哈希哈希表都存在 不能直接删除元素 的问题。\n编程语言的选择 C++：链地址法\nJava：链地址法\nPython：开放定址法\nGo：链地址法\n参考 Hello算法-6.2哈希冲突 ","permalink":"https://blog.cassdev.com/posts/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch2 id=\"链地址法\"\u003e链地址法\u003c/h2\u003e\u003cp\u003e链地址法也叫做拉链法，它的基本思想是，将哈希表中的每个槽位都指向一个链表，当发生哈希冲突时，将数据插入到链表中。\u003c/p\u003e\n\u003cp\u003e很好理解，如图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://s2.loli.net/2024/06/29/DUupYdFkvxbCscP.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"开放定址法\"\u003e开放定址法\u003c/h2\u003e\u003cp\u003e开放定址法是一种解决哈希冲突的方法，它的基本思想是，当发生哈希冲突时，不是将数据直接插入到哈希表中，而是寻找哈希表中的空槽位，将数据插入到空槽位中。\u003c/p\u003e\n\u003ch3 id=\"线性探测\"\u003e线性探测\u003c/h3\u003e\u003cp\u003e线性探测采用固定步长的线性搜索来进行探测。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 1），直至找到空桶，将元素插入其中。\u003c/li\u003e\n\u003cli\u003e查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 value 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 None 。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e注意，我们不能在开放寻址哈希表中直接删除元素。因为删除元素会在数组内产生一个空桶 None ，当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://s2.loli.net/2024/06/29/qEIPUWjZ2HNwBbp.png\"\u003e\u003c/p\u003e\n\u003cp\u003e为了解决该问题，我们可以采用懒删除（ \u003cem\u003elazy deletion\u003c/em\u003e ）机制，不直接从哈希表中移除元素，而是利用一个常量 \u003cstrong\u003eTOMBSTONE\u003c/strong\u003e 来标记这个桶。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNone\u003c/strong\u003e 和 \u003cstrong\u003eTOMBSTONE\u003c/strong\u003e 都代表空桶，都可以放置键值对。线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。在线性探测中记录遇到的首个 TOMBSTONE 的索引，并将搜索到的目标元素与该 TOMBSTONE 交换位置，这样可以优化效率。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://s2.loli.net/2024/06/29/gxJ6SFeRzVZwG25.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e线性探测容易产生 \u003cstrong\u003e聚集现象\u003c/strong\u003e，为了缓解这个问题，就有了平方探测和双重散列。\u003c/p\u003e\n\u003ch3 id=\"平方探测\"\u003e平方探测\u003c/h3\u003e\u003cp\u003e平方探测思想与线性探测类似，不同之处在于探测的步长是平方级别的。即当发生哈希冲突时，探测的步长为 \u003ccode\u003e1\u003c/code\u003e，\u003ccode\u003e4\u003c/code\u003e，\u003ccode\u003e9\u003c/code\u003e，\u0026hellip;步。\u003c/p\u003e\n\u003cp\u003e平方探测可以缓解线性探测的聚集现象，但不能彻底解决。\u003c/p\u003e\n\u003ch3 id=\"多次哈希\"\u003e多次哈希\u003c/h3\u003e\u003cp\u003e多次哈希的基本思想是，当发生哈希冲突时，尝试其他的哈希函数，直到找到空槽位。\u003c/p\u003e\n\u003cp\u003e与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。\u003c/p\u003e\n\n            \u003clink rel=\"stylesheet\" href=\"/css/vendors/admonitions.4fd9a0b8ec8899f2ca952048d255a569f433f77dfb3f52f5bc87e7d65cdce449.css\" integrity=\"sha256-T9mguOyImfLKlSBI0lWlafQz9337P1L1vIfn1lzc5Ek=\" crossorigin=\"anonymous\"\u003e\n    \u003cdiv class=\"admonition warning\"\u003e\n      \u003cdiv class=\"admonition-header\"\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\u003cpath d=\"M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480L40 480c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24l0 112c0 13.3 10.7 24 24 24s24-10.7 24-24l0-112c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z\"/\u003e\u003c/svg\u003e\n        \u003cspan\u003e警告\u003c/span\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"admonition-content\"\u003e\n        \u003cp\u003e以上三种方法，线性探测、平方探测和多次哈希哈希表都存在 \u003cstrong\u003e不能直接删除元素\u003c/strong\u003e 的问题。\u003c/p\u003e","title":"哈希冲突解决方法学习笔记"},{"content":"常用容器 序列容器\nvector: 动态数组，随机插入/删除 O(n)，随机访问 O(1)，尾插 O(1)\narray: 静态数组，不支持插入/删除，随机访问 O(1)\ndeque: 双端队列，头尾插入/删除 O(1)，随机访问 O(1)，中间插入/删除 O(n)\nlist: 双向链表，插入/删除 O(1)，不支持随机访问\nforward_list: 单向链表，插入/删除 O(1)，不支持随机访问\n关联容器（底层实现为 红黑树 ）\nset: 有序集合，插入/删除/查找 O(logn)\nmap: 有序映射，插入/删除/查找 O(logn)\nmultiset: 有序多重集合，插入/删除/查找 O(logn)\nmultimap: 有序多重映射，插入/删除/查找 O(logn)\n无序容器（底层实现为 哈希表 ）\nunordered_set: 无序集合，插入/删除/查找 O(1)\nunordered_map: 无序映射，插入/删除/查找 O(1)\nunordered_multiset: 无序多重集合，插入/删除/查找 O(1)\nunordered_multimap: 无序多重映射，插入/删除/查找 O(1)\n容器适配器\nstack: 栈，后进先出，只能在栈顶插入/删除元素\nqueue: 队列，先进先出，只能在队尾插入，在队头删除元素\npriority_queue: 优先队列，元素按照一定规则排序，每次取出的是最大/最小元素，底层实现为堆\nvector#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // vector使用示例 int main() { vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; // 尾部插入元素：复杂度为O(1) vec.push_back(6); // 尾部删除元素：复杂度为O(1) vec.pop_back(); // 随机插入和删除元素：复杂度为O(n) vec.insert(vec.begin() + 1, 3); vec.erase(vec.begin() + 1); // vector的大小 cout \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; endl; // 获取vector的容量 cout \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; endl; // 判断vector是否为空 cout \u0026lt;\u0026lt; vec.empty() \u0026lt;\u0026lt; endl; // 获取vector的第一个元素和最后一个元素 cout \u0026lt;\u0026lt; vec.front() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; vec.back() \u0026lt;\u0026lt; endl; // 访问指定位置的元素 cout \u0026lt;\u0026lt; vec[2] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; vec.at(2) \u0026lt;\u0026lt; endl; // at函数会检查索引是否越界，更安全 vector\u0026lt;int\u0026gt; vec2 = {7, 8, 9, 10}; vec.swap(vec2); // 交换两个vector的元素 // 清空vector vec.clear(); } vector 常用的成员函数：\n元素访问\nfront(): 返回第一个元素\nback(): 返回最后一个元素\nat(): 访问指定位置的元素，会检查索引是否越界\n迭代器\nbegin(): 返回指向第一个元素的迭代器\nend(): 返回指向最后一个元素的迭代器\nrbegin(): 返回指向最后一个元素的逆向迭代器\nrend(): 返回指向第一个元素的逆向迭代器\ncbegin()、cend()、crbegin()、crend(): 返回常量迭代器，不允许修改元素\n容量\nsize(): 返回vector中元素的个数\nmax_size(): 返回当前程序中的vector最大可以容纳的元素个数，通常是一个很大的值\ncapacity(): 返回vector的容量\nempty(): 判断vector是否为空\nreserve(): 为vector预留空间\nshrink_to_fit(): 将vector的容量缩小到和元素个数相同\n元素修改\nassign(): 为vector赋值\nassign_range(): 为vector赋值一个范围内的元素（C++23）\npush_back(): 尾部插入元素\nemplace_back(): 原地构造并插入元素到尾部\npop_back(): 尾部删除元素\ninsert(): 插入元素\nemplace(): 原地构造并插入元素\ninsert_range(): 插入元素一个范围内的元素（C++23）\nappend_range(): 尾部插入元素一个范围内的元素（C++23）\nerase(): 删除元素\nresize(): 改变vector的大小\nswap(): 交换两个vector的元素\nclear(): 清空vector\nvector 的底层实现vector 的底层实现是一个动态数组，当元素个数超过容量时，会重新分配内存，将原来的元素拷贝到新的内存空间中。\n值得一提的是，无论 vector 是直接创建还是通过 new 关键词创建，vector 的 元素 都是在 堆上 分配的。\nvector 的扩容机制vector 的扩容取决于编译器的实现，在 GCC、Clang 中，vector 是以 2 倍 扩容的，即当元素个数超过容量时，会重新分配一个 2 倍大小的内存空间。在 MSVC 中，vector 是以 1.5 倍 扩容的。\n假设我们有一个 A 类，如果我们在 vector 中存储 A 类的对象，当 vector 扩容时，A 类的对象会被拷贝到新的内存空间中，这是一笔不小的开销！\nint main() { vector\u0026lt;A\u0026gt; vec{1, 2, 3, 4, 5}; cout \u0026lt;\u0026lt; vec.data() \u0026lt;\u0026lt; endl; // 输出：0x15be05f20 vec.reserve(100); // 扩容 cout \u0026lt;\u0026lt; vec.data() \u0026lt;\u0026lt; endl; // 输出：0x15be06100 // 从输出结果可以看出，vector 元素地址在内存的位置发生了变化 5f20 -\u0026gt; 6100 } vector 迭代器失效如果在插入元素时引起了内存的重新分配，那么原来的迭代器就会失效。例如下面代码：\nint main() { vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; //此时 size 和 capacity 都是 5 auto it = vec.begin(); cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; // 正常输出 1 vec.push_back(6); // vector 扩容，capacity 增加到 10，内存重新分配 cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; // 这里会出现未定义行为 } vector 的时间复杂度 操作 时间复杂度 push_back()、pop_back() O(1) insert()、erase() O(n) at() O(1) 笔记 emplace_back() 和 push_back() 的区别\n不废话看代码：\nclass A { private: int _count; public: A(int count): _count(count){ cout \u0026lt;\u0026lt; \u0026#34;default\u0026#34; \u0026lt;\u0026lt; endl; } A(const A\u0026amp; a): _count(a._count) { cout \u0026lt;\u0026lt; \u0026#34;copy\u0026#34; \u0026lt;\u0026lt; endl; } A(A\u0026amp;\u0026amp; a): _count(a._count) { cout \u0026lt;\u0026lt; \u0026#34;move\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { vector\u0026lt;A\u0026gt; vec; vec.reserve(100); // 相同点： A a(1); // 传入左值 vec.push_back(a); //copy vec.emplace_back(a); //copy A b(1); A c(1); // 传入右值 vec.push_back(std::move(b)); //move vec.emplace_back(std::move(c)); //move // 不同点： // 传入参数 vec.push_back(1); //default move vec.emplace_back(1); //default } resize() 和 assign() 的区别\nresize(): 改变vector的大小，如果新的大小比原来的大，则新的元素用默认值填充，如果新的大小比原来的小，则删除多余的元素\nassign(): 为vector赋值，会清空原来的元素，然后用新的元素填充\narray#include \u0026lt;iostream\u0026gt; #include \u0026lt;array\u0026gt; using namespace std; // array使用示例 int main() { array\u0026lt;int, 5\u0026gt; arr = {10, 20, 30, 40, 50}; // 获取array的大小 cout \u0026lt;\u0026lt; arr.size() \u0026lt;\u0026lt; endl; // 访问指定位置的元素，复杂度为O(1) arr[2] = 100; cout \u0026lt;\u0026lt; arr[2] \u0026lt;\u0026lt; endl; // 获取array的第一个元素和最后一个元素，复杂度为O(1) cout \u0026lt;\u0026lt; arr.front() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; arr.back() \u0026lt;\u0026lt; endl; // 直接获取array的数据指针 int *p = arr.data(); cout \u0026lt;\u0026lt; *(p + 2) \u0026lt;\u0026lt; endl; } array 常用的成员函数：\n元素访问\nfront(): 返回第一个元素\nback(): 返回最后一个元素\nat(): 访问指定位置的元素，会检查索引是否越界\ndata(): 直接获取array的数据指针\n迭代器\nbegin(): 返回指向第一个元素的迭代器，\nend(): 返回指向最后一个元素的迭代器\nrbegin(): 返回指向最后一个元素的逆向迭代器\nrend(): 返回指向第一个元素的逆向迭代器\ncbegin()、cend()、crbegin()、crend(): 返回常量迭代器，不允许修改元素\n容量\nsize(): 返回array中元素的个数\nempty(): 判断array是否为空\nmax_size(): 与 size() 相同，只是为了与其他容器保持一致\n容器操作\nfill(): 用指定的值填充array\nswap(): 交换两个array的元素\narray 和 vector 的区别 array 是 静态数组，大小是 固定 的，不支持插入和删除操作，支持随机访问，元素在 栈上 分配。\nvector 是 动态数组，大小是 可变 的，支持插入和删除操作，支持随机访问，元素在 堆上 分配。\nint main() { std::array\u0026lt;int, 100\u0026gt; arr = {1,2,3}; cout \u0026lt;\u0026lt; \u0026amp;arr \u0026lt;\u0026lt; endl; // 栈上：0x7fff92971320 cout \u0026lt;\u0026lt; arr.data() \u0026lt;\u0026lt; endl; //栈上：0x7fff92971320 vector\u0026lt;int\u0026gt; vec {1, 2, 3}; cout \u0026lt;\u0026lt; \u0026amp;vec \u0026lt;\u0026lt; endl; // 栈上：0x7fff92971320 cout \u0026lt;\u0026lt; vec.data() \u0026lt;\u0026lt; endl; // 堆上：0x7ad2c0 } array 的时间复杂度 操作 时间复杂度 at() O(1) front()、back() O(1) deque#include\u0026lt;iostream\u0026gt; #include\u0026lt;deque\u0026gt; using namespace std; // deque使用示例 int main() { deque\u0026lt;int\u0026gt; deq(10, 1); // 初始化一个大小为10，元素值为0的deque // 在deque的尾部和头部插入元素：复杂度为O(1) deq.push_back(99); deq.push_back(99); deq.push_front(100); // 在deque的尾部和头部删除元素：复杂度为O(1) deq.pop_back(); deq.pop_front(); // 随机插入和删除元素：复杂度为O(n) deq.insert(deq.begin() + 1, 3); deq.erase(deq.begin() + 1); // deque的大小 cout \u0026lt;\u0026lt; deq.size() \u0026lt;\u0026lt; endl; // 获取deque的第一个元素和最后一个元素 cout \u0026lt;\u0026lt; deq.front() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; deq.back() \u0026lt;\u0026lt; endl; // 访问指定位置的元素 cout \u0026lt;\u0026lt; deq[5] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; deq.at(5) \u0026lt;\u0026lt; endl; // at函数会检查索引是否越界，更安全 } deque 常用的成员函数：\n元素访问\nfront(): 返回第一个元素\nback(): 返回最后一个元素\nat(): 访问指定位置的元素，会检查索引是否越界\n迭代器\nbegin()、end()、rbegin()、rend()、cbegin()、cend()、crbegin()、crend(): 与 vector 相同 容量\nsize(): 返回deque中元素的个数\nmax_size(): 返回当前程序中的deque最大可以容纳的元素个数，通常是一个很大的值\nempty(): 判断deque是否为空\n元素修改\npush_back(): 尾部插入元素\nemplace_back(): 原地构造并插入元素到尾部\npop_back(): 尾部删除元素\nappend_range(): 尾部插入元素一个范围内的元素（C++23）\npush_front(): 头部插入元素\nemplace_front(): 原地构造并插入元素到头部\npop_front(): 头部删除元素\nprepend_range(): 头部插入元素一个范围内的元素（C++23）\ninsert(): 插入元素\nemplace(): 原地构造并插入元素\nerase(): 删除元素\nclear(): 清空deque\nresize(): 改变deque的大小\nswap(): 交换两个deque的元素\ndeque 的底层实现deque 的底层实现是由多段 等长的连续空间 组成，各段不一定连续，它们被一块 map 数组所控制，map 数组的每个元素都是一个指针，指向一段连续空间。\n由于 deque 这种特殊的结构，deque 的迭代器不是普通的指针，而是一个复杂的结构体，它包含了四个指针，分别指向当前段的当前元素、当前段头、当前段尾、当前段的 map 指针。\ndeque 的时间复杂度 操作 时间复杂度 push_back()、pop_back()、push_front()、pop_front() O(1) insert()、erase() O(n) at() O(1) list#include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; // list使用示例 int main() { list\u0026lt;int\u0026gt; ls = {1, 2, 3, 4, 5}; // 在list的头部和尾部插入元素：复杂度为O(1) ls.push_back(6); ls.push_front(0); // 在list的头部和尾部删除元素：复杂度为O(1) ls.pop_back(); ls.pop_front(); // 随机插入和删除元素：复杂度为O(1) ls.insert(ls.begin(), 3); ls.erase(ls.begin()); // list的大小 cout \u0026lt;\u0026lt; ls.size() \u0026lt;\u0026lt; endl; // 获取list的第一个元素和最后一个元素 cout \u0026lt;\u0026lt; ls.front() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ls.back() \u0026lt;\u0026lt; endl; // 访问指定位置的元素，使用迭代器 list\u0026lt;int\u0026gt;::iterator it = ls.begin(); advance(it, 2); // advance函数用于移动迭代器 cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } list 常用的成员函数：\n元素访问\nfront(): 返回第一个元素\nback(): 返回最后一个元素\nlist 不支持随机访问，因此没有 at() 函数，如果需要访问指定位置的元素，需要使用迭代器\n迭代器\nbegin()、end()、rbegin()、rend()、cbegin()、cend()、crbegin()、crend(): 与 vector 相同 容量\nsize(): 返回list中元素的个数\nmax_size(): 返回当前程序中的list最大可以容纳的元素个数，通常是一个很大的值\nempty(): 判断list是否为空\n元素修改\npush_back(): 尾部插入元素\nemplace_back(): 原地构造并插入元素到尾部\npop_back(): 尾部删除元素\npush_front(): 头部插入元素\nemplace_front(): 原地构造并插入元素到头部\npop_front(): 头部删除元素\ninsert(): 插入元素\nemplace(): 原地构造并插入元素\nerase(): 删除元素\nclear(): 清空list\nresize(): 改变list的大小\nswap(): 交换两个list的元素\n容器操作\nsplice(): 将一个 list 中的元素插入到另一个 list 中\nmerge(): 合并两个有序 list\nremove(): 删除 list 中值为指定值的元素，不是按照迭代器删除\nremove_if(): 删除 list 中满足条件的元素\nreverse(): 反转 list\nunique(): 删除 list 中相邻的重复元素\nsort(): 对 list 进行排序\nlist 的时间复杂度list 是一个插入删除效率高的容器，但是访问效率低；vector 是一个访问效率高的容器，但是插入删除效率低；\n操作 时间复杂度 push_back()、pop_back()、push_front()、pop_front() O(1) insert()、erase() O(1) front()、back() O(1) forward_listforward_list 是一个单向链表，它只支持单向遍历，不支持双向遍历，因此没有 back() 函数。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;forward_list\u0026gt; using namespace std; // forward_list使用示例 int main() { forward_list\u0026lt;int\u0026gt; fl = {1, 2, 3, 4, 5}; // 在forward_list的头部插入元素：复杂度为O(1) fl.push_front(0); // 在forward_list的头部删除元素：复杂度为O(1) fl.pop_front(); // 随机插入和删除元素：复杂度为O(1) fl.insert_after(fl.before_begin(), 3); fl.erase_after(fl.before_begin()); // forward_list的大小 cout \u0026lt;\u0026lt; fl.size() \u0026lt;\u0026lt; endl; // 获取forward_list的第一个元素 cout \u0026lt;\u0026lt; fl.front() \u0026lt;\u0026lt; endl; // 访问指定位置的元素，使用迭代器 forward_list\u0026lt;int\u0026gt;::iterator it = fl.begin(); advance(it, 2); // advance函数用于移动迭代器 cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } forward_list 常用的成员函数：\n元素访问\nfront(): 返回第一个元素 迭代器\nbegin(): 返回指向第一个元素的迭代器\nend(): 返回指向最后一个元素的迭代器\nbefore_begin(): 返回指向第一个元素之前的迭代器，这是一个特殊的迭代器，用于插入到第一个元素的位置\ncbegin()、cend()、cbefore_begin(): 返回常量迭代器，不允许修改元素\nforward_list 不支持反向迭代器，因此没有 rbegin()、rend()、crbegin()、crend() 函数\n容量\nempty(): 判断forward_list是否为空\nmax_size(): 返回当前程序中的forward_list最大可以容纳的元素个数，通常是一个很大的值\n元素修改\npush_front()、emplace_front(): 头部插入元素\npop_front(): 头部删除元素\ninsert_after()、emplace_after(): 插入元素\nerase_after(): 删除元素\nclear(): 清空forward_list\nresize(): 改变forward_list的大小\ninsert_range_after(): 插入元素一个范围内的元素（C++23）\nprepend_range(): 头部插入元素一个范围内的元素（C++23）\nswap(): 交换两个forward_list的元素\n容器操作\nsplice_after(): 将一个 forward_list 中的元素插入到另一个 forward_list 中\nmerge(): 合并两个有序 forward_list\nremove()、remove_if(): 删除 forward_list 中满足条件的元素\nreverse(): 反转 forward_list\nunique(): 删除 forward_list 中相邻的重复元素\nsort(): 对 forward_list 进行排序\nforward_list 的时间复杂度forward_list 是一个插入删除效率高的容器，但是访问效率低，但相比于 list，forward_list 的空间效率更高，性能开销更小。\n操作 时间复杂度 push_front()、pop_front() O(1) insert_after()、erase_after() O(1) front() O(1) set#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; // set使用示例 int main() { set\u0026lt;int\u0026gt; s = {1, 2, 3, 4, 5}; // 插入元素：复杂度为O(logn) s.insert(6); // 删除元素：复杂度为O(logn) s.erase(3); // 查找元素：复杂度为O(logn) auto it = s.find(4); if (it != s.end()) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } // set的大小 cout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; // 判断set是否为空 cout \u0026lt;\u0026lt; s.empty() \u0026lt;\u0026lt; endl; } set 常用的成员函数：\n迭代器\nbegin()、end()、rbegin()、rend()、cbegin()、cend()、crbegin()、crend(): 该有的都有 容量\nsize()、max_size()、empty(): 该有的都有 元素修改\ninsert()、emplace()、insert_range(): 插入元素\nemplace_hint(): 通过迭代器提示插入元素，可以提高插入效率\nerase(): 删除元素\nclear(): 清空set\nswap(): 交换两个set的元素\nextract(): 提取并删除元素（C++17）\nmerge(): 合并两个有序 set（C++17）\n查找\nfind(): 查找元素\ncount(): 统计元素个数\nlower_bound(): 返回第一个不小于指定值的元素的迭代器\nupper_bound(): 返回第一个大于指定值的元素的迭代器\nequal_range(): 返回指定值的区间\ncontains(): 判断是否包含指定值（C++20）\nset、map、multi_set、multi_map 的特点 set：有序集合，不允许重复元素，插入元素时会自动排序\nmap：有序映射，不允许重复键，插入元素时根据键自动排序\nmulti_set：有序多重集合，允许重复元素，插入元素时会自动排序\nmulti_map：有序多重映射，允许重复键，插入元素时根据键自动排序\nset 的底层实现set、map、multi_set、multi_map 的底层实现是 红黑树，它是一种自平衡的二叉查找树，可以保证插入、删除、查找的时间复杂度都是 O(logn)。至于为什么不选择 AVL 树，是因为红黑树的旋转操作比 AVL 树的旋转操作更少，AVL 树的平衡策略太严格了。综合来看，红黑树是一种性能和平衡性都比较好的二叉查找树。\nmultiset 的底层实现multiset 的底层实现也是红黑树，但是 multiset 允许重复元素，因此\nset 的时间复杂度 操作 时间复杂度 insert()、erase() O(logn) find() O(logn) unordered_set使用方法和 set 类似，只是 unordered_set 是无序集合，底层实现是 哈希表，插入、删除、查找的时间复杂度都是 O(1)。是一种空间换时间的策略。\nunordered_set 常用的成员函数：\n迭代器\nbegin()、end()、cbegin()、cend(): unordered_set 不支持反向迭代器 容量\nsize()、max_size()、empty(): 该有的都有 元素修改\n和 set 一致 查找\n和 set 一致，但是 unordered_set 不支持 lower_bound()、upper_bound()、equal_range() 函数 unordered_set 的底层实现unordered_set、unordered_map、unordered_multiset、unordered_multimap 的底层实现是 哈希表，哈希表是一种以键值对形式存储数据的数据结构，通过哈希函数将键映射到哈希表中的一个位置，然后将值存储在该位置。\n哈希表的优点是插入、删除、查找的时间复杂度都是 O(1)，但是哈希表的缺点是空间利用率低，哈希冲突的处理比较复杂。\nunordered_set 的时间复杂度 操作 时间复杂度 insert()、erase() O(1) find() O(1) map不想写了\n笔记 map中[]和find的区别\n[]：返回的是该 key 对应的 value，如果 key 不存在，会插入一个键值对，值为默认值\nfind()：返回的是该 key 的迭代器，如果 key 不存在，返回 end() 迭代器\nunordered_map不想写了\nstackstack 和 queue 是容器适配器，它们是在底层容器的基础上提供了一些操作，使得底层容器的操作更加方便。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; // stack使用示例 int main() { stack\u0026lt;int\u0026gt; s; // 入栈 s.push(1); s.push(2); s.push(3); // 出栈 s.pop(); // 获取栈顶元素 cout \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; // 判断栈是否为空 cout \u0026lt;\u0026lt; s.empty() \u0026lt;\u0026lt; endl; // 获取栈的大小 cout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; } stack 常用的成员函数：\n元素访问\ntop(): 返回栈顶元素 容量\nsize(): 返回栈中元素的个数\nempty(): 判断栈是否为空\n元素修改\npush(): 入栈\nemplace(): 原地构造并入栈\npop(): 出栈\nswap(): 交换两个 stack 的元素\nemplace(): 原地构造并入栈\nstack 的底层实现stack 的底层实现默认是由 deque 实现的，deque 是一个双端队列，支持在队头和队尾插入和删除元素，因此 stack 也支持在栈顶插入和删除元素。\nstack 的时间复杂度 操作 时间复杂度 push()、pop()、top() O(1) queue#include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; // queue使用示例 int main() { queue\u0026lt;int\u0026gt; q; // 入队 q.push(1); q.push(2); q.push(3); // 出队 q.pop(); // 获取队头元素 cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; endl; // 获取队尾元素 cout \u0026lt;\u0026lt; q.back() \u0026lt;\u0026lt; endl; // 判断队列是否为空 cout \u0026lt;\u0026lt; q.empty() \u0026lt;\u0026lt; endl; // 获取队列的大小 cout \u0026lt;\u0026lt; q.size() \u0026lt;\u0026lt; endl; } queue 常用的成员函数：\n元素访问\nfront(): 返回队头元素\nback(): 返回队尾元素\n容量\nsize(): 返回队列中元素的个数\nempty(): 判断队列是否为空\n元素修改\npush(): 入队\nemplace(): 原地构造并入队\npop(): 出队\nswap(): 交换两个 queue 的元素\n迭代器STL 常用迭代器操作函数：\nadvance()：移动迭代器\ndistance()：计算两个迭代器之间的距离\nnext()：返回迭代器的下一个或下 n 个位置\nprev()：返回迭代器的上一个或上 n 个位置\nbegin()：返回指向第一个元素的迭代器\nend()：返回指向最后一个元素的迭代器\nrbegin()：返回指向最后一个元素的逆向迭代器\nrend()：返回指向第一个元素的逆向迭代器\ncbegin()、cend()、crbegin()、crend()：返回常量迭代器，不允许修改元素\n迭代器底层实现迭代器实际上是一种泛化的指针，它是一个类，重载了 *、-\u0026gt;、++、--、==、!= 等操作符，使得迭代器可以像指针一样操作容器中的元素。\n迭代器和反向迭代器的关系\n","permalink":"https://blog.cassdev.com/posts/c++-stl-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch2 id=\"常用容器\"\u003e常用容器\u003c/h2\u003e\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e序列容器\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003evector\u003c/code\u003e: 动态数组，随机插入/删除 \u003ccode\u003eO(n)\u003c/code\u003e，随机访问 \u003ccode\u003eO(1)\u003c/code\u003e，尾插 \u003ccode\u003eO(1)\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003earray\u003c/code\u003e: 静态数组，不支持插入/删除，随机访问 \u003ccode\u003eO(1)\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003edeque\u003c/code\u003e: 双端队列，头尾插入/删除 \u003ccode\u003eO(1)\u003c/code\u003e，随机访问 \u003ccode\u003eO(1)\u003c/code\u003e，中间插入/删除 \u003ccode\u003eO(n)\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003elist\u003c/code\u003e: 双向链表，插入/删除 \u003ccode\u003eO(1)\u003c/code\u003e，不支持随机访问\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eforward_list\u003c/code\u003e: 单向链表，插入/删除 \u003ccode\u003eO(1)\u003c/code\u003e，不支持随机访问\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e关联容器（底层实现为 \u003cstrong\u003e红黑树\u003c/strong\u003e ）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eset\u003c/code\u003e: 有序集合，插入/删除/查找 \u003ccode\u003eO(logn)\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003emap\u003c/code\u003e: 有序映射，插入/删除/查找 \u003ccode\u003eO(logn)\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003emultiset\u003c/code\u003e: 有序多重集合，插入/删除/查找 \u003ccode\u003eO(logn)\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003emultimap\u003c/code\u003e: 有序多重映射，插入/删除/查找 \u003ccode\u003eO(logn)\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e无序容器（底层实现为 \u003cstrong\u003e哈希表\u003c/strong\u003e ）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eunordered_set\u003c/code\u003e: 无序集合，插入/删除/查找 \u003ccode\u003eO(1)\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eunordered_map\u003c/code\u003e: 无序映射，插入/删除/查找 \u003ccode\u003eO(1)\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eunordered_multiset\u003c/code\u003e: 无序多重集合，插入/删除/查找 \u003ccode\u003eO(1)\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eunordered_multimap\u003c/code\u003e: 无序多重映射，插入/删除/查找 \u003ccode\u003eO(1)\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e容器适配器\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003estack\u003c/code\u003e: 栈，后进先出，只能在栈顶插入/删除元素\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003equeue\u003c/code\u003e: 队列，先进先出，只能在队尾插入，在队头删除元素\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003epriority_queue\u003c/code\u003e: 优先队列，元素按照一定规则排序，每次取出的是最大/最小元素，底层实现为堆\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"vector\"\u003evector\u003c/h2\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"k\"\u003enamespace\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// vector使用示例\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evec\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 尾部插入元素：复杂度为O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epush_back\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 尾部删除元素：复杂度为O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epop_back\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 随机插入和删除元素：复杂度为O(n)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003einsert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eerase\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// vector的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 获取vector的容量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecapacity\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 判断vector是否为空\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eempty\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 获取vector的第一个元素和最后一个元素\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efront\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eback\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 访问指定位置的元素\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eat\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// at函数会检查索引是否越界，更安全\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evec2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e7\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e9\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eswap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evec2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 交换两个vector的元素\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 清空vector\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003evec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eclear\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003evector 常用的成员函数：\u003c/p\u003e","title":"C++ STL 常用容器和迭代器学习笔记"},{"content":"对象MyClass obj; obj.fun(); obj.count = 10; 对象是类的实例，占据实际的内存空间，可以调用类的成员函数和访问类的成员变量。\n对象大小 = 成员变量大小 + 对齐填充\n指针MyClass *p = new MyClass; p-\u0026gt;fun(); p-\u0026gt;count = 10; 指针是一个变量，存储对象的地址，可以通过指针访问对象的成员函数和成员变量。\n指针大小 = 4 字节（32 位系统）或 8 字节（64 位系统）\n对象和指针的区别 内存管理 对象：内存分配和释放通常是自动的（除非使用动态分配）。 指针：指向的内存需要手动管理，尤其是动态分配的内存。 访问方式： 对象：直接访问成员。 指针：通过解引用访问成员（使用 -\u0026gt; 操作符）。 生命周期： 对象：由作用域决定，局部对象在离开作用域时自动销毁。 指针：生命周期由程序员控制，指针可以指向任何作用域的变量。 ","permalink":"https://blog.cassdev.com/posts/c++-%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch2 id=\"对象\"\u003e对象\u003c/h2\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eMyClass\u003c/span\u003e \u003cspan class=\"n\"\u003eobj\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eobj\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efun\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eobj\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e对象是类的实例，占据实际的内存空间，可以调用类的成员函数和访问类的成员变量。\u003c/p\u003e\n\u003cp\u003e对象大小 = 成员变量大小 + 对齐填充\u003c/p\u003e\n\u003ch2 id=\"指针\"\u003e指针\u003c/h2\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eMyClass\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eMyClass\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efun\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e指针是一个变量，存储对象的地址，可以通过指针访问对象的成员函数和成员变量。\u003c/p\u003e\n\u003cp\u003e指针大小 = 4 字节（32 位系统）或 8 字节（64 位系统）\u003c/p\u003e\n\u003ch2 id=\"对象和指针的区别\"\u003e对象和指针的区别\u003c/h2\u003e\u003col\u003e\n\u003cli\u003e内存管理\n\u003cul\u003e\n\u003cli\u003e对象：内存分配和释放通常是自动的（除非使用动态分配）。\u003c/li\u003e\n\u003cli\u003e指针：指向的内存需要手动管理，尤其是动态分配的内存。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e访问方式：\n\u003cul\u003e\n\u003cli\u003e对象：直接访问成员。\u003c/li\u003e\n\u003cli\u003e指针：通过解引用访问成员（使用 -\u0026gt; 操作符）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e生命周期：\n\u003cul\u003e\n\u003cli\u003e对象：由作用域决定，局部对象在离开作用域时自动销毁。\u003c/li\u003e\n\u003cli\u003e指针：生命周期由程序员控制，指针可以指向任何作用域的变量。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"C++ 对象和指针的区别学习笔记"},{"content":"C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。\nC++ 的多态性主要有两种实现方式：静态多态和动态多态。\n静态多态：通过函数重载和模板实现。\n动态多态：通过虚函数实现。\n静态多态函数重载函数重载是指在同一个作用域内，可以定义 多个名称相同 但 参数列表不同 的函数。注意，不能用 返回值类型 来区分重载函数。\nint add(int a, int b) { return a + b; } double add(double a, double b) { return a + b; } double add(double a, double b, double c) { return a + b + c; } 笔记 编译过程\n预处理：将源文件中的头文件展开，处理宏定义，删除注释等；\n对应命令：g++ -E main.cpp -o main.i；\n编译：进行词法分析、语法分析、语义分析，接着 生成汇编代码 ；\n词法分析：分析源代码中的关键字、标识符、常量等是否合法；\n语法分析：分析源代码中的语法结构是否合法；\n语义分析：分析源代码中的语义是否合法；\n对应命令：g++ -S main.i -o main.s；\n汇编：将 汇编代码 转换为 目标文件 ，即将汇编代码翻译成机器指令；\n对应命令：g++ -c main.s -o main.o；\n链接：将 目标文件 和 库文件 链接成 可执行文件 ；\n静态链接：将库文件的代码和目标文件的代码合并成一个可执行文件；\n动态链接：将库文件的代码和目标文件的代码分开，运行时再动态链接；\n对应命令：g++ main.o -o main。\n函数重载的原理是通过 函数名修饰 实现的，即在编译阶段，编译器会根据函数名和参数列表生成一个唯一的函数名。\n可以通过 objdump -t main.o 命令查看函数名修饰后的函数名。一般函数名格式为 _ZN + 类名长度 + 类名 + 函数名长度 + 函数名 + E + 参数类型首字母。\nclass A { public: void func(int a) { // 函数名修饰后：_ZN1A4funcEi std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; } void func(double a, double b) { // 函数名修饰后：_ZN1A4funcEdd std::cout \u0026lt;\u0026lt; \u0026#34;double: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; } }; int main() { // ... } 模板模板也是一种静态多态。\n动态多态虚函数C++ 的多态性是通过虚函数实现的，虚函数是在基类中声明的，子类可以重写基类的虚函数，从而实现 基类指针指向子类对象 ，调用子类对象的成员函数。\n虚函数表虚函数表（vtable）是一个存储 虚函数地址 的一维数组，每个类都有一个虚函数表，虚函数表中存储的是虚函数的地址。\n虚函数表的创建时机是在 编译阶段 ，存放于 只读数据段（.rodata） 中，是一个全局变量，每个类的虚函数表都是唯一的，这个类的所有实例都会共享这个虚函数表。\n虚函数表指针虚函数表指针（vptr）是一个指向虚函数表的指针，是一个 隐藏的成员变量 ，存在于每个类的对象中，指向这个类的虚函数表。\n虚函数表指针是在构造函数中初始化的，指向这个类的虚函数表，当调用虚函数时，会通过这个虚函数表指针找到虚函数表，再找到虚函数的地址，最后调用虚函数。\n编译器任务如果一个类中有虚函数（用 virtual 关键字修饰的函数）：\n那么编译器就会为这个类生成一个 vtable ，存放这个类的虚函数地址。\n编译器还会在这个类的对象中添加一个 vptr，用于指向这个类的 vtable。\n编译器还会在这个类的 构造函数 插入初始化 vptr 的代码，指向这个类的 vtable。\n编译器还会在这个类的 析构函数 插入清空 vptr 的代码。\n对象实例的内存布局如下：\n继承下如果一个类继承了另一个类，在编译阶段，子类的 vtable 赋值流程如下：\n先将父类的 vtable 复制到子类的 vtable 中。\n再查找子类中 新的虚函数 ，如果有新的虚函数，就将新的虚函数地址 添加 到子类的 vtable 中。\n最后查找子类中 重写的虚函数 ，如果有重写的虚函数，就将重写的虚函数地址 覆盖 父类的虚函数地址。\n因此如果子类中没有新的虚函数和重写的虚函数，那么子类的 vtable 就和父类的 vtable 一样。\n","permalink":"https://blog.cassdev.com/posts/c++-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003eC++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。\u003c/p\u003e\n\u003cp\u003eC++ 的多态性主要有两种实现方式：静态多态和动态多态。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e静态多态：通过函数重载和模板实现。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e动态多态：通过虚函数实现。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"静态多态\"\u003e静态多态\u003c/h2\u003e\u003ch3 id=\"函数重载\"\u003e函数重载\u003c/h3\u003e\u003cp\u003e函数重载是指在同一个作用域内，可以定义 \u003cstrong\u003e多个名称相同\u003c/strong\u003e 但 \u003cstrong\u003e参数列表不同\u003c/strong\u003e 的函数。注意，不能用 \u003cstrong\u003e返回值类型\u003c/strong\u003e 来区分重载函数。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003eadd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"nf\"\u003eadd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"nf\"\u003eadd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n            \u003clink rel=\"stylesheet\" href=\"/css/vendors/admonitions.4fd9a0b8ec8899f2ca952048d255a569f433f77dfb3f52f5bc87e7d65cdce449.css\" integrity=\"sha256-T9mguOyImfLKlSBI0lWlafQz9337P1L1vIfn1lzc5Ek=\" crossorigin=\"anonymous\"\u003e\n    \u003cdiv class=\"admonition note\"\u003e\n      \u003cdiv class=\"admonition-header\"\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 576 512\"\u003e\u003cpath d=\"M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 125.7-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9 0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6 0zM311.9 417L441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z\"/\u003e\u003c/svg\u003e\n        \u003cspan\u003e笔记\u003c/span\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"admonition-content\"\u003e\n        \u003cp\u003e\u003cstrong\u003e编译过程\u003c/strong\u003e\u003c/p\u003e","title":"C++ 多态学习笔记"},{"content":"互联网发展至今，HTTP 协议已经发展了多个版本，分别为 HTTP/1.0、HTTP/1.1、HTTP/2.0、HTTP/3.0，本文将对这几个版本的变化进行学习笔记。\nHTTP/1.0HTTP/1.0 是最早的 HTTP 协议版本，它的特点是：\n每次请求都会建立一个新的 TCP 连接，请求结束后立即断开连接。\n每个请求都会包含完整的请求头和请求体。\n不支持持久连接，每次请求都需要重新建立连接。\n不支持管道化，即同一个连接中不能同时发送多个请求。\nHTTP/1.1HTTP/1.1 是对 HTTP/1.0 的改进，它的特点是：\n支持持久连接（Keep-Alive），即同一个连接可以发送多个请求。\n支持管道化，即同一个连接中可以同时发送多个请求。但是，由于 HTTP/1.1 中的管道化存在队头阻塞问题，所以很少被使用。默认为关闭状态，并且大多数浏览器也不支持。 所以我们认为 HTTP/1.1 不支持管道化 。\nHTTP/1.1 的缺点：\n队头阻塞问题：如果一个请求响应时间过长，那么后面的请求就会被阻塞。\n明文传输：HTTP/1.1 的数据传输是纯文本且未加密的，容易被窃听。比如状态码 200 会被分为 2、0、0 三个字节传输。这点会在 HTTP/2.0 中得到改进。\n头部冗余：每次请求都需要携带完整的请求头，头部信息冗余。\nHTTPS在讲述 HTTP/2.0 之前，我们先来了解一下 HTTPS。\nHTTPS 是在 HTTP 的基础上加入了 SSL/TLS 加密层，使得数据传输更加安全。HTTPS 的特点是：\n数据加密：HTTPS 使用 SSL/TLS 加密传输数据，保证数据传输的安全性。\n身份认证：HTTPS 使用证书机制对服务器和客户端进行身份认证，防止中间人攻击。\n数据完整性：HTTPS 使用数字签名对数据进行完整性校验，防止数据被篡改。\n加密方式：对称加密、非对称加密、数字签名。\n通信前使用非对称加密协商对称加密的密钥，通信过程使用对称加密传输数据，保证数据传输的安全性。\nHTTP/2.0HTTP/2.0 是对 HTTP/1.1 的重大升级，它的特点是：\n头部压缩：HTTP/2.0 使用 HPACK 算法对头部进行压缩，如果请求头中包含相同的字段，只需要发送一次，后续请求只需要发送索引，接着从静态表或动态表中获取对应的值。解决了 HTTP/1.1 中头部冗余的问题。\n二进制传输：HTTP/2.0 使用二进制格式传输数据，而不是 HTTP/1.x 的文本格式。如状态码 200 只需要传输一个字节，但不是直接将 200 表示为二进制，而是通过 HPACK 算法压缩后的索引。HTTP/2.0 + HTTPS 解决了 HTTP/1.1 明文传输的问题。\n多路复用（并发传输）：HTTP/2.0 支持多路复用，即在一个连接上可以同时发送多个请求和响应。HTTP/2.0 引入了 Stream 流的概念，每个 Stream 都有一个唯一的标识符，一个连接上可以有多个 Stream。一定程度上缓解了 HTTP/1.1 的队头阻塞问题。\n服务端主动推送：HTTP/2.0 支持服务端主动推送资源，即在客户端请求一个资源时，服务端可以主动推送相关资源给客户端，减少客户端请求次数。\nHTTP/2.0 的缺点：\n队头阻塞问题：虽然 HTTP/2.0 引入了多路复用，但是由于 TCP 的特性，依然存在队头阻塞问题。因为 TCP 是一个有序的传输协议，如果一个数据包丢失，后续的数据包需要等待重传，导致后续数据包被阻塞。\nTCP 与 TLS 握手延迟：TCP 建立连接需要三次握手，TLS 握手需要四次握手，这些握手过程会增加延迟。合并之后仍然需要 3 个 RTT 的时延。\n网络迁移需要重新建立连接：一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WiFi。 HTTP/3.0QUIC在讲述 HTTP/3.0 之前，我们先来了解一下 QUIC。\nQUIC 是基于 UDP 的传输协议，由 Google 开发，用于替代 TCP。QUIC 是在应用层，也就是用户空间实现的协议，相比在内核实现的 TCP 协议，QUIC 协议不再僵硬，可以十分灵活的进行设置。\nQUIC 的特点是：\n无队头阻塞：QUIC 使用多路复用，每个数据流独立，不会相互影响。相比于 HTTP/2.0 基于 TCP 的多路复用，由于 UDP 是无序传输的，所以 QUIC 不会出现队头阻塞问题。\n更快的握手：QUIC 优化了建立连接的握手过程，且由于 QUIC 内部包含了 TLS，所以 QUIC 仅需要一个握手过程即可建立连接。有效负载数据可以与握手数据一起发送，做到了 0-RTT 的握手。\n连接迁移：QUIC 的连接是由 Connection ID 确定的，这意味着即使 IP 地址或者端口变动了，只要 Connection ID 不变，就可以保持连接。然而这在 TCP 中是做不到的，因为 TCP 一个连接标识是一个四元组：源 IP、源端口、目的 IP、目的端口，只要其中一个发生变化，就需要重新建立连接。\nHTTP/3.0HTTP/3.0 是基于 QUIC 的 HTTP 协议，所以它包含了 QUIC 的所有特点。\n参考 HTTP 常见面试题（文章）\nQUIC 协议详解（文章）\n","permalink":"https://blog.cassdev.com/posts/http-%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003e互联网发展至今，HTTP 协议已经发展了多个版本，分别为 \u003ccode\u003eHTTP/1.0\u003c/code\u003e、\u003ccode\u003eHTTP/1.1\u003c/code\u003e、\u003ccode\u003eHTTP/2.0\u003c/code\u003e、\u003ccode\u003eHTTP/3.0\u003c/code\u003e，本文将对这几个版本的变化进行学习笔记。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"HTTP 协议层\" loading=\"lazy\" src=\"https://s2.loli.net/2024/06/27/6KE87inXyFe4DbW.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"http10\"\u003eHTTP/1.0\u003c/h2\u003e\u003cp\u003eHTTP/1.0 是最早的 HTTP 协议版本，它的特点是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e每次请求都会建立一个新的 TCP 连接，请求结束后立即断开连接。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e每个请求都会包含完整的请求头和请求体。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e不支持持久连接，每次请求都需要重新建立连接。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e不支持管道化，即同一个连接中不能同时发送多个请求。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"http11\"\u003eHTTP/1.1\u003c/h2\u003e\u003cp\u003eHTTP/1.1 是对 HTTP/1.0 的改进，它的特点是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e支持持久连接（Keep-Alive），即同一个连接可以发送多个请求。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e支持管道化，即同一个连接中可以同时发送多个请求。但是，由于 HTTP/1.1 中的管道化存在队头阻塞问题，所以很少被使用。默认为关闭状态，并且大多数浏览器也不支持。 \u003cstrong\u003e所以我们认为 HTTP/1.1 不支持管道化\u003c/strong\u003e 。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHTTP/1.1 的缺点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e队头阻塞问题：如果一个请求响应时间过长，那么后面的请求就会被阻塞。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e明文传输：HTTP/1.1 的数据传输是纯文本且未加密的，容易被窃听。比如状态码 \u003ccode\u003e200\u003c/code\u003e 会被分为 \u003ccode\u003e2\u003c/code\u003e、\u003ccode\u003e0\u003c/code\u003e、\u003ccode\u003e0\u003c/code\u003e 三个字节传输。这点会在 HTTP/2.0 中得到改进。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e头部冗余：每次请求都需要携带完整的请求头，头部信息冗余。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\"\u003e\u003c/p\u003e\n\u003ch2 id=\"https\"\u003eHTTPS\u003c/h2\u003e\u003cp\u003e在讲述 HTTP/2.0 之前，我们先来了解一下 HTTPS。\u003c/p\u003e\n\u003cp\u003eHTTPS 是在 HTTP 的基础上加入了 SSL/TLS 加密层，使得数据传输更加安全。HTTPS 的特点是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e数据加密：HTTPS 使用 SSL/TLS 加密传输数据，保证数据传输的安全性。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e身份认证：HTTPS 使用证书机制对服务器和客户端进行身份认证，防止中间人攻击。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e数据完整性：HTTPS 使用数字签名对数据进行完整性校验，防止数据被篡改。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e加密方式：对称加密、非对称加密、数字签名。\u003c/p\u003e\n\u003cp\u003e通信前使用非对称加密协商对称加密的密钥，通信过程使用对称加密传输数据，保证数据传输的安全性。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"HTTPS\" loading=\"lazy\" src=\"https://s2.loli.net/2024/06/27/wcztbDYBevjP26L.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"http20\"\u003eHTTP/2.0\u003c/h2\u003e\u003cp\u003eHTTP/2.0 是对 HTTP/1.1 的重大升级，它的特点是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e头部压缩：HTTP/2.0 使用 HPACK 算法对头部进行压缩，如果请求头中包含相同的字段，只需要发送一次，后续请求只需要发送索引，接着从静态表或动态表中获取对应的值。解决了 HTTP/1.1 中头部冗余的问题。\u003c/p\u003e","title":"HTTP 协议版本变化学习笔记"},{"content":"TCP 的拥塞控制算法有几种：\nTahoe\nReno\nNewReno\nSACK\nBIC\nCUBIC\nBBR\n笔记 MSS: Maximum Segment Size，最大分段大小。\ncwnd: Congestion Window，拥塞窗口，单位为 MSS。\nssthresh: Slow Start Threshold，慢启动阈值，单位为 MSS。\nRTO: Retransmission TimeOut，重传超时时间。\nTahoeTahoe 只有两种状态：慢启动和拥塞避免。\n慢启动阶段：cwnd = 1; ssthresh = 65535;。\n每次收到一个 ACK，cwnd = cwnd + 1;，所以一个 RTT 内 cwnd 会翻倍，cwnd 呈指数增长。\n拥塞避免阶段：cwnd = cwnd + 1;。\n每次收到一个 ACK，cwnd = cwnd + 1 / cwnd;，所以每个 RTT 内 cwnd 只会增加 1，cwnd 呈线性增长。\n触发事件：RTO 超时 或 3 个冗余 ACK。\n进入慢启动状态，cwnd = 1; ssthresh = cwnd / 2;。\nTahoe 算法还有一个快速重传机制，当收到 3 个冗余 ACK 时，立即重传丢失的数据包。但无论是重传还是超时，都会将 ssthresh 设置为 cwnd / 2，并将 cwnd 设置为 1。反应很激烈，所以效率不高。\nRenoReno 在 Tahoe 的基础上增加了快速恢复机制。\n触发事件：3 个冗余 ACK。\n进入快速恢复状态，ssthresh = cwnd / 2; cwnd = ssthresh + 3;。\n在快速恢复状态下，每收到一个冗余 ACK，cwnd = cwnd + 1，直到收到新的 ACK，证明原来丢失的数据包已经被接收，回到拥塞避免状态，并且将 cwnd 设置为 ssthresh。\n触发事件：RTO 超时。\n和 Tahoe 一样，Reno 在 RTO 超时时，会将 ssthresh 设置为 cwnd / 2，并将 cwnd 设置为 1。\n相较于 Tahoe，Reno 在收到 3 个冗余 ACK 时，不会将 cwnd 设置为 1，而是设置为 ssthresh + 3，这样可以更快地恢复拥塞窗口。\nNewRenoNewReno 在 Reno 的基础上优化了快速恢复机制。在网络中只有一个丢包时，NewReno 算法和 Reno 算法的表现是一样的。但在网络中有多个丢包时，NewReno 算法可以更快地恢复拥塞窗口。\nPACK：Partial ACK，部分 ACK。\nRACK：Recovery ACK，恢复 ACK。\nSACKSACK：Selective Acknowledgment，选择性确认。\nSACK 是一种可选的 TCP 选项，可以在 TCP 连接建立时协商是否使用 SACK。旨在解决 NewReno 一次 RTT 只能恢复一个丢包的问题。\nSACK 在 Reno 的基础上增加了选择确认机制和选择重传机制。\n通过 left_edge 和 right_edge 来标记已经接收到的数据包，当收到冗余 ACK 时，可以根据 SACK 选项来选择重传哪些数据包。\nBICBIC 是一种新的拥塞控制算法，可以更好地适应高速网络。简单来说是使用了二分搜索来寻找最佳拥塞窗口。\nCUBIC优化后的 BIC 算法。\nBBRBBR 是谷歌开发的一种拥塞控制算法，可以更好地适应高速网络和高延迟网络。它不再是基于丢包的拥塞控制算法，而是基于带宽和延迟的拥塞控制算法。\n参考 TCP拥塞控制算法之NewReno和SACK（文章）\n拥塞控制算法（从Tahoe到PCC Vivace）（文章）\n","permalink":"https://blog.cassdev.com/posts/tcp-%E7%9A%84%E5%B8%B8%E8%A7%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003eTCP 的拥塞控制算法有几种：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTahoe\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eReno\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNewReno\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSACK\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBIC\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCUBIC\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBBR\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n            \u003clink rel=\"stylesheet\" href=\"/css/vendors/admonitions.4fd9a0b8ec8899f2ca952048d255a569f433f77dfb3f52f5bc87e7d65cdce449.css\" integrity=\"sha256-T9mguOyImfLKlSBI0lWlafQz9337P1L1vIfn1lzc5Ek=\" crossorigin=\"anonymous\"\u003e\n    \u003cdiv class=\"admonition note\"\u003e\n      \u003cdiv class=\"admonition-header\"\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 576 512\"\u003e\u003cpath d=\"M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 125.7-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9 0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6 0zM311.9 417L441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z\"/\u003e\u003c/svg\u003e\n        \u003cspan\u003e笔记\u003c/span\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"admonition-content\"\u003e\n        \u003cp\u003eMSS: Maximum Segment Size，最大分段大小。\u003c/p\u003e","title":"TCP 的常见拥塞控制算法学习笔记"},{"content":"智能指针简介智能指针是一种 RAII（Resource Acquisition Is Initialization）技术，用于管理动态分配的内存。智能指针的优点是可以自动释放内存，避免内存泄漏。\nC++11 标准引入了三种智能指针：std::unique_ptr、std::shared_ptr 和 std::weak_ptr。\n它们都定义在头文件 \u0026lt;memory\u0026gt; 中。\nunique_ptrunique_ptr 是一种独占所有权的智能指针，它保证同一时间只有一个指针可以指向对象。\nunique_ptr 的创建#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; int main() { // 使用 new 创建 unique_ptr std::unique_ptr\u0026lt;int\u0026gt; up1(new int(10)); std::cout \u0026lt;\u0026lt; *up1 \u0026lt;\u0026lt; std::endl; // 使用裸指针创建 unique_ptr int count = 20; std::unique_ptr\u0026lt;int\u0026gt; up2(\u0026amp;count); std::cout \u0026lt;\u0026lt; *up2 \u0026lt;\u0026lt; std::endl; // 使用 make_unique 创建 unique_ptr auto up2 = std::make_unique\u0026lt;int\u0026gt;(20); std::cout \u0026lt;\u0026lt; *up2 \u0026lt;\u0026lt; std::endl; return 0; } unique_ptr 的拷贝和赋值unique_ptr 不能拷贝，但可以移动。\n#include \u0026lt;iostream\u0026gt; int main() { std::unique_ptr\u0026lt;int\u0026gt; up1(new int(10)); std::unique_ptr\u0026lt;int\u0026gt; up2 = std::move(up1); std::cout \u0026lt;\u0026lt; *up2 \u0026lt;\u0026lt; std::endl; return 0; } unique_ptr 的释放unique_ptr 会在离开作用域时自动释放内存。\n#include \u0026lt;iostream\u0026gt; int main() { std::unique_ptr\u0026lt;int\u0026gt; up1(new int(10)); std::cout \u0026lt;\u0026lt; *up1 \u0026lt;\u0026lt; std::endl; return 0; } unique_ptr 的自定义删除器unique_ptr 支持自定义删除器，可以用于释放动态分配的内存。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; void deleter(int *p) { std::cout \u0026lt;\u0026lt; \u0026#34;delete \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; std::endl; delete p; } int main() { std::unique_ptr\u0026lt;int, decltype(deleter) *\u0026gt; up(new int(10), deleter); std::cout \u0026lt;\u0026lt; *up \u0026lt;\u0026lt; std::endl; return 0; } unique_ptr 作为函数参数当 unique_ptr 作为函数参数时，分为两种情况：\nPass by value（传值）：需要使用 std::move 移动 unique_ptr，调用函数后原来的 unique_ptr 就会失效。\nPass by reference（传引用）：unique_ptr 不会被移动，调用函数后原来的 unique_ptr 仍然有效。如果声明为 const 引用，则不能改变 unique_ptr 的指向（如调用 reset 函数）。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; void foo(std::unique_ptr\u0026lt;int\u0026gt; up) { std::cout \u0026lt;\u0026lt; *up \u0026lt;\u0026lt; std::endl; } void bar(std::unique_ptr\u0026lt;int\u0026gt; \u0026amp;up) { std::cout \u0026lt;\u0026lt; *up \u0026lt;\u0026lt; std::endl; } void baz(const std::unique_ptr\u0026lt;int\u0026gt; \u0026amp;up) { std::cout \u0026lt;\u0026lt; *up \u0026lt;\u0026lt; std::endl; } int main() { auto up = std::make_unique\u0026lt;int\u0026gt;(10); foo(std::move(up)); // up 失效 // std::cout \u0026lt;\u0026lt; *up \u0026lt;\u0026lt; std::endl; // 运行时错误 auto up2 = std::make_unique\u0026lt;int\u0026gt;(20); bar(up2); // up2 仍然有效 std::cout \u0026lt;\u0026lt; *up2 \u0026lt;\u0026lt; std::endl; auto up3 = std::make_unique\u0026lt;int\u0026gt;(30); baz(up3); // up3 仍然有效 std::cout \u0026lt;\u0026lt; *up3 \u0026lt;\u0026lt; std::endl; return 0; } unique_ptr 作为函数返回值unique_ptr 作为函数返回值时，只有一种情况：\nReturn by value（返回值）：需要使用 std::move 移动 unique_ptr，调用函数后原来的 unique_ptr 就会失效。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; std::unique_ptr\u0026lt;int\u0026gt; foo() { return std::make_unique\u0026lt;int\u0026gt;(10); } int main() { auto up = foo(); std::cout \u0026lt;\u0026lt; *up \u0026lt;\u0026lt; std::endl; return 0; } shared_ptrshared_ptr 是一种共享所有权的智能指针，它可以被多个指针共享，当最后一个指针离开作用域时，会自动释放内存。\nshared_ptr 的创建#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; int main() { // 使用 new 创建 shared_ptr std::shared_ptr\u0026lt;int\u0026gt; sp1(new int(10)); std::cout \u0026lt;\u0026lt; *sp1 \u0026lt;\u0026lt; std::endl; // 使用裸指针创建 shared_ptr int count = 20; std::shared_ptr\u0026lt;int\u0026gt; sp2(\u0026amp;count); std::cout \u0026lt;\u0026lt; *sp2 \u0026lt;\u0026lt; std::endl; // 使用 make_shared 创建 shared_ptr auto sp3 = std::make_shared\u0026lt;int\u0026gt;(30); std::cout \u0026lt;\u0026lt; *sp3 \u0026lt;\u0026lt; std::endl; // 拷贝 shared_ptr std::shared_ptr\u0026lt;int\u0026gt; sp4 = sp3; std::cout \u0026lt;\u0026lt; *sp4 \u0026lt;\u0026lt; std::endl; return 0; } shared_ptr 的释放shared_ptr 会在最后一个指针离开作用域时自动释放内存。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; int main() { std::shared_ptr\u0026lt;int\u0026gt; sp1(new int(10)); std::cout \u0026lt;\u0026lt; *sp1 \u0026lt;\u0026lt; std::endl; { std::shared_ptr\u0026lt;int\u0026gt; sp2 = sp1; std::cout \u0026lt;\u0026lt; *sp2 \u0026lt;\u0026lt; std::endl; } // sp2 离开作用域，内存不会被释放 std::cout \u0026lt;\u0026lt; *sp1 \u0026lt;\u0026lt; std::endl; // sp1 仍然有效 return 0; // sp1 离开作用域，内存被释放 } shared_ptr 的自定义删除器shared_ptr 支持自定义删除器，可以用于释放动态分配的内存。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; void deleter(int *p) { std::cout \u0026lt;\u0026lt; \u0026#34;delete \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; std::endl; delete p; } int main() { std::shared_ptr\u0026lt;int\u0026gt; sp(new int(10), deleter); std::cout \u0026lt;\u0026lt; *sp \u0026lt;\u0026lt; std::endl; return 0; } shared_ptr 作为函数参数当 shared_ptr 作为函数参数时，分为两种情况：\nPass by value（传值）：可以直接传递 shared_ptr，函数内部会自动增加引用计数，调用函数后原来的 shared_ptr 仍然有效。\nPass by reference（传引用）：与 unique_ptr 类似，如果声明为 const 引用，则不能改变 shared_ptr 的指向（如调用 reset 函数）。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; void foo(std::shared_ptr\u0026lt;int\u0026gt; sp) { std::cout \u0026lt;\u0026lt; *sp \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; sp.use_count() \u0026lt;\u0026lt; std::endl; } void bar(const std::shared_ptr\u0026lt;int\u0026gt; \u0026amp;sp) { std::cout \u0026lt;\u0026lt; *sp \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; sp.use_count() \u0026lt;\u0026lt; std::endl; } int main() { auto sp = std::make_shared\u0026lt;int\u0026gt;(10); foo(sp); // sp 仍然有效 std::cout \u0026lt;\u0026lt; sp.use_count() \u0026lt;\u0026lt; std::endl; auto sp2 = std::make_shared\u0026lt;int\u0026gt;(20); bar(sp2); // sp2 仍然有效 std::cout \u0026lt;\u0026lt; sp2.use_count() \u0026lt;\u0026lt; std::endl; return 0; } shared_ptr 作为函数返回值与 unique_ptr 类似同理。\nunique_ptr 和 shared_ptr 的转换unique_ptr 能够转换为 shared_ptr，但 shared_ptr 不能转换为 unique_ptr。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; int main() { std::unique_ptr\u0026lt;int\u0026gt; up(new int(10)); std::shared_ptr\u0026lt;int\u0026gt; sp = std::move(up); std::cout \u0026lt;\u0026lt; *sp \u0026lt;\u0026lt; std::endl; return 0; } weak_ptrweak_ptr 是一种弱引用的智能指针，它不会增加引用计数，当最后一个指向对象的 shared_ptr 离开作用域时，即使还有 weak_ptr 指向对象，对象也会被释放。\nweak_ptr 用于解决 shared_ptr 的循环引用问题。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; int main() { std::shared_ptr\u0026lt;int\u0026gt; sp(new int(10)); std::weak_ptr\u0026lt;int\u0026gt; wp = sp; std::cout \u0026lt;\u0026lt; *wp.lock() \u0026lt;\u0026lt; std::endl; // lock() 返回 shared_ptr sp.reset(); if (wp.expired()) { std::cout \u0026lt;\u0026lt; \u0026#34;wp is expired\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 智能指针和管理的对象分别在哪个区域智能指针和管理的对象并在同一个区域，C++ 中的智能指针是在栈上分配的，而管理的对象是在堆上分配的。之所以能够自动释放内存，是因为智能指针在析构时会调用 delete 函数。\n记住，智能指针本身是在 栈上 分配的，而其管理的对象是在 堆上 分配的。\n参考 C++现代实用教程:智能指针（视频） ","permalink":"https://blog.cassdev.com/posts/c++-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch2 id=\"智能指针简介\"\u003e智能指针简介\u003c/h2\u003e\u003cp\u003e智能指针是一种 RAII（Resource Acquisition Is Initialization）技术，用于管理动态分配的内存。智能指针的优点是可以自动释放内存，避免内存泄漏。\u003c/p\u003e\n\u003cp\u003eC++11 标准引入了三种智能指针：\u003ccode\u003estd::unique_ptr\u003c/code\u003e、\u003ccode\u003estd::shared_ptr\u003c/code\u003e 和 \u003ccode\u003estd::weak_ptr\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e它们都定义在头文件 \u003ccode\u003e\u0026lt;memory\u0026gt;\u003c/code\u003e 中。\u003c/p\u003e\n\u003ch2 id=\"unique_ptr\"\u003eunique_ptr\u003c/h2\u003e\u003cp\u003e\u003ccode\u003eunique_ptr\u003c/code\u003e 是一种独占所有权的智能指针，它保证同一时间只有一个指针可以指向对象。\u003c/p\u003e\n\u003ch3 id=\"unique_ptr-的创建\"\u003eunique_ptr 的创建\u003c/h3\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;memory\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 使用 new 创建 unique_ptr\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eunique_ptr\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eup1\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eup1\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 使用裸指针创建 unique_ptr\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecount\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e20\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eunique_ptr\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eup2\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eup2\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 使用 make_unique 创建 unique_ptr\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"n\"\u003eup2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003emake_unique\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e20\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eup2\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"unique_ptr-的拷贝和赋值\"\u003eunique_ptr 的拷贝和赋值\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eunique_ptr\u003c/code\u003e 不能拷贝，但可以移动。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eunique_ptr\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eup1\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eunique_ptr\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eup2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003emove\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eup1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eup2\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"unique_ptr-的释放\"\u003eunique_ptr 的释放\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eunique_ptr\u003c/code\u003e 会在离开作用域时自动释放内存。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eunique_ptr\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eup1\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eup1\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"unique_ptr-的自定义删除器\"\u003eunique_ptr 的自定义删除器\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eunique_ptr\u003c/code\u003e 支持自定义删除器，可以用于释放动态分配的内存。\u003c/p\u003e","title":"C++ 智能指针学习笔记"},{"content":"Redis 采用单线程的原因是因为在 内存中 进行读写操作，CPU不是Redis的性能瓶颈，而是内存和带宽，所以采用单线程可以避免 线程切换和锁的开销。\nRedis 是什么？Redis 是一个开源的内存数据库，它可以存储键值对，支持多种数据结构，如字符串（string）、哈希（hash）、列表（list）、集合（set）、有序集合（zset）等。\nRedis 是不是单线程？实际上，Redis 是多线程的，其内部有以下几个线程：\nredis-server：主线程，负责接收客户端的连接，读取请求，发送响应。\nbio-close-file：负责异步关闭大文件。\nbio-aof-fsync：负责将 AOF 文件异步刷到磁盘。\nbio-lasy-free：负责异步释放大内存。\njemalloc-bg-thread：负责内存碎片整理。\nio-thread：IO 线程，负责 read/write，decode/encode。\n笔记 AOF（Append Only File） 是 Redis 的一种持久化方式，将所有写操作追加到文件末尾，重启时重新执行 AOF 文件中的命令即可恢复数据。实时硬盘操作，不会丢失数据，但是会影响性能。\n除了 AOF，Redis 还有一种持久化方式是 RDB（Redis DataBase） ，它是将内存中的数据快照保存到磁盘上。非实时硬盘操作，可能会丢失数据，但是性能更好。\nRedis 为什么采用单线程？ Redis 不是 CPU 密集型应用，CPU 不是 Redis 的性能瓶颈。\n如果采用多线程，会导致加锁解锁的开销大，CPU 上下文切换开销大。数据库请求量变化大，一会有请求，一会无请求，多线程会在运行和阻塞状态来回切换。\n单线程的 Redis 为什么速度很快？Redis 机制 内存数据库：Redis 是一个内存数据库，内存的读写速度相比于磁盘的读写速度要快很多。\n数据结构高效：Redis 使用了很多高效的数据结构，如哈希表、跳表等。\n使用了 Reactor 模型：Redis 使用了 Reactor 模型，采用了 IO 多路复用技术，可以处理多个客户端请求。采用的是非阻塞 IO，不会因为一个 IO 阻塞导致其他任务无法执行。\nRedis 采用的优化 耗时的操作，另起线程：如 AOF 文件的刷盘操作，Redis 会另起线程异步执行。\n拆分大任务：例如 Dict 的扩容（rehash）操作，Redis 会将其拆分为多个小任务，分批执行。\n不同的对象类型选择不同的数据结构：根据节点数量，Redis 会选择不同的数据结构，以取得空间和时间上的平衡。\n","permalink":"https://blog.cassdev.com/posts/redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E5%A5%BD/","summary":"\u003cp\u003eRedis 采用单线程的原因是因为在 \u003cstrong\u003e内存中\u003c/strong\u003e 进行读写操作，\u003cstrong\u003eCPU不是Redis的性能瓶颈\u003c/strong\u003e，而是内存和带宽，所以采用单线程可以避免 \u003cstrong\u003e线程切换和锁的开销\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"redis-是什么\"\u003eRedis 是什么？\u003c/h2\u003e\u003cp\u003eRedis 是一个开源的内存数据库，它可以存储键值对，支持多种数据结构，如字符串（string）、哈希（hash）、列表（list）、集合（set）、有序集合（zset）等。\u003c/p\u003e\n\u003ch2 id=\"redis-是不是单线程\"\u003eRedis 是不是单线程？\u003c/h2\u003e\u003cp\u003e实际上，Redis 是多线程的，其内部有以下几个线程：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eredis-server\u003c/code\u003e：主线程，负责接收客户端的连接，读取请求，发送响应。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ebio-close-file\u003c/code\u003e：负责异步关闭大文件。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ebio-aof-fsync\u003c/code\u003e：负责将 AOF 文件异步刷到磁盘。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ebio-lasy-free\u003c/code\u003e：负责异步释放大内存。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ejemalloc-bg-thread\u003c/code\u003e：负责内存碎片整理。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eio-thread\u003c/code\u003e：IO 线程，负责 read/write，decode/encode。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n            \u003clink rel=\"stylesheet\" href=\"/css/vendors/admonitions.4fd9a0b8ec8899f2ca952048d255a569f433f77dfb3f52f5bc87e7d65cdce449.css\" integrity=\"sha256-T9mguOyImfLKlSBI0lWlafQz9337P1L1vIfn1lzc5Ek=\" crossorigin=\"anonymous\"\u003e\n    \u003cdiv class=\"admonition note\"\u003e\n      \u003cdiv class=\"admonition-header\"\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 576 512\"\u003e\u003cpath d=\"M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 125.7-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9 0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6 0zM311.9 417L441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z\"/\u003e\u003c/svg\u003e\n        \u003cspan\u003e笔记\u003c/span\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"admonition-content\"\u003e\n        \u003cp\u003e\u003cstrong\u003eAOF（Append Only File）\u003c/strong\u003e 是 Redis 的一种持久化方式，将所有写操作追加到文件末尾，重启时重新执行 AOF 文件中的命令即可恢复数据。实时硬盘操作，不会丢失数据，但是会影响性能。\u003c/p\u003e","title":"Redis 为什么采用单线程，为什么性能好"},{"content":"在学习堆排序之前，我们先来了解一下堆这种数据结构。\n堆的概念堆是一种特殊的树形数据结构，它满足以下性质：\n堆必须是一个 完全二叉树 。 堆序性：堆中任意节点的值总是不大于或不小于其子节点的值。 根据堆序性，我们可以将堆分为两种类型：\n大顶堆：每个节点的值都大于或等于其子节点的值\n小顶堆：每个节点的值都小于或等于其子节点的值\n所以，如果一个完全二叉树的一个节点即大于其父节点，又大于其子节点，那么这个树就不是一个堆。小于同理。\n笔记 完全二叉树的性质\n完全二叉树只允许最后一层的节点可以不是满的 最后一行的节点必须从左到右依次排列，不能有间隔 堆的存储堆通常使用数组来存储，数组中的元素按照 层序遍历 的顺序存储，根节点存储在数组的第一个位置，即 a[0] 。\n对于任意一个节点 a[i] ，它的左子节点存储在 a[2*i+1] ，右子节点存储在 a[2*i+2] 。\n堆的基本操作堆的基本操作有 下沉 和 上浮 两种。\n下沉：将一个节点向下移动，直到满足堆序性。具体操作是将当前节点与其最大（或最小）子节点交换。\n上浮：将一个节点向上移动，直到满足堆序性。具体操作是比较当前节点与其父节点的大小，若不满足堆序性则交换。\n下沉操作假设我们试图构建一个大顶堆，对于如下图中的一个堆，可以发现只有根节点破坏了大顶堆的堆序性。\n我们需要将此节点（破坏了堆序性的节点）进行下沉操作。对于大顶堆的 下沉 操作，是将此节点与其最大子节点进行比较，若小于其最大子节点则进行交换，持续比较、交换，直到此节点大于其子节点或移动到底部为止。\n上浮操作假设我们同样试图构建一个大顶堆，对于如下图中的一个堆，可以发现只有最后一个元素破坏了堆序性。\n我们需要将此节点与其父节点比较，若大于父节点则交换，直到无法上移为止。\n建堆建堆是指将一个无序数组转换为一个堆。有两种方法可以实现建堆，分别是 自顶向下 和 自底向上 。\n自顶向下：对应的操作是 上浮 ，将元素一个一个插入到堆的最后一个位置，然后进行上浮操作。\n自底向上：对应的操作是 下沉 ，先将数组中的元素按照 层序遍历 的顺序存储到一个完全二叉树，然后从最后一个非叶子节点开始，依次进行下沉操作。\n自顶向下建堆时间复杂度为 O(NlogN) 。\n开始遍历，对于每个元素分为两步操作：\n将新元素插入堆的最后一个位置\n对新元素进行上浮操作\n如下图所示，先将元素 3 插入根节点位置，然后插入元素 4 到堆的最后一个位置，然后对元素 4 进行上浮操作。\n元素 4 的上浮操作结束后，接着插入元素 5 到堆的最后一个位置，然后对元素 5 进行上浮操作。\n自底向上建堆时间复杂度为 O(N) ，优于自顶向下建堆法。\n先将数组中的元素按照 层序遍历 的顺序存储到一个完全二叉树中，然后开始遍历，对于每一个元素只有一步操作：\n选取最后一个非叶子节点（最后一个父节点），进行下沉操作。 如下图所示，先数组中的元素按照层序遍历的顺序存储到一个完全二叉树。\n选取最后一个非叶子节点，即节点 5，开始下沉操作。\n接着选取另一个非叶子节点，即节点 4，开始下沉操作。\n优先队列优先队列是一种特殊的队列，它的出队顺序是按照元素的优先级来决定的。我们可以使用堆来实现优先队列。大顶堆可以实现最大优先级队列，小顶堆可以实现最小优先级队列。\n这里以最小优先级队列为例，需要使用堆的下沉操作来实现出队操作，使用堆的上浮操作来实现入队操作。\n出队操作出队操作即弹出堆顶元素，弹出后需要将堆的最后一个元素放到堆顶，然后进行下沉操作。\n入队操作入队操作即将元素插入到堆的最后一个位置，然后进行上浮操作。\n堆排序堆排序是一种原地排序算法，它的基本思想是将数组构建成一个大顶堆/小顶堆，然后将堆顶元素与堆的最后一个元素交换，然后对剩余的元素进行下沉操作，直到整个数组有序。\n算法实现#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 递归方式构建大顶堆(len是arr的长度，index是第一个非叶子节点的下标) void adjust(vector\u0026lt;int\u0026gt; \u0026amp;arr, int len, int index) { int left = 2 * index + 1; // index的左子节点 int right = 2 * index + 2; // index的右子节点 int max_idx = index; // 用于记录最大值的下标 if (left \u0026lt; len \u0026amp;\u0026amp; arr[left] \u0026gt; arr[max_idx]) { max_idx = left; } if (right \u0026lt; len \u0026amp;\u0026amp; arr[right] \u0026gt; arr[max_idx]) { max_idx = right; } if (max_idx != index) { swap(arr[max_idx], arr[index]); adjust(arr, len, max_idx); } } // 堆排序 void heap_sort(vector\u0026lt;int\u0026gt; \u0026amp;arr, int size) { // 构建大顶堆（从最后一个非叶子节点向上） for (int i = size / 2 - 1; i \u0026gt;= 0; i--) { adjust(arr, size, i); } // 调整大顶堆 for (int i = size - 1; i \u0026gt;= 1; i--) { swap(arr[0], arr[i]); // 将当前最大的放置到数组末尾 adjust(arr, i, 0); // 将未完成排序的部分继续进行堆排序 } } // 构建小顶堆 void adjust_min(vector\u0026lt;int\u0026gt; \u0026amp;arr, int len, int index) { int l = 2 * index + 1; int r = 2 * index + 2; int max_idx = index; if (l \u0026lt; len \u0026amp;\u0026amp; arr[l] \u0026lt; arr[max_idx]) { max_idx = l; } if (r \u0026lt; len \u0026amp;\u0026amp; arr[r] \u0026lt; arr[max_idx]) { max_idx = r; } if (max_idx != index) { swap(arr[index], arr[max_idx]); adjust_min(arr, len, max_idx); } } void heap_sort_min(vector\u0026lt;int\u0026gt; \u0026amp;arr, int size) { // 构建小顶堆，从第一个非叶子节点开始下沉 for (int i = size / 2 - 1; i \u0026gt;= 0; --i) { adjust_min(arr, size, i); } // 开始排序，交换根节点和最后一个节点，然后对根节点进行下沉 for (int i = size - 1; i \u0026gt;= 1; --i) { swap(arr[0], arr[i]); adjust_min(arr, i, 0); } } int main() { vector\u0026lt;int\u0026gt; arr = {8, 1, 14, 3, 21, 5, 7, 10}; heap_sort(arr, arr.size()); for(int i : arr) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; arr = {8, 1, 14, 3, 21, 5, 7, 10}; heap_sort_min(arr, arr.size()); for(int i : arr) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 堆排序与其他排序算法的比较堆排序、快速排序和归并排序，他们的时间复杂度都为 O(NlogN)，但堆排序是一个原地排序算法，所以其空间复杂度最小，为 O(1)，快速排序和归并排序的空间复杂度分别为 O(logN) 和 O(N)。\n参考 【从堆的定义到优先队列、堆排序】 10分钟看懂必考的数据结构——堆（视频） ","permalink":"https://blog.cassdev.com/posts/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003e在学习堆排序之前，我们先来了解一下堆这种数据结构。\u003c/p\u003e\n\u003ch2 id=\"堆的概念\"\u003e堆的概念\u003c/h2\u003e\u003cp\u003e堆是一种特殊的树形数据结构，它满足以下性质：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e堆必须是一个 \u003cstrong\u003e完全二叉树\u003c/strong\u003e 。\u003c/li\u003e\n\u003cli\u003e堆序性：堆中任意节点的值总是不大于或不小于其子节点的值。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e根据堆序性，我们可以将堆分为两种类型：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e大顶堆\u003c/strong\u003e：每个节点的值都大于或等于其子节点的值\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e小顶堆\u003c/strong\u003e：每个节点的值都小于或等于其子节点的值\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cimg alt=\"堆\" loading=\"lazy\" src=\"https://s2.loli.net/2024/06/26/8UaE23iJSzV91Rd.png\"\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e所以，如果一个完全二叉树的一个节点即大于其父节点，又大于其子节点，那么这个树就不是一个堆。小于同理。\u003c/p\u003e\n\n            \u003clink rel=\"stylesheet\" href=\"/css/vendors/admonitions.4fd9a0b8ec8899f2ca952048d255a569f433f77dfb3f52f5bc87e7d65cdce449.css\" integrity=\"sha256-T9mguOyImfLKlSBI0lWlafQz9337P1L1vIfn1lzc5Ek=\" crossorigin=\"anonymous\"\u003e\n    \u003cdiv class=\"admonition note\"\u003e\n      \u003cdiv class=\"admonition-header\"\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 576 512\"\u003e\u003cpath d=\"M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 125.7-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9 0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6 0zM311.9 417L441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z\"/\u003e\u003c/svg\u003e\n        \u003cspan\u003e笔记\u003c/span\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"admonition-content\"\u003e\n        \u003cp\u003e\u003cstrong\u003e完全二叉树的性质\u003c/strong\u003e\u003c/p\u003e","title":"堆排序学习笔记"},{"content":"代码class AClass { private: int _count; public: AClass() : _count(0) { std::cout \u0026lt;\u0026lt; \u0026#34;Default constructor called\\n\u0026#34;; } // 赋值运算符，返回引用 AClass \u0026amp;operator=(int cnt) { _count = cnt;k return *this; } // 后置自增运算符，返回引用 int \u0026amp;operator++(int) { ++_count; return *this; } }; 如果不使用引用返回，其实也是可以运行的，只不过会在返回时调用拷贝构造函数，生成临时对象，然后再调用析构函数释放临时对象，这样会多出一次拷贝构造和析构的开销。而使用引用返回，可以直接返回对象的引用，避免了这个开销。\n需要注意的是，如果我们返回值类型，我们是不能直接修改返回值的：\nclass AClass { private: int _count; public: // 省略构造函数 // 赋值运算符，返回引用 AClass operator=(int cnt) { _count = cnt; return *this; } // 后置自增运算符，返回引用 int operator++(int) { ++_count; return *this; } void print() const { std::cout \u0026lt;\u0026lt; \u0026#34;AClass: count = \u0026#34; \u0026lt;\u0026lt; _count \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { AClass a; a.print(); // 输出 AClass: count = 0 (a++) = 10; a.print(); // 输出 AClass: count = 1 (a++)++; a.print(); // 输出 AClass: count = 2 } 可以看到，如果我们返回值类型，我们是不能直接修改返回值的。虽然 a++ 已经修改了 a 的值，但是 a++ 返回的是一个修改后的 a 对象的拷贝，所以 (a++) = 10; 或者 (a++)++; 修改的是这个拷贝对象，而不是原对象 a。\n","permalink":"https://blog.cassdev.com/posts/c++-%E7%B1%BB%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E/","summary":"\u003ch2 id=\"代码\"\u003e代码\u003c/h2\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eAClass\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eAClass\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Default constructor called\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 赋值运算符，返回引用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003eAClass\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecnt\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003e_count\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecnt\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 后置自增运算符，返回引用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果不使用引用返回，其实也是可以运行的，只不过会在返回时调用拷贝构造函数，生成临时对象，然后再调用析构函数释放临时对象，这样会多出一次拷贝构造和析构的开销。而使用引用返回，可以直接返回对象的引用，避免了这个开销。\u003c/p\u003e\n\u003cp\u003e需要注意的是，如果我们返回值类型，我们是不能直接修改返回值的：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eAClass\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 省略构造函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// 赋值运算符，返回引用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003eAClass\u003c/span\u003e \u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecnt\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003e_count\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecnt\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 后置自增运算符，返回引用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;AClass: count = \u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"sc\"\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eAClass\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 输出 AClass: count = 0\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 输出 AClass: count = 1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 输出 AClass: count = 2\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e可以看到，如果我们返回值类型，我们是不能直接修改返回值的。虽然 \u003ccode\u003ea++\u003c/code\u003e 已经修改了 \u003ccode\u003ea\u003c/code\u003e 的值，但是 \u003ccode\u003ea++\u003c/code\u003e 返回的是一个修改后的 \u003ccode\u003ea\u003c/code\u003e 对象的拷贝，所以 \u003ccode\u003e(a++) = 10;\u003c/code\u003e 或者 \u003ccode\u003e(a++)++;\u003c/code\u003e 修改的是这个拷贝对象，而不是原对象 \u003ccode\u003ea\u003c/code\u003e。\u003c/p\u003e","title":"C++ 类的运算符为什么要使用引用返回"},{"content":"友元函数版代码class AClass { private: int _count; std::string _str; std::vector\u0026lt;int\u0026gt; _vec; public: friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const AClass \u0026amp;a) { os \u0026lt;\u0026lt; \u0026#34;AClass: count = \u0026#34; \u0026lt;\u0026lt; a._count \u0026lt;\u0026lt; \u0026#34;, str = \u0026#34; \u0026lt;\u0026lt; a._str \u0026lt;\u0026lt; \u0026#34;, vec size = \u0026#34; \u0026lt;\u0026lt; a._vec.size(); return os; } }; 为什么要声明为友元函数先理解一下友元函数，它实际上是一个普通函数，不属于类成员，但它又是一个特殊的普通函数，因为它可以访问类的私有成员。因此 operator\u0026lt;\u0026lt; 和 operator\u0026gt;\u0026gt; 声明为友元函数的目的很明显，就是为了能够访问类的私有成员。\n实际上，如果它们不声明为友元函数，也是可以实现的，例如下面代码：\nclass AClass { private: int _count; std::string _str; std::vector\u0026lt;int\u0026gt; _vec; public: std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os) { os \u0026lt;\u0026lt; \u0026#34;AClass: count = \u0026#34; \u0026lt;\u0026lt; _count \u0026lt;\u0026lt; \u0026#34;, str = \u0026#34; \u0026lt;\u0026lt; _str \u0026lt;\u0026lt; \u0026#34;, vec size = \u0026#34; \u0026lt;\u0026lt; _vec.size(); return os; } }; 但是这样就需要特殊的方法来调用这个 operator\u0026lt;\u0026lt; 函数，因为它不再是一个普通函数，而是一个类成员函数：\nint main() { AClass a; a \u0026lt;\u0026lt; std::cout; // 错误，不能这样调用 a.operator\u0026lt;\u0026lt;(std::cout); // 正确 return 0; } 这样显然不够直观，不是一个正常人类写的代码：）\n所以，为了代码的可读性和可维护性，我们将 operator\u0026lt;\u0026lt; 和 operator\u0026gt;\u0026gt; 声明为友元函数，这样就可以直接使用 \u0026lt;\u0026lt; 和 \u0026gt;\u0026gt; 运算符来操作类的对象了。\n","permalink":"https://blog.cassdev.com/posts/c++-%E7%B1%BB%E7%9A%84%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/","summary":"\u003ch2 id=\"友元函数版代码\"\u003e友元函数版代码\u003c/h2\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eAClass\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efriend\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eostream\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eostream\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003eAClass\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eos\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;AClass: count = \u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_count\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;, str = \u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_str\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;, vec size = \u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"为什么要声明为友元函数\"\u003e为什么要声明为友元函数\u003c/h2\u003e\u003cp\u003e先理解一下友元函数，它实际上是一个普通函数，不属于类成员，但它又是一个特殊的普通函数，因为它可以访问类的私有成员。因此 \u003ccode\u003eoperator\u0026lt;\u0026lt;\u003c/code\u003e 和 \u003ccode\u003eoperator\u0026gt;\u0026gt;\u003c/code\u003e 声明为友元函数的目的很明显，就是为了能够访问类的私有成员。\u003c/p\u003e\n\u003cp\u003e实际上，如果它们不声明为友元函数，也是可以实现的，例如下面代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eAClass\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eostream\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eostream\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eos\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;AClass: count = \u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;, str = \u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003e_str\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;, vec size = \u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e但是这样就需要特殊的方法来调用这个 \u003ccode\u003eoperator\u0026lt;\u0026lt;\u003c/code\u003e 函数，因为它不再是一个普通函数，而是一个类成员函数：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eAClass\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// 错误，不能这样调用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// 正确\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这样显然不够直观，不是一个正常人类写的代码：）\u003c/p\u003e\n\u003cp\u003e所以，为了代码的可读性和可维护性，我们将 \u003ccode\u003eoperator\u0026lt;\u0026lt;\u003c/code\u003e 和 \u003ccode\u003eoperator\u0026gt;\u0026gt;\u003c/code\u003e 声明为友元函数，这样就可以直接使用 \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e 和 \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e 运算符来操作类的对象了。\u003c/p\u003e","title":"C++ 类的流插入和流提取运算符为什么要声明为友元函数"},{"content":"什么是 IO 多路复用？阻塞 IO 与 非阻塞 IO我们先了解一下阻塞 IO，阻塞 IO 是指应用程序在读写数据时，如果没有数据可读或者写，应用程序会一直 阻塞在那里 ，直到有数据可读或者写。\n与它相反的是非阻塞 IO，是指应用程序在读写数据时，无论是否有数据可读写，都 立即返回 ，若没有数据可读写将会返回一个错误码，通过不断轮询来检查是否有数据可读或者写。\nIO 多路复用由于 Scoket 默认是阻塞 IO，所以很多初学者在处理多个连接时，会为每个连接创建一个线程来处理，但这样做会引起 CPU 的上下文切换，降低系统的性能。\n有一种更“优雅”的方式，那就是 IO 多路复用，也称为事件驱动模型（Event-driven IO）。IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 事件已经就绪，就通知该进程。IO 多路复用模型中，只需要一个线程就可以同时处理多个连接。\n通俗易懂的说，IO 多路复用就是将多个 IO 事件交给内核，内核帮我们监听这些 IO 事件，当有 IO 事件就绪时，内核会通知我们，我们只需要处理就绪的 IO 事件即可。\nIO 多路复用的优点 一个线程可以同时处理多个连接，减少线程的创建和销毁\n降低了系统开销，提高了系统的并发性能\nIO 多路复用的实现方式 select\npoll\nepoll (Linux)\nkqueue (FreeBSD)\nIOCP（Windows）\n其中 epoll 是 Linux 下的 IO 多路复用机制，kqueue 是 FreeBSD（macOS 就属于 FreeBSD）下的 IO 多路复用机制。\n下面的伪代码是 IO 多路复用的最基本实现方式：\nwhile (1) { for (fd : fds) { // 遍历所有的文件描述符 if (fd 有数据) { 处理数据; // 如果文件描述符有数据则处理数据 } } } 如果我们在自行编写的程序中使用上面的伪代码，那么每次判断 fd 是否有数据时，都需要询问内核，所以每次判断都会引起一次系统调用，也就是会从用户态切换到内核态，这样的效率是不够高的。\n所以操作系统为我们提供了 select、poll、epoll、kqueue、ICOP 这几种解决方案，它们可以在内核中直接监听文件描述符，当文件描述符就绪时，内核会通知我们，这样就不需要我们自己去轮询文件描述符了。\n下面介绍一下五种方式的区别：\nselect 笔记 前置知识\nfd_set\nfd_set（file descriptor set）是一个文件描述符集合，它本质上是一个 bitmap（位图），每个文件描述符对应一个位，如果文件描述符在集合中，则对应的位为 1，否则为 0。例如我们有 3 个文件描述符，分别为 3、4、8，那么 fd_set 的值为 000110001。\nstruct timeval\nstruct timeval 是一个结构体，用来表示时间，它有两个成员变量，分别是 tv_sec 和 tv_usec，分别表示秒和微秒。\n提示 文件描述符补充知识\n在 Linux 中，用户创建的文件描述符最小值为 3，因为 0、1、2 分别为标准输入、标准输出和标准错误。\nint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); nfds：监听的文件描述符的最大值加 1\nreadfds：读事件 fd 集合（输出参数）\nwritefds：写事件 fd 集合（输出参数）\nexceptfds：异常事件 fd 集合（输出参数）\ntimeout：超时时间，类型为 struct timeval\n函数返回值：就绪的文件描述符的数量，如果超时返回 0，出错返回 -1\n从函数原型可以看出，select 函数中间三个参数都是输出参数，我们只需要传入 fd_set 结构体的指针即可。我们需要给予 select 函数的数据只有监听的 fd 的最大值加 1 和监听超时时间，然后 select 函数就会帮我们监听这些文件描述符。\n至于 nfds 为什么要加 1，是因为 select 函数是从 0 开始遍历文件描述符的。用刚刚 fd_set 的例子来说，如果我们不加 1，那么 select 函数只会遍历到 00011000 七个 fd，而不会遍历最后一个 1 对应的 fd。\ntimeout 参数除了设置一个具体的时间值外，还可以设置为 -1，表示永久阻塞，直到有文件描述符就绪。如果设置为 0，则表示立即返回，不会阻塞。\nselect 的工作原理大致如下：\n用户态将需要监听的文件描述符集合传递给内核\n内核将这些文件描述符集合拷贝到内核空间\n内核循环遍历这些 fd ，如果有 fd 可读，则将 readfds 对应的位设置为 1，如果有 fd 可写，则将 writefds 对应的位设置为 1，如果有异常，则将 exceptfds 对应的位设置为 1\n函数返回\nselect 函数每次调用时会将需要遍历的文件描述符直接一次全量拷贝到内核空间，并在内核态进行轮询判断，这样就不会引起用户态和内核态的频繁切换，自然也就提高了效率。\n当 select 函数返回后，我们就可以通过判断 readfds、writefds、exceptfds 中的位来判断哪些文件描述符有数据可读、可写或者有异常。\nselect 函数的使用示例：\n// ... // 假设 fds 为一个 fd 数组，里面存放了需要监听的文件描述符，fd_max 为 fds 中最大的 fd fd_set r_fdset; fd_set w_fdset; fd_set e_fdset; while (1) { FD_ZERO(\u0026amp;r_fdset); // 清空 fd_set FD_ZERO(\u0026amp;w_fdset); FD_ZERO(\u0026amp;e_fdset); for (int i = 0; i \u0026lt; fds.size(); i++) { // 初始化 fd_set FD_SET(fds[i], \u0026amp;r_fdset); FD_SET(fds[i], \u0026amp;w_fdset); FD_SET(fds[i], \u0026amp;e_fdset); } struct timeval timeout; timeout.tv_sec = 5; // 设置超时时间为 5 秒 timeout.tv_usec = 0; int ret = select(fd_max + 1, \u0026amp;r_fdset, \u0026amp;w_fdset, \u0026amp;e_fdset, \u0026amp;timeout); if (ret == 0) { printf(\u0026#34;select timeout\\n\u0026#34;); continue; } if (ret \u0026lt; 0) { perror(\u0026#34;select error\u0026#34;); break; } for (int i = 0; i \u0026lt; fds.size(); i++) { if (FD_ISSET(fds[i], \u0026amp;r_fdset)) { // 处理读事件 } if (FD_ISSET(fds[i], \u0026amp;w_fdset)) { // 处理写事件 } if (FD_ISSET(fds[i], \u0026amp;e_fdset)) { // 处理异常事件 } } } select 函数的缺点：\nfd_set 的大小有限，一般为 1024，所以 select 函数最多只能监听 1024 个文件描述符 fd_set 不可重用，每次调用 select 函数都需要重新初始化 fd_set。上述代码中，每次 while 循环都需要重新初始化 r_fdset、w_fdset 以及 e_fdset select 函数的时间复杂度为 O(n)，n 为文件描述符的数量 每次调用 select 函数都会将所有的文件描述符集合从用户态拷贝到内核态，这样仍有一定的开销 判断哪些文件描述符有数据可读、可写或者有异常时，需要再次遍历所有的文件描述符，时间复杂度为 O(n)，效率不高 select 函数有这些缺点也不奇怪，因为它是最早的 IO 多路复用函数，随着时间的推移，就出现了第二个 IO 多路复用函数 poll。\npoll 笔记 前置知识\nstruct pollfd\npollfd 是一个结构体，用来存放需要监听的文件描述符，它的定义如下：\nstruct pollfd { int fd; // 文件描述符 short events; // 需要监听的事件 short revents; // 返回的事件 }; events 和 revents 都是一个位掩码，用来表示需要监听的事件和返回的事件，它们可以是以下几个值的组合（使用或 | 运算符）：\nPOLLIN：有数据可读，相当于 POLLRDNORM | POLLRDBAND POLLOUT：有数据可写，相当于 POLLWRNORM | POLLWRBAND POLLERR：有错误 POLLHUP：挂起 POLLNVAL：无效请求 POLLPRI：有紧急数据 POLLRDBAND：有带外数据可读 POLLRDNORM：有普通数据可读 POLLWRBAND：有带外数据可写 POLLWRNORM：有普通数据可写 int poll(struct pollfd *fds, nfds_t nfds, int timeout); fds：pollfd 结构体数组，用来存放需要监听的文件描述符\nnfds：fds 数组的大小\ntimeout：超时时间，单位为毫秒\n函数返回值：与 select 函数一样，返回就绪的文件描述符的数量，如果超时返回 0，出错返回 -1\n可以看出，poll 比 select 少了两个参数，fds 既为输入参数，又为输出参数，nfds 为 fds 数组的大小，timeout 为超时时间。poll 函数在有 IO 事件或错误发生时，会将对应的 fd 的 revents 设置为对应的事件，我们只需要遍历 fds 数组，判断 revents 的值即可。\nrevents 的默认值为 0，因此我们在处理完一个 fd 后，只需要将其 revents 设置为 0，这相比于 select 函数的 fd_set 初始化要简洁一些。\npoll 函数的最大亮点就是使用了 pollfd 结构体存放需要监听的文件描述符，所以 poll 函数不会有文件描述符个数的限制，相比于 select 函数能承受更高的并发量。\npoll 函数的使用示例：\n// ... // 假设 pollfds 为一个 pollfd 数组，里面存放了需要监听的文件描述符，pollfds_size 为 pollfds 的大小 for (int i = 0; i \u0026lt; pollfds_size; i++) { pollfds[i].events = POLLIN | POLLOUT | POLLERR; // 设置需要监听的事件 } while(1) { int ret = poll(pollfds, pollfds_size, 5000); // 设置超时时间为 5 秒 if (ret == 0) { printf(\u0026#34;poll timeout\\n\u0026#34;); continue; } if (ret \u0026lt; 0) { perror(\u0026#34;poll error\u0026#34;); break; } for (int i = 0; i \u0026lt; pollfds_size(); i++) { if (pollfds[i].revents \u0026amp; POLLIN) { pollfds[i].revents = 0; // 处理完后将 revents 设置为 0 // 处理读事件 } if (pollfds[i].revents \u0026amp; POLLOUT) { pollfds[i].revents = 0; // 处理写事件 } if (pollfds[i].revents \u0026amp; POLLERR) { pollfds[i].revents = 0; // 处理异常事件 } } } poll 函数解决了 select 函数的 fd_set 大小有限、不可重用的问题，但是它仍有以下两个缺点：\n每次调用 poll 函数都会将所有的文件描述符集合从用户态拷贝到内核态 poll 函数与 select 函数一样，为了判断文件描述符是否就绪，需要遍历所有的文件描述符 是否能够不用每次调用都将文件描述符集合从用户态拷贝到内核态呢，而是只值传递一次呢？是否能够不用每次都遍历所有的文件描述符呢，而是只遍历就绪的文件描述符呢？答案是肯定的，这就是 epoll。\nepoll 笔记 前置知识\nepoll_event\nepoll_event 是一个结构体，用来存放需要监听的文件描述符，它的定义如下：\ntypedef union epoll_data { void *ptr; int fd; __uint32_t u32; __uint64_t u64; } epoll_data_t; struct epoll_event { __uint32_t events; // 需要监听的事件 epoll_data_t data; // 用户数据 }; events 是需要监听的事件，它可以是以下几个值的组合（使用或 | 运算符）：\nEPOLLIN：有数据可读 EPOLLOUT：有数据可写 EPOLLERR：有错误 EPOLLHUP：挂起 EPOLLPRI：有 OOB 紧急数据 EPOLLRDHUP：断开连接或者半关闭的情况，只有在边缘触发模式下才有效（关于边缘触发会在下文中介绍） EPOLLONESHOT：只监听一次事件，发生一次事件后，此文件描述符就不再收到事件通知。需要使用 epoll_ctl 的 EPOLL_CTL_MOD 修改事件 EPOLLET：设置为边缘触发模式 EPOLLWAKEUP：唤醒进程 EPOLLEXCLUSIVE：独占模式 data 是用户数据，一般用于存放文件描述符。\nepoll 共有三个函数：\nepoll_create：创建一个 epoll 实例\nepoll_ctl：控制 epoll 实例中的文件描述符\nepoll_wait：等待就绪的文件描述符\nepoll 的 “e” 代表了 “event”，这是一个事件驱动的模型，即响应式的模型。内核不再需要 主动 轮询文件描述符，而是通过回调函数来实现通知进程，属于 被动响应 。\nselect 和 poll 都只有一个函数，所有功能都聚合到一个函数中，因此每次调用都需要传入需要监听的文件描述符，也就导致了每次都需要将文件描述符集合从用户态拷贝到内核态，增加了开销。\nepoll 将 维护文件描述符集合 和 判断文件描述符是否就绪 两个功能进行了拆分，整个过程只需要使用 epoll_ctl 函数添加一次文件描述符，在 epoll_wait 函数中不再需要传入需要监听文件描述符，这样就大大减少了从用户态到内核态切换的开销。\nint epoll_create(int size); Linux 手册：\nepoll_create() creates a new epoll(7) instance. Since Linux 2.6.8, the size argument is ignored, but must be greater than zero; see HISTORY.\n根据 Linux 手册，epoll_create 函数的 size 参数在 Linux 2.6.8 之后被忽略，但是必须大于 0。所以我们可以将 size 参数设置为 1。根本原因是内核支持了动态扩容，所以 size 参数不再有意义，但为了向下兼容，size 参数仍然需要传入。\nepoll_create 函数作用是创建一个 eventpoll 结构体（ epoll 实例 ），函数返回值是一个非负的文件描述符，用于操作 eventpoll，如果返回 -1 则表示创建失败，并且 errno 会被设置为相应的错误码。这个文件描述符与其他文件描述符一样，需要通过 close 函数关闭，否则文件描述符会被耗尽。\neventpoll 是一个内核数据结构，由操作系统管理，其内部有三个重要的字段：\n红黑树：用来存放需要监听的文件描述符，时间复杂度为 O(log n)\n就绪列表：用来存放就绪的文件描述符，是一个双向循环链表，其作用就是告诉内核哪些文件描述符的哪些事件已经就绪\n等待队列：用来存放等待的进程/线程\n通过 eventpoll 可知，与 select 和 poll 采用的 线性结构 的方式存储文件描述符不同，eventpoll 维护了一个名为 rbr 的红黑树，用来存放需要监听的文件描述符，采用了 树形结构 存储文件描述符，将查询操作的时间复杂度从 O(n) 降低到了 O(log n)。\neventpoll 还维护了一个名为 rdllist 的就绪列表，用来存放就绪的文件描述符。当文件描述符就绪时，其会被 rdllist 引用，因此用户只需要获取 rdllist 中的内容即可知道哪些文件描述符就绪。\n由于一个 epoll 实例可以被多个进程共享，即一个 epfd 可以被多个进程的 epoll_wait 函数调用，所以 eventpoll 还维护了一个名为 wq 的等待队列，用来存放等待中（阻塞中）的线程。\nepoll_create 的工作原理大致如下：\n为 eventpoll 申请空间，并且初始化其成员，如红黑树、就绪列表和等待队列等\n为 eventpoll 申请一个未使用的文件描述符 fd\n申请一个满足 VFS 的虚拟文件结构体 file\neventpoll 与 file 关联，将 fd 和 file 关联起来\n返回 fd\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epfd：epoll 实例的文件描述符，即 epoll_create 函数返回的文件描述符\nop：操作类型，Linux 为我们定义了三个宏：\nEPOLL_CTL_ADD：添加一个文件描述符到 epoll 实例中\nEPOLL_CTL_MOD：修改一个文件描述符在 epoll 实例中的事件\nEPOLL_CTL_DEL：从 epoll 实例中删除一个文件描述符\nfd：需要监听的文件描述符\nevent：epoll_event 结构体，用来存放需要监听的事件\n函数返回值：成功返回 0，失败返回 -1，并且 errno 会被设置为相应的错误码\nepoll_ctl 函数（ epoll control ）用来控制 epoll 实例中的文件描述符，可以添加、修改或者删除文件描述符。\n阅读下面代码语句：\nepoll_ctl(A, EPOLL_CTL_ADD, B, \u0026amp;C); epoll_ctl(A, EPOLL_CTL_DEL, B, NULL); 第一条语句的意思是在 epoll 实例 A 中注册（添加）文件描述符 B，并监听参数 C 中的事件。 第二条语句的意思是在 epoll 实例 A 中删除文件描述符 B。可以看出在删除文件描述符时，不需要传入事件参数。\n由于 epoll_ctl 函数的实现里有互斥锁的存在，所以它是一个线程安全的函数，多个线程/进程可以并发调用 epoll_ctl 函数。\n在调用 epoll_ctl 函数时，epoll_ctl 函数会为每个文件描述符创建一个 epitem 结构体，这个结构体用来存放文件描述符的信息，包括文件描述符、事件、回调函数等。这个 epitem 结构体会被添加到 eventpoll 的红黑树中。\nepitem 结构体的定义如下：\nstruct epitem { struct rb_node rbn; // 红黑树节点 struct list_head rdllink; // 就绪列表节点 struct eppoll_entry *pwqlist; // socket 等待队列 struct eventpoll* ep; // 指向 eventpoll 结构体 struct epoll_event event; // 事件 } epoll_ctl(ADD) 函数的工作原理大致如下：\n将 event 拷贝到内核空间\n尝试在红黑树中查找 fd 对应的 epitem 结构体\n找不到则创建一个新的 epitem，并将 epitem 添加到红黑树中\n创建一个 epitem 对应的 eppoll_entry 用于链接到 socket 等待队列，并为 eppoll_entry 设置回调函数\n将 eppoll_entry 添加到 socket 等待队列中\n检查该 socket 的读写缓冲区和状态，如果有事件发生，则将 epitem 添加到就绪列表中，并且唤醒 eventpoll.wq 中的等待进程\n函数返回\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); epfd：epoll 实例的文件描述符\nevents：用来存放就绪的文件描述符\nmaxevents：events 数组的大小\ntimeout：超时时间，单位为毫秒\n函数返回值：返回就绪的文件描述符的数量，如果超时返回 0，出错返回 -1\n其中 epfd 和 timeout 参数皆为输入参数，events 为输出参数，我们只需要传入空的 epoll_event 数组即可。events 数组会被填充就绪的文件描述符，所以其大小 maxevents 应该大于等于监听的文件描述符的数量。\nepoll_wait 函数会检查 epoll 实例的就绪链表，如果就绪链表中有文件描述符，则将其添加到 events 数组中，然后返回就绪的文件描述符的数量。如果就绪链表为空，则会阻塞直到有文件描述符就绪或者超时。\nepoll_wait 函数的工作原理大致如下：\n通过传入的 epfd 找到对应的 eventpoll 结构体\n判断 eventpoll.rdllist 是否有 epitem，有则代表有 epitem 就绪，但不一定是我们感兴趣的事件，所以需要进一步判断\n若 rdllist 不为空，则遍历它，获取 epitem 的 socket 后，在 rdllist 中删除此 epitem，接着判断 socket 具体触发的事件类型是否为我们需要监听的事件\n若是我们需要监听的事件，则将此事件拷贝回用户态的 events 数组中，函数返回\n若是水平触发模式，则将 epitem 重新添加到 rdllist 中，以便下次再次判断\n若 rdllist 为空，则判断是否超时，若超时则直接返回\n未超时则将该进程加入到 eventpoll.wq 进程等待队列中，并且将进程置为可中断睡眠状态，等待唤醒\n唤醒后，将进程设置为运行状态，并在 wq 中删除该进程\n重复 2-8 步骤，直到超时或者有文件描述符就绪\n笔记 注意，epoll 并没有采用共享内存的方式，阅读源码可知，epoll 采用了内核态和用户态的数据拷贝：\nepoll_put_uevent(__poll_t revents, __u64 data, struct epoll_event __user *uevent) { // __put_user 是内核态到用户态的数据拷贝的函数 if (__put_user(revents, \u0026amp;uevent-\u0026gt;events) || __put_user(data, \u0026amp;uevent-\u0026gt;data)) return NULL; return uevent+1; } 笔记 epoll 的两种触发模式\nepoll 有两种触发模式，分别是 水平触发模式（ Level Trigger ）和 边缘触发模式（ Edge Trigger ）。水平触发模式是 epoll 默认的工作模式。\n水平触发模式（ LT模式 ）：相当于时序电路中的高电平触发。关注点是 数据，只要读操作缓冲区不为空或写操作缓冲区不为满，epoll_wait 就会返回就绪事件。\n边缘触发模式（ ET模式 ）：相当于时序电路中的边沿出发。关注点是 变化，只有当有数据写接收进缓冲区或者从发送缓冲区读出数据时，epoll_wait 才会返回就绪事件。\nepoll 函数的使用示例：\n// ... // 假设 epfd 为 epoll 实例的文件描述符，fds 为需要监听的文件描述符数组，fds_size 为 fds 的大小 struct epoll_event events[5] int epfd = epoll_create(1); for (int i = 0; i \u0026lt; 5; i++) { static struct epoll_event ev; ev.events = EPOLLIN | EPOLLOUT | EPOLLERR; // 设置需要监听的事件 ev.data.fd = fds[i]; // 设置需要监听的文件描述符 epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, \u0026amp;ev); // 注册文件描述符和事件 } while (1) { int ret = epoll_wait(epfd, events, 5, 5000); // 设置超时时间为 5 秒 if (ret == 0) { printf(\u0026#34;epoll timeout\\n\u0026#34;); continue; } if (ret \u0026lt; 0) { perror(\u0026#34;epoll error\u0026#34;); break; } for (int i = 0; i \u0026lt; ret; i++) { if (events[i].events \u0026amp; EPOLLIN) { // 处理读事件，events[i].data.fd 为就绪的文件描述符 } if (events[i].events \u0026amp; EPOLLOUT) { // 处理写事件，events[i].data.fd 为就绪的文件描述符 } if (events[i].events \u0026amp; EPOLLERR) { // 处理异常事件，events[i].data.fd 为就绪的文件描述符 } } } kqueueIOCP几个问题1. select 和 poll 一无是处了吗？在学完这几个多路复用函数后，可能有些人会对 select 和 poll 感到失望。但是它们也有优点，比如 select 函数是跨平台的，无论你在 Linux、Windows 还是 macOS 下，都可以使用 select 函数。而改进的 IO 多路复用模型兼容性差，epoll 函数只能在 Linux 下使用，kqueue 函数只能在 FreeBSD 下使用，IOCP 函数只能在 Windows 下使用。\n除此之外，未必所有的程序都需要处理大量的并发连接，如果一个程序只需要处理十几个连接，那么选择 select 函数是优于 epoll 函数的。\n2. epoll 为什么使用红黑树而不是哈希表或 AVL 树？其实历史版本的 Linux 内核中，epoll 使用的是哈希表，但后面改用了红黑树。\n应用程序在调用 epoll 函数，尤其是当 epoll 监视的文件数量达到百万级的时候，对文件描述符的增删改查操作的频率很高，选用不同的数据结构带来的效率差异可能非常大。我们需要选择一个综合性能较好的数据结构。\n数据结构 插入 删除 查找 特点 红黑树 O(log n) O(log n) O(log n) 综合性能最优，最坏情况下时间复杂度为 O(log n) 哈希表 O(1) O(1) O(1) ReHashing 开销大即扩展性差，且难以抉择哈希表大小 AVL 树 O(log n) O(log n) O(log n) 查询效率稍快于红黑树，但插入删除效率稍慢于红黑树 综合考量，红黑树是最优选择。\n3. 为什么是 epitem 的成员指向就绪列表，而不是列表元素指向 epitem？有人可能会发现，在 epitem 结构体中，rdllink 指向就绪列表，而不是就绪列表的元素指向 epitem。这是由于 Linux 内核的链表设计哲学：“让万物包含链表，而不是链表包含万物。” Linux 内核可以通过 container_of 宏来获取链表元素的所在结构体地址，所以就绪列表的元素不需要指向 epitem。\n参考资料 TCP/IP 网络编程（伊圣雨）（书籍）\n如果这篇文章说不清epoll的本质，那就过来掐死我吧！（文章）\n源码解读epoll内核机制（文章）\n十个问题理解Linux epoll工作原理（文章）\n【并发】IO多路复用select/poll/epoll介绍（视频）\n腾讯面试：请描述 select、poll、epoll 这三种IO多路复用技术的执行原理（视频）\n","permalink":"https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003ch2 id=\"什么是-io-多路复用\"\u003e什么是 IO 多路复用？\u003c/h2\u003e\u003ch3 id=\"阻塞-io-与-非阻塞-io\"\u003e阻塞 IO 与 非阻塞 IO\u003c/h3\u003e\u003cp\u003e我们先了解一下阻塞 IO，阻塞 IO 是指应用程序在读写数据时，如果没有数据可读或者写，应用程序会一直 \u003cstrong\u003e阻塞在那里\u003c/strong\u003e ，直到有数据可读或者写。\u003c/p\u003e\n\u003cp\u003e与它相反的是非阻塞 IO，是指应用程序在读写数据时，无论是否有数据可读写，都 \u003cstrong\u003e立即返回\u003c/strong\u003e ，若没有数据可读写将会返回一个错误码，通过不断轮询来检查是否有数据可读或者写。\u003c/p\u003e\n\u003ch3 id=\"io-多路复用\"\u003eIO 多路复用\u003c/h3\u003e\u003cp\u003e由于 Scoket 默认是阻塞 IO，所以很多初学者在处理多个连接时，会为每个连接创建一个线程来处理，但这样做会引起 CPU 的上下文切换，降低系统的性能。\u003c/p\u003e\n\u003cp\u003e有一种更“优雅”的方式，那就是 IO 多路复用，也称为事件驱动模型（Event-driven IO）。IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 事件已经就绪，就通知该进程。IO 多路复用模型中，只需要一个线程就可以同时处理多个连接。\u003c/p\u003e\n\u003cp\u003e通俗易懂的说，IO 多路复用就是将多个 IO 事件交给内核，内核帮我们监听这些 IO 事件，当有 IO 事件就绪时，内核会通知我们，我们只需要处理就绪的 IO 事件即可。\u003c/p\u003e\n\u003ch2 id=\"io-多路复用的优点\"\u003eIO 多路复用的优点\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e一个线程可以同时处理多个连接，减少线程的创建和销毁\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e降低了系统开销，提高了系统的并发性能\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"io-多路复用的实现方式\"\u003eIO 多路复用的实现方式\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eselect\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003epoll\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eepoll (Linux)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ekqueue (FreeBSD)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIOCP（Windows）\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e其中 epoll 是 Linux 下的 IO 多路复用机制，kqueue 是 FreeBSD（macOS 就属于 FreeBSD）下的 IO 多路复用机制。\u003c/p\u003e\n\u003cp\u003e下面的伪代码是 IO 多路复用的最基本实现方式：\u003c/p\u003e","title":"Socket 编程之 IO 多路复用学习笔记"},{"content":"本文章主要介绍如何使用 GitHub Actions 实现基于 MkDocs 的 GitHub.io 个人静态博客的自动化部署。\n本指南主要分为以下几个部分：\n创建 GitHub 仓库 创建 MkDocs 项目 配置 GitHub Actions 部署到 GitHub Pages 创建 GitHub 仓库由于我们的博客是托管在 GitHub io 上的，所以我们需要一个 GitHub 仓库来存放我们的 MkDocs 博客。\n创建仓库首先，我们需要在 GitHub 上创建一个新的仓库，仓库名可以是 \u0026lt;username\u0026gt;.github.io，其中 \u0026lt;username\u0026gt; 是你的 GitHub 用户名。\n克隆仓库然后，我们需要将这个仓库克隆到本地：\ngit clone \u0026lt;repository-url\u0026gt; cd \u0026lt;repository-name\u0026gt; 创建 MkDocs 项目安装 MkDocsMkDocs 是一个 Python 项目使用 pip 安装：\npip install mkdocs 我们需要创建一个 MkDocs 项目，可以使用 MkDocs 官方提供的模板来创建。直接在仓库根目录执行以下命令即可：\nmkdocs new . 然后，我们需要安装 MkDocs Material 主题。当然我们也可以选择其他主题，可以在 MkDocs 的 WiKi 查看更多主题。\npip install mkdocs-material markdown-callouts 笔记 这里我安装了 markdown-callouts 插件，这个插件可以让我们在 MkDocs 中使用 GitHub 的 callouts 语法，比如 \u0026gt; [!NOTE]、\u0026gt; [!WARNING] 等。\n因此我们为项目添加一个 requirements.txt 文件，执行 vim requirements.txt，并粘贴如下内容：\nmarkdown-callouts\u0026gt;=0.4.0 配置 MkDocsMkDocs 的配置文件是 mkdocs.yml，我们可以在这个文件中配置 MkDocs 的一些参数，比如主题、导航栏等。 具体的配置可以参考 MkDocs 的官方文档。\n下面是我个人的配置文件示例：\nmkdocs.yml site_name: Cassius0924\u0026#39;s Blog # site_url: https://cassius0924.github.io site_author: Cassius0924 repo_name: \u0026#39;Cassius0924/Cassius0924.github.io\u0026#39; copyright: \u0026#34;Copyright \u0026amp;copy; 2024 - 2024 Chihchou Ho\u0026#34; name: \u0026#39;material\u0026#39; palette: primary: \u0026#39;indigo\u0026#39; accent: \u0026#39;indigo\u0026#39; features: - content.code.select - content.code.copy language: \u0026#39;zh\u0026#39; extra: social: - icon: \u0026#39;fontawesome/brands/github\u0026#39; link: \u0026#39;https://github.com/cassius0924\u0026#39; - icon: \u0026#39;fontawesome/brands/bilibili\u0026#39; link: \u0026#39;https://space.bilibili.com/12873865\u0026#39; markdown_extensions: - github-callouts # github callouts 语法支持 - admonition # 注解块支持 - pymdownx.arithmatex # 数学公式的TeX语法支持 - pymdownx.betterem: smart_enable: all - pymdownx.caret - pymdownx.critic - pymdownx.details - pymdownx.emoji: # 表情支持 emoji_generator: !!python/name:pymdownx.emoji.to_svg - pymdownx.magiclink - pymdownx.mark - pymdownx.smartsymbols - pymdownx.tasklist: # 任务清单支持 custom_checkbox: true - pymdownx.tilde - pymdownx.highlight: anchor_linenums: true line_spans: __span pygments_lang_class: true - pymdownx.inlinehilite - pymdownx.snippets - pymdownx.superfences - meta # 元数据支持 extra_javascript: - \u0026#39;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML\u0026#39; plugins: - search 编写 Markdown 文件在 docs 目录下编写 Markdown 文件，也就是将我们以前写的 Markdown 格式的博客文件放在这里，这些文件将会被 MkDocs 转换成静态网页。\n其中，index.md 是默认的首页文件，当访问网站时，会默认显示这个文件。\n本地预览在本地预览 MkDocs 生成的静态网页，可以执行以下命令：\nmkdocs serve 然后，打开浏览器访问终端打印的地址，如： http://127.0.0.1:8000/。可以进一步根据需求修改 MkDocs 配置，自己满意了就可以进行下一步。\n配置 GitHub ActionsGitHub Actions 是 GitHub 提供的持续集成服务，我们可以使用它来实现自动化部署。\n创建 Actions 配置文件在仓库根目录下创建 .github/workflows 目录，并在该目录下创建一个名为 deploy.yml 的文件，内容如下：\nname: Deploy on: push: branches: - main jobs: build: name: Deploy docs to GitHub Pages runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 - name: Build uses: Tiryoh/actions-mkdocs@v0 with: mkdocs_version: \u0026#39;latest\u0026#39; requirements: \u0026#39;requirements.txt\u0026#39; configfile: \u0026#39;mkdocs.yml\u0026#39; - name: Deploy uses: peaceiris/actions-gh-pages@v4 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./site publish_branch: gh-pages 这个配置文件定义了一个名为 Deploy 的工作流，当 main 分支有代码提交时，会触发这个工作流。\n可以发现这个 deploy.yml 中使用了一个名为 GITHUB_TOKEN 的 secret，GitHub 会为每个工作流都创建并注入 GITHUB_TOKEN，我们并不需要手动创建这个 secret。\n这个工作流包含了三个步骤：\nCheckout：检出代码 Build：构建 MkDocs 项目 Deploy：部署到 GitHub Pages（推送到 GitHub 的 gh-pages 分支） 设置 Workflow 权限进入仓库的 Settings -\u0026gt; Actions -\u0026gt; Generals 页面，滑到下面，找到 Workflow permissions，勾选 Read and write permissions，然后点击 Save。\n部署到 GitHub Pages当我们将代码推送到 GitHub 的 main 分支时，GitHub Actions 会自动触发工作流，构建 MkDocs 项目，并将生成的静态网页推送到 gh-pages 分支。\n由于 GitHub 不允许使用 HTTPS 协议推送代码，所以 Push 前需要将本地仓库的远程仓库地址修改为你远程仓库 SSH 地址：\ngit remote set-url origin \u0026lt;ssh-repo-url\u0026gt; 然后，将代码推送到 GitHub：\ngit add . git commit -m \u0026#34;Add MkDocs project\u0026#34; git push origin main 等待 GitHub Actions 完成构建，此时还未部署成功，还需进行最后一步设置。\n设置 GitHub Pages在 GitHub 仓库的 Settings -\u0026gt; Pages 中，将 Branch 设置为 gh-pages，Folder 设置为 / (root)，点击 Save 即可。\n此时 GitHub 会再运行一个 GitHub Pages 的 action。等待 action 运行完毕完成后，即可访问 https://\u0026lt;username\u0026gt;.github.io 查看你的博客。\n关于自动化完成上述步骤后，GitHub.io 就可以实现自动化部署了。每次我们将新博客推送到 main 分支时，GitHub Actions 会自动构建 MkDocs 项目，并将生成的静态网页推送到 gh-pages 分支，网站也会自动更新。\n","permalink":"https://blog.cassdev.com/posts/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%9A%84-github.io-%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e本文章主要介绍如何使用 GitHub Actions 实现基于 MkDocs 的 GitHub.io 个人静态博客的自动化部署。\u003c/p\u003e\n\u003cp\u003e本指南主要分为以下几个部分：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/posts/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%9A%84-github.io-%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/#%e5%88%9b%e5%bb%ba-github-%e4%bb%93%e5%ba%93\"\u003e创建 GitHub 仓库\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/posts/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%9A%84-github.io-%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/#%e5%88%9b%e5%bb%ba-mkdocs-%e9%a1%b9%e7%9b%ae\"\u003e创建 MkDocs 项目\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/posts/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%9A%84-github.io-%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/#%e9%85%8d%e7%bd%ae-github-actions\"\u003e配置 GitHub Actions\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/posts/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%9A%84-github.io-%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/#%e9%83%a8%e7%bd%b2%e5%88%b0-github-pages\"\u003e部署到 GitHub Pages\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"创建-github-仓库\"\u003e创建 GitHub 仓库\u003c/h2\u003e\u003cp\u003e由于我们的博客是托管在 GitHub io 上的，所以我们需要一个 GitHub 仓库来存放我们的 MkDocs 博客。\u003c/p\u003e\n\u003ch3 id=\"创建仓库\"\u003e创建仓库\u003c/h3\u003e\u003cp\u003e首先，我们需要在 GitHub 上创建一个新的仓库，仓库名可以是 \u003ccode\u003e\u0026lt;username\u0026gt;.github.io\u003c/code\u003e，其中 \u003ccode\u003e\u0026lt;username\u0026gt;\u003c/code\u003e 是你的 GitHub 用户名。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"创建 GitHub 仓库\" loading=\"lazy\" src=\"https://s2.loli.net/2024/06/17/X43nikWmO7hVGrb.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"克隆仓库\"\u003e克隆仓库\u003c/h3\u003e\u003cp\u003e然后，我们需要将这个仓库克隆到本地：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit clone \u0026lt;repository-url\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e \u0026lt;repository-name\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"创建-mkdocs-项目\"\u003e创建 MkDocs 项目\u003c/h2\u003e\u003ch3 id=\"安装-mkdocs\"\u003e安装 MkDocs\u003c/h3\u003e\u003cp\u003eMkDocs 是一个 Python 项目使用 pip 安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epip install mkdocs\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我们需要创建一个 MkDocs 项目，可以使用 MkDocs 官方提供的模板来创建。直接在仓库根目录执行以下命令即可：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emkdocs new .\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e然后，我们需要安装 MkDocs Material 主题。当然我们也可以选择其他主题，可以在 MkDocs 的 \u003ca href=\"https://github.com/mkdocs/mkdocs/wiki/MkDocs-Themes\"\u003eWiKi\u003c/a\u003e 查看更多主题。\u003c/p\u003e","title":"搭建自动化部署的 GitHub.io 个人静态博客指南"},{"content":"本文章主要介绍 Windows 下和 Linux 下的 Socket 编程区别，即 Windows Socket API 和 Linux Socket API 的区别。\n头文件Windows 环境下的 Socket 编程需要以下头文件:\n\u0026lt;WinSock2.h\u0026gt; \u0026lt;WS2tcpip.h\u0026gt; 笔记 如果使用 MSVC 编译器，那么还需要使用预处理指令 #pragma comment(lib, \u0026quot;Ws2_32.lib\u0026quot;) 来链接 Ws2_32.lib 库。\n而 Linux 环境下的 Socket 编程可能会用到以下头文件:\n\u0026lt;sys/socket.h\u0026gt; \u0026lt;netinet/in.h\u0026gt; \u0026lt;arpa/inet.h\u0026gt; \u0026lt;unistd.h\u0026gt; \u0026lt;fcntl.h\u0026gt; #indef __linux__ #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #elif defined(_WIN32) #include \u0026lt;winsock2.h\u0026gt; #include \u0026lt;WS2tcpip.h\u0026gt; socket 套接字类型 Linux 环境下为 int\nWindows 环境下为 SOCKET\n函数返回值Windows 环境下有专门定义操作成功的宏 NO_ERROR，Linux 环境下则没有。\nclose 和 closesocket关闭一个套接字需要使用 close 或 closesocket，Linux 环境下需要使用 close 删除套接字描述符，Windows 环境下则使用 closesocket。\nLinux 环境 close(fd); 返回值：\n返回值 描述 EBADF fd 不是有效的文件描述符。 EINTR 执行被信号中断。 EIO 先前未提交的 write(2) 遇到输入/输出错误。 Windows 环境 closesocket(fd); 返回值：\n返回值 描述 WSANOTINITIALIZED 在使用此函数之前，必须成功调用 WSAStartup。 WSAENETDOWN 网络子系统发生故障。 WSAENOTSOCK 描述符不是套接字。 WSAEINPROGRESS 阻止 Windows 套接字 1.1 调用正在进行，或者服务提供商仍在处理回调函数。 WSAEINTR (阻止) Windows 套接字 1.1 调用已通过 WSACancelBlockingCall 取消。 WSAEWOULDBLOCK 套接字标记为非阻止，但 linger 结构的 l_onoff 成员设置为非零，而 linger 结构的 l_linger 成员设置为非零超时值。 getsockopt 和 setsockopt Linux 环境下的函数原型 int getsockopt( int sockfd, int level, int optname, void optval[restrict *.optlen], socklen_t *restrict optlen ); int setsockopt( int socket, int level, int option_name, const void *option_value, socklen_t option_len ); Windows 环境下的函数原型 int getsockopt( [in] SOCKET s, [in] int level, [in] int optname, [out] char *optval, [in, out] int *optlen ); int setsockopt( [in] SOCKET s, [in] int level, [in] int optname, [in] const char *optval, [in] int optlen ); 二者区别在于 Windows 下的 optval 是 char * 类型，而 Linux 下的 optval 是 void * 类型。\n所以建议使用 char * 类型，这样可以在 Windows 和 Linux 下都能正常使用。\nfcntl 和 ioctlsocket这两个函数都是用来设置套接字的属性，比如设置非阻塞模式等。\nLinux 环境下的函数原型 int fcntl(int fd, int cmd, ... /* arg */ ); cmd 参数的取值：\nF_DUPFD：复制文件描述符 F_GETFL：获取文件状态标志，返回值是文件状态标志的副本； F_SETFL：设置文件状态标志，设置文件状态标志为 arg 参数的值； F_GETFD：获取文件描述符标志，返回值是文件描述符标志的副本； F_SETFD：设置文件描述符标志，设置文件描述符标志为 arg 参数的值； FL 和 FD 的区别 文件描述符标志（FD Flags）和文件状态标志（FL Flags）都是与文件描述符相关的属性，但它们的用途和含义有所不同。\n文件描述符标志（FD Flags）：这些标志控制文件描述符的行为。目前，只有一个文件描述符标志，即 FD_CLOEXEC。\n文件状态标志（FL Flags）：这些标志描述了文件的状态，例如文件是以读模式、写模式还是读写模式打开的，文件是否支持非阻塞操作，等等。\nWindows 环境下的函数原型 int WSAAPI ioctlsocket( [in] SOCKET s, [in] long cmd, [in, out] u_long *argp ); cmd 参数的取值：\nFIONBIO：设置非阻塞模式，如果设置为0，那么套接字是阻塞的，否则是非阻塞的； FIONREAD：获取接收缓冲区中的字节数，如果是流式套接字（TCP），那么返回的是接收缓冲区中的字节数，如果是数据报套接字（UDP），那么返回的是下一个数据报的大小； SIOCATMARK：确定是否已经读取了所有的Out-of-Band数据（带外数据），此命令只适用于设置了SO_OOBINLINE选项的流式套接字，如果没有OOB数据等待读取，那么返回TRUE，否则返回FALSE； 返回值：\n错误代码 含义 WSANOTINITIALIZED 在使用此函数之前，必须成功调用 WSAStartup 。 WSAENETDOWN 网络子系统发生故障。 WSAEINPROGRESS 阻止 Windows 套接字 1.1 调用正在进行，或者服务提供商仍在处理回调函数。 WSAENOTSOCK 描述符 s 不是套接字。 WSAEFAULT argp 参数不是用户地址空间的有效部分。 ","permalink":"https://blog.cassdev.com/posts/windows-socket-api-%E5%92%8C-linux-socket-api/","summary":"\u003cp\u003e本文章主要介绍 Windows 下和 Linux 下的 Socket 编程区别，即 Windows Socket API 和 Linux Socket API 的区别。\u003c/p\u003e\n\u003ch2 id=\"头文件\"\u003e头文件\u003c/h2\u003e\u003cp\u003eWindows 环境下的 Socket 编程需要以下头文件:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;WinSock2.h\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;WS2tcpip.h\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003cdiv class=\"admonition note\"\u003e\n      \u003cdiv class=\"admonition-header\"\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 576 512\"\u003e\u003cpath d=\"M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 125.7-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9 0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6 0zM311.9 417L441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z\"/\u003e\u003c/svg\u003e\n        \u003cspan\u003e笔记\u003c/span\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"admonition-content\"\u003e\n        \u003cp\u003e如果使用 MSVC 编译器，那么还需要使用预处理指令 \u003ccode\u003e#pragma comment(lib, \u0026quot;Ws2_32.lib\u0026quot;)\u003c/code\u003e 来链接 \u003ccode\u003eWs2_32.lib\u003c/code\u003e 库。\u003c/p\u003e","title":"Windows Socket API 和 Linux Socket API"},{"content":"本文主要介绍如何在 Windows 系统下的 Visual Studio Code 中使用 JetBrians Mono 字体。\n下载字体可能你跟着网上很多教程一样，一上来就在 VS Code 中设置字体，结果发现设置不生效，这是因为你没有安装 JetBrians Mono 字体。\nJetBrians Mono 字体下载地址：JetBrainsMono\n安装字体下载字体后，解压缩，进入 ttf 文件夹，找到 JetBrainsMono-Regular.ttf 文件，双击打开，点击安装即可。当然你也可以全部字体都安装 :)\n设置 VS Code打开 VS Code 的设置，搜索 editor.fontFamily，将其值设置为 JetBrains Mono，如下图所示：\n重启 VS Code最后一步，重启 VS Code 即可。\n","permalink":"https://blog.cassdev.com/posts/windows-vscode-%E4%BD%BF%E7%94%A8-jetbrians-mono-%E5%AD%97%E4%BD%93/","summary":"\u003cp\u003e本文主要介绍如何在 Windows 系统下的 Visual Studio Code 中使用 JetBrians Mono 字体。\u003c/p\u003e\n\u003ch2 id=\"下载字体\"\u003e下载字体\u003c/h2\u003e\u003cp\u003e可能你跟着网上很多教程一样，一上来就在 VS Code 中设置字体，结果发现设置不生效，这是因为你没有安装 JetBrians Mono 字体。\u003c/p\u003e\n\u003cp\u003eJetBrians Mono 字体下载地址：\u003ca href=\"https://www.jetbrains.com/lp/mono/\"\u003eJetBrainsMono\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"安装字体\"\u003e安装字体\u003c/h2\u003e\u003cp\u003e下载字体后，解压缩，进入 \u003ccode\u003ettf\u003c/code\u003e 文件夹，找到 \u003ccode\u003eJetBrainsMono-Regular.ttf\u003c/code\u003e 文件，双击打开，点击安装即可。当然你也可以全部字体都安装 :)\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2024-06-02 at 16.22.26@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2024/06/02/RG7EY6MqkvHW8Ni.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"设置-vs-code\"\u003e设置 VS Code\u003c/h2\u003e\u003cp\u003e打开 VS Code 的设置，搜索 \u003ccode\u003eeditor.fontFamily\u003c/code\u003e，将其值设置为 \u003ccode\u003eJetBrains Mono\u003c/code\u003e，如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2024-06-02 at 16.35.35@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2024/06/02/fJlT5nwtE6kG829.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"重启-vs-code\"\u003e重启 VS Code\u003c/h2\u003e\u003cp\u003e最后一步，重启 VS Code 即可。\u003c/p\u003e","title":"Windows VSCode 使用 JetBrians Mono 字体"},{"content":"起因是因为我在对我的 C++ 项目进行跨平台适配，从 macOS 平台移植到 Windows 平台时，在使用 Cmake + MSVC 编译后，出现了这个问题。\n问题原因这是由于 Windows 平台默认使用的是 GBK 编码，而 macOS 平台上使用的是 UTF-8 编码。\n解决方法方法一在 CMakeLists.txt 文件中添加如下代码：\nadd_compile_options(\u0026#34;$\u0026lt;$\u0026lt;C_COMPILER_ID:MSVC\u0026gt;:/source-charset:utf-8\u0026gt;\u0026#34;) 方法二在 CMakeLists.txt 文件中添加如下代码：\nif(MSVC) target_compile_options(\u0026lt;你的项目名\u0026gt; PRIVATE \u0026#34;/utf-8\u0026#34;) endif() ","permalink":"https://blog.cassdev.com/posts/%E8%A7%A3%E5%86%B3-warning-c4819--%E8%AF%A5%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8D%E8%83%BD%E5%9C%A8%E5%BD%93%E5%89%8D%E4%BB%A3%E7%A0%81%E9%A1%B5936%E4%B8%AD%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%AD%97%E7%AC%A6-%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e起因是因为我在对我的 C++ 项目进行跨平台适配，从 macOS 平台移植到 Windows 平台时，在使用 Cmake + MSVC 编译后，出现了这个问题。\u003c/p\u003e\n\u003ch2 id=\"问题原因\"\u003e问题原因\u003c/h2\u003e\u003cp\u003e这是由于 Windows 平台默认使用的是 GBK 编码，而 macOS 平台上使用的是 UTF-8 编码。\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\u003ch3 id=\"方法一\"\u003e方法一\u003c/h3\u003e\u003cp\u003e在 CMakeLists.txt 文件中添加如下代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cmake\" data-lang=\"cmake\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eadd_compile_options\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;$\u0026lt;$\u0026lt;C_COMPILER_ID:MSVC\u0026gt;:/source-charset:utf-8\u0026gt;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"err\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"方法二\"\u003e方法二\u003c/h3\u003e\u003cp\u003e在 CMakeLists.txt 文件中添加如下代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cmake\" data-lang=\"cmake\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003eMSVC\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"err\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"err\"\u003e\u003c/span\u003e    \u003cspan class=\"nb\"\u003etarget_compile_options\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026lt;你的项目名\u0026gt;\u003c/span\u003e \u003cspan class=\"s\"\u003ePRIVATE\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;/utf-8\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"err\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"err\"\u003e\u003c/span\u003e\u003cspan class=\"nb\"\u003eendif\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"err\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"解决 “warning C4819- 该文件包含不能在当前代码页(936)中表示的字符” 问题指南"},{"content":"在流里读出数据后，需要将数据包大小缩短成有效大小，即 bytesRead 长度。\n下面是 C# 端接收并解析数据的示例代码：\nprivate void ReceiveMessage() { stream = client.GetStream(); int bytesRead; while (isKeepReading) { if (stream.CanRead) { buffer = new byte[client.ReceiveBufferSize]; bytesRead = stream.Read(buffer, 0, client.ReceiveBufferSize); if (bytesRead \u0026gt; 0) { MemoryStream protoStream = new MemoryStream(buffer,0, bytesRead); Cas.Proto.DataMessage dataMessage = Cas.Proto.DataMessage.Parser.ParseFrom(protoStream); switch (dataMessage.Type) { case DataMessage.Types.Type.Mesh: Debug.Log(\u0026#34;Mesh类型\u0026#34;); break; default: break; } } } } } ","permalink":"https://blog.cassdev.com/posts/c%23-protobuf-%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE/","summary":"\u003cp\u003e在流里读出数据后，需要将数据包大小缩短成有效大小，即 \u003ccode\u003ebytesRead\u003c/code\u003e  长度。\u003c/p\u003e\n\u003cp\u003e下面是 C# 端接收并解析数据的示例代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eReceiveMessage\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estream\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eclient\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetStream\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebytesRead\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eisKeepReading\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estream\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCanRead\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ebuffer\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"kt\"\u003ebyte\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eclient\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eReceiveBufferSize\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ebytesRead\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estream\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eRead\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebuffer\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"m\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eclient\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eReceiveBufferSize\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebytesRead\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"m\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003eMemoryStream\u003c/span\u003e \u003cspan class=\"n\"\u003eprotoStream\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eMemoryStream\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebuffer\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"m\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ebytesRead\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003eCas\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eProto\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDataMessage\u003c/span\u003e \u003cspan class=\"n\"\u003edataMessage\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eCas\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eProto\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDataMessage\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eParser\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eParseFrom\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eprotoStream\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eswitch\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edataMessage\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eType\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"n\"\u003eDataMessage\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eTypes\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eType\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMesh\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t                    \t\u003cspan class=\"n\"\u003eDebug\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eLog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Mesh类型\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"k\"\u003edefault\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"C# Protobuf 接收数据并解析数据"},{"content":"当我们处理程序中的多个标志位时，将它们合并成一个整数是一种常见的技巧。这种做法不仅有助于提高代码的可读性，还使得对多个标志位进行操作更为方便。\n在C++中，可以使用按位或（|）运算符来实现这一功能。\n合并标志位的基本思想在C++中，合并标志位的基本思想是将多个标志位的二进制表示中的相应位进行按位或运算，形成一个包含所有标志位信息的整数。这样，就能够用一个整数表示多个不同的状态或选项。\n代码示例#include \u0026lt;iostream\u0026gt; int main() { // 定义三个标志位 const int FLAG_A = 0b0001; const int FLAG_B = 0b0010; const int FLAG_C = 0b0100; // 合并标志位 int flags = FLAG_A | FLAG_C; // 检查是否设置了某个标志位 if (flags \u0026amp; FLAG_A) {\t// True std::cout \u0026lt;\u0026lt; \u0026#34;FLAG_A is set.\u0026#34; \u0026lt;\u0026lt; std::endl; } if (flags \u0026amp; FLAG_B) {\t// False std::cout \u0026lt;\u0026lt; \u0026#34;FLAG_B is set.\u0026#34; \u0026lt;\u0026lt; std::endl; } if (flags \u0026amp; FLAG_C) {\t// True std::cout \u0026lt;\u0026lt; \u0026#34;FLAG_C is set.\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 在这个示例中，首先定义了三个标志位 FLAG_A、FLAG_B 和 FLAG_C，它们分别对应二进制的 0001、0010 和 0100。然后，使用 | 运算符将 FLAG_A 和 FLAG_C 合并成 flags。\n接下来，使用按位与运算符 \u0026amp; 来检查 flags 中是否设置了每个标志位。如果某个标志位被设置，相应的条件语句将会执行。\n优点与用途 可读性提高： 将多个标志位合并成一个整数可以提高代码的可读性。通过使用有意义的常量名称，可以更清晰地了解整数表示的含义。 便于操作： 合并后的整数可以方便地进行各种按位操作，如按位与、按位或等，而无需单独处理每个标志位。 节省内存： 在某些情况下，将多个标志位合并成一个整数可能节省内存，特别是当标志位数量较多时。 在实际编码中，合并标志位是一种常见的编程技巧，适用于需要处理多个二进制状态的情况。这种技术不仅简化了代码，还使得代码更易维护和扩展。\n","permalink":"https://blog.cassdev.com/posts/c++-%E4%B8%AD%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8%E4%B8%8E%E8%BF%90%E7%AE%97%E5%92%8C%E6%88%96%E8%BF%90%E7%AE%97%E7%9A%84%E5%90%88%E5%B9%B6%E6%A0%87%E5%BF%97%E4%BD%8D/","summary":"\u003cp\u003e当我们处理程序中的多个标志位时，将它们合并成一个整数是一种常见的技巧。这种做法不仅有助于提高代码的可读性，还使得对多个标志位进行操作更为方便。\u003c/p\u003e\n\u003cp\u003e在C++中，可以使用按位或（\u003ccode\u003e|\u003c/code\u003e）运算符来实现这一功能。\u003c/p\u003e\n\u003ch2 id=\"合并标志位的基本思想\"\u003e合并标志位的基本思想\u003c/h2\u003e\u003cp\u003e在C++中，合并标志位的基本思想是将多个标志位的二进制表示中的相应位进行按位或运算，形成一个包含所有标志位信息的整数。这样，就能够用一个整数表示多个不同的状态或选项。\u003c/p\u003e\n\u003ch2 id=\"代码示例\"\u003e代码示例\u003c/h2\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 定义三个标志位\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eFLAG_A\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mb\"\u003e0b0001\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eFLAG_B\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mb\"\u003e0b0010\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eFLAG_C\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mb\"\u003e0b0100\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 合并标志位\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eflags\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eFLAG_A\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"n\"\u003eFLAG_C\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 检查是否设置了某个标志位\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eflags\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eFLAG_A\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\t\t\u003cspan class=\"c1\"\u003e// True\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;FLAG_A is set.\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eflags\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eFLAG_B\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\t\t\u003cspan class=\"c1\"\u003e// False\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;FLAG_B is set.\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eflags\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eFLAG_C\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\t\t\u003cspan class=\"c1\"\u003e// True\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;FLAG_C is set.\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在这个示例中，首先定义了三个标志位 \u003ccode\u003eFLAG_A\u003c/code\u003e、\u003ccode\u003eFLAG_B\u003c/code\u003e 和 \u003ccode\u003eFLAG_C\u003c/code\u003e，它们分别对应二进制的 \u003ccode\u003e0001\u003c/code\u003e、\u003ccode\u003e0010\u003c/code\u003e 和 \u003ccode\u003e0100\u003c/code\u003e。然后，使用 \u003ccode\u003e|\u003c/code\u003e 运算符将 \u003ccode\u003eFLAG_A\u003c/code\u003e 和 \u003ccode\u003eFLAG_C\u003c/code\u003e 合并成 \u003ccode\u003eflags\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e接下来，使用按位与运算符 \u003ccode\u003e\u0026amp;\u003c/code\u003e 来检查 \u003ccode\u003eflags\u003c/code\u003e 中是否设置了每个标志位。如果某个标志位被设置，相应的条件语句将会执行。\u003c/p\u003e\n\u003ch2 id=\"优点与用途\"\u003e优点与用途\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e可读性提高：\u003c/strong\u003e 将多个标志位合并成一个整数可以提高代码的可读性。通过使用有意义的常量名称，可以更清晰地了解整数表示的含义。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e便于操作：\u003c/strong\u003e 合并后的整数可以方便地进行各种按位操作，如按位与、按位或等，而无需单独处理每个标志位。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e节省内存：\u003c/strong\u003e 在某些情况下，将多个标志位合并成一个整数可能节省内存，特别是当标志位数量较多时。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在实际编码中，合并标志位是一种常见的编程技巧，适用于需要处理多个二进制状态的情况。这种技术不仅简化了代码，还使得代码更易维护和扩展。\u003c/p\u003e","title":"C++ 中位运算的妙用：与运算和或运算的合并标志位"},{"content":"# .NET Install Tool for Extenstion ABC C/C++ C/C++ Extension Pack C/C++ Themes C# C# Dev Kit CMake CMake Language Support Cmake Tools Codelf Code Runner Code Snap Code Together Color Highlight Color Picker CSS Peek D Dev Containers Docker Doxygen Documentation Genertor EFG Git Graph git-commit-plugin GitHub Copilot GitHub Copilot Chat GitHub Copilot Labs GitHub Pull Resquest and Issues HI IntelliCode API Usage Examples IntelliCode for C# Dev Kit IntelliJ IDEA New UI Theme J Jetbrains Fleet Theme JetBrains Icon Theme JetBrains IDE Keymap KL Live Sever Live Share M Markdown Preview Github Styling Markdown Preview Mermaid Support Marp for VS Code MASM masm-code MASM/TASM Material Icon Theme mypy NOP Pylance Python QR Remote - SSH: Editing Configuration Files Remote - Development Remote Explorer REST API Ruff S Slidev T TODO Highlight v2 UV Vim VSCode DOSBox VSCode Git Commit Message W WSL XYZ Marp for VS Code ","permalink":"https://blog.cassdev.com/posts/cassius0924-%E7%9A%84-vscode-%E6%8F%92%E4%BB%B6/","summary":"\u003ch2 id=\"heading\"\u003e#\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e.NET Install Tool for Extenstion\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a\"\u003eA\u003c/h2\u003e\u003ch2 id=\"b\"\u003eB\u003c/h2\u003e\u003ch2 id=\"c\"\u003eC\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eC/C++\u003c/li\u003e\n\u003cli\u003eC/C++ Extension Pack\u003c/li\u003e\n\u003cli\u003eC/C++ Themes\u003c/li\u003e\n\u003cli\u003eC#\u003c/li\u003e\n\u003cli\u003eC# Dev Kit\u003c/li\u003e\n\u003cli\u003eCMake\u003c/li\u003e\n\u003cli\u003eCMake Language Support\u003c/li\u003e\n\u003cli\u003eCmake Tools\u003c/li\u003e\n\u003cli\u003eCodelf\u003c/li\u003e\n\u003cli\u003eCode Runner\u003c/li\u003e\n\u003cli\u003eCode Snap\u003c/li\u003e\n\u003cli\u003eCode Together\u003c/li\u003e\n\u003cli\u003eColor Highlight\u003c/li\u003e\n\u003cli\u003eColor Picker\u003c/li\u003e\n\u003cli\u003eCSS Peek\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"d\"\u003eD\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eDev Containers\u003c/li\u003e\n\u003cli\u003eDocker\u003c/li\u003e\n\u003cli\u003eDoxygen Documentation Genertor\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"e\"\u003eE\u003c/h2\u003e\u003ch2 id=\"f\"\u003eF\u003c/h2\u003e\u003ch2 id=\"g\"\u003eG\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eGit Graph\u003c/li\u003e\n\u003cli\u003egit-commit-plugin\u003c/li\u003e\n\u003cli\u003eGitHub Copilot\u003c/li\u003e\n\u003cli\u003eGitHub Copilot Chat\u003c/li\u003e\n\u003cli\u003eGitHub Copilot Labs\u003c/li\u003e\n\u003cli\u003eGitHub Pull Resquest and Issues\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"h\"\u003eH\u003c/h2\u003e\u003ch2 id=\"i\"\u003eI\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eIntelliCode API Usage Examples\u003c/li\u003e\n\u003cli\u003eIntelliCode for C# Dev Kit\u003c/li\u003e\n\u003cli\u003eIntelliJ IDEA New UI Theme\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"j\"\u003eJ\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eJetbrains Fleet Theme\u003c/li\u003e\n\u003cli\u003eJetBrains Icon Theme\u003c/li\u003e\n\u003cli\u003eJetBrains IDE Keymap\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"k\"\u003eK\u003c/h2\u003e\u003ch2 id=\"l\"\u003eL\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eLive Sever\u003c/li\u003e\n\u003cli\u003eLive Share\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"m\"\u003eM\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eMarkdown Preview Github Styling\u003c/li\u003e\n\u003cli\u003eMarkdown Preview Mermaid Support\u003c/li\u003e\n\u003cli\u003eMarp for VS Code\u003c/li\u003e\n\u003cli\u003eMASM\u003c/li\u003e\n\u003cli\u003emasm-code\u003c/li\u003e\n\u003cli\u003eMASM/TASM\u003c/li\u003e\n\u003cli\u003eMaterial Icon Theme\u003c/li\u003e\n\u003cli\u003emypy\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"n\"\u003eN\u003c/h2\u003e\u003ch2 id=\"o\"\u003eO\u003c/h2\u003e\u003ch2 id=\"p\"\u003eP\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003ePylance\u003c/li\u003e\n\u003cli\u003ePython\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"q\"\u003eQ\u003c/h2\u003e\u003ch2 id=\"r\"\u003eR\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eRemote - SSH: Editing Configuration Files\u003c/li\u003e\n\u003cli\u003eRemote - Development\u003c/li\u003e\n\u003cli\u003eRemote Explorer\u003c/li\u003e\n\u003cli\u003eREST API\u003c/li\u003e\n\u003cli\u003eRuff\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"s\"\u003eS\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eSlidev\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"t\"\u003eT\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eTODO Highlight v2\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"u\"\u003eU\u003c/h2\u003e\u003ch2 id=\"v\"\u003eV\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eVim\u003c/li\u003e\n\u003cli\u003eVSCode DOSBox\u003c/li\u003e\n\u003cli\u003eVSCode Git Commit Message\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"w\"\u003eW\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eWSL\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"x\"\u003eX\u003c/h2\u003e\u003ch2 id=\"y\"\u003eY\u003c/h2\u003e\u003ch2 id=\"z\"\u003eZ\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eMarp for VS Code\u003c/li\u003e\n\u003c/ul\u003e","title":"Cassius0924 的 VSCode 插件"},{"content":"Google Coral Dev Board 是一款功能强大的开发板，可用于构建机器学习应用程序。该板配备了 Edge TPU，这是一款专门用于机器学习任务的加速器。Edge TPU 非常高效，但它也可能会产生热量。如果温度过高，Edge TPU 可能会降频或关闭。\n查看目前 TPU 温度使用命令查看目前开发板核心 TPU 的温度，输出温度为1000倍的摄氏度。\ncat /sys/class/thermal/thermal_zone0/temp 如输出54000，则代表当前温度为54摄氏度。\n修改散热器温度阈值禁用热管理：\necho \u0026#34;disabled\u0026#34; \u0026gt; /sys/devices/virtual/thermal/thermal_zone0/mode 修改散热器温度阈值为50摄氏度\necho 50000 \u0026gt; /sys/devices/platform/gpio_fan/hwmon/hwmon0/fan1_target ","permalink":"https://blog.cassdev.com/posts/google-coral-dev-board-%E4%BF%AE%E6%94%B9%E9%A3%8E%E6%89%87%E8%BD%AC%E5%8A%A8%E6%B8%A9%E5%BA%A6%E9%98%88%E5%80%BC%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003eGoogle Coral Dev Board 是一款功能强大的开发板，可用于构建机器学习应用程序。该板配备了 Edge TPU，这是一款专门用于机器学习任务的加速器。Edge TPU 非常高效，但它也可能会产生热量。如果温度过高，Edge TPU 可能会降频或关闭。\u003c/p\u003e\n\u003ch2 id=\"查看目前-tpu-温度\"\u003e查看目前 TPU 温度\u003c/h2\u003e\u003cp\u003e使用命令查看目前开发板核心 TPU 的温度，输出温度为1000倍的摄氏度。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat /sys/class/thermal/thermal_zone0/temp\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如输出\u003ccode\u003e54000\u003c/code\u003e，则代表当前温度为54摄氏度。\u003c/p\u003e\n\u003ch2 id=\"修改散热器温度阈值\"\u003e修改散热器温度阈值\u003c/h2\u003e\u003cp\u003e禁用热管理：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;disabled\u0026#34;\u003c/span\u003e \u0026gt; /sys/devices/virtual/thermal/thermal_zone0/mode\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e修改散热器温度阈值为50摄氏度\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"m\"\u003e50000\u003c/span\u003e \u0026gt; /sys/devices/platform/gpio_fan/hwmon/hwmon0/fan1_target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Google Coral Dev Board 修改风扇转动温度阈值指南"},{"content":"介绍HammerSpoon 这是一款强大的OS X自动化工具。\nHammerSpoon 本质上就是操作系统和Lua脚本引擎之间的桥梁。\nHammerSpoon 之所以强大，在于它提供了一系列向用户公开特定系统功能模块的扩展。有了这些扩展，用户便可利用Lua脚本来控制 macOS 的各个方面。\n安装建议直接使用 Homebrew 安装。\nbrew install hammerspoon --cask 手动安装参考官方 Github。\n参考文档 HammerSpoon 入门指南 HammerSpoon API 文档 HammerSpoon 常见问题 HammerSpoon 配置示例 快速开始启动应用安装完毕后启动 HammerSpoon，设置中打开辅助功能。\n接着点击 Open Config 打开配置文件。下面开始教程。\nHello World-- Hello World hs.hotkey.bind({\u0026#34;cmd\u0026#34;, \u0026#34;alt\u0026#34;, \u0026#34;shift\u0026#34;, \u0026#34;ctrl\u0026#34;}, \u0026#34;W\u0026#34;, function() hs.alert.show(\u0026#34;HammerSpoon is working!\u0026#34;) end) 每次修改配置文件后都需要点击 Reload Config。\n以上代码实现了点击快捷键 command + option + shift + control + w，在屏幕中间显示弹窗提示的功能。\n也可以使用 macOS 原生通知形式\n-- Hello World（macOS native notification） hs.hotkey.bind({\u0026#34;cmd\u0026#34;, \u0026#34;alt\u0026#34;, \u0026#34;shift\u0026#34;, \u0026#34;ctrl\u0026#34;}, \u0026#34;Q\u0026#34;, function() hs.notify.new({title=\u0026#34;macOS Native Notification\u0026#34;, informativeText=\u0026#34;HammerSpoon is working\u0026#34;}):send() end) hs.hotkey API 介绍\nhs.notify API 介绍\n","permalink":"https://blog.cassdev.com/posts/hammerspoon-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","summary":"\u003ch2 id=\"介绍\"\u003e介绍\u003c/h2\u003e\u003cp\u003eHammerSpoon 这是一款强大的OS X自动化工具。\u003c/p\u003e\n\u003cp\u003eHammerSpoon 本质上就是操作系统和Lua脚本引擎之间的桥梁。\u003c/p\u003e\n\u003cp\u003eHammerSpoon 之所以强大，在于它提供了一系列向用户公开特定系统功能模块的扩展。有了这些扩展，用户便可利用Lua脚本来控制 macOS 的各个方面。\u003c/p\u003e\n\u003ch2 id=\"安装\"\u003e安装\u003c/h2\u003e\u003cp\u003e建议直接使用 Homebrew 安装。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ebrew install hammerspoon --cask\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e手动安装参考\u003ca href=\"https://github.com/Hammerspoon/hammerspoon\"\u003e官方 Github\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"参考文档\"\u003e参考文档\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.hammerspoon.org/go/\"\u003eHammerSpoon 入门指南\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.hammerspoon.org/docs/\"\u003eHammerSpoon API 文档\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.hammerspoon.org/faq/\"\u003eHammerSpoon 常见问题\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Hammerspoon/hammerspoon/wiki/Sample-Configurations\"\u003eHammerSpoon 配置示例\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"快速开始\"\u003e快速开始\u003c/h2\u003e\u003ch3 id=\"启动应用\"\u003e启动应用\u003c/h3\u003e\u003cp\u003e安装完毕后启动 HammerSpoon，设置中打开辅助功能。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"HS Preferences\" loading=\"lazy\" src=\"https://s2.loli.net/2023/08/06/ZkNiYmXvIRPJ4bs.png\"\u003e\u003c/p\u003e\n\u003cp\u003e接着点击 Open Config 打开配置文件。下面开始教程。\u003c/p\u003e\n\u003ch3 id=\"hello-world\"\u003eHello World\u003c/h3\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-lua\" data-lang=\"lua\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e-- Hello World\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ehs.hotkey\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebind\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;cmd\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;alt\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;shift\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;ctrl\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e},\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;W\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kr\"\u003efunction\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ehs.alert\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eshow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;HammerSpoon is working!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e每次修改配置文件后都需要点击 Reload Config。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e以上代码实现了点击快捷键 \u003ccode\u003ecommand\u003c/code\u003e + \u003ccode\u003eoption\u003c/code\u003e + \u003ccode\u003eshift\u003c/code\u003e + \u003ccode\u003econtrol\u003c/code\u003e + \u003ccode\u003ew\u003c/code\u003e，在屏幕中间显示弹窗提示的功能。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Hello World\" loading=\"lazy\" src=\"https://s2.loli.net/2023/08/06/PR3k6Ty4K5AVIqx.png\"\u003e\u003c/p\u003e\n\u003cp\u003e也可以使用 macOS 原生通知形式\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-lua\" data-lang=\"lua\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e-- Hello World（macOS native notification）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ehs.hotkey\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebind\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;cmd\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;alt\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;shift\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;ctrl\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e},\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Q\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kr\"\u003efunction\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ehs.notify\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"n\"\u003etitle\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;macOS Native Notification\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003einformativeText\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;HammerSpoon is working\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e}):\u003c/span\u003e\u003cspan class=\"n\"\u003esend\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg alt=\"macOS native notification\" loading=\"lazy\" src=\"https://s2.loli.net/2023/08/06/HwxemCVBGf1KNnh.png\"\u003e\n\u003cimg alt=\"[bg right opacity]\" loading=\"lazy\" src=\"https://s2.loli.net/2023/08/06/HwxemCVBGf1KNnh.png\"\u003e\u003c/p\u003e","title":"HammerSpoon 入门指南"},{"content":"问题当项目在 Unity 测试 Mesh 面片渲染正常，而打包部署到 HoloLens 后就无法正常显示 Mesh 面片了。\n失败原因可能出在 Holo 不支持程序代码所用的 Shader 着色器，需要使用 MRTK3 官方提供的 Shader 着色器。\n解决方法默认前提你的项目已经安装了 MRTK3 开发包。\nMRTK3 官方可用的彩色 Mesh 着色器为 Mixed Reality Toolkit/Dashed Ray。\nUnityEngine.Mesh mesh = new UnityEngine.Mesh(); mesh.indexFormat = UnityEngine.Rendering.IndexFormat.UInt32;\t#当面片数量超过65535时需要设置此项 GetComponent\u0026lt;MeshFilter\u0026gt;().mesh = mesh; Material material = new Material(Shader.Find(\u0026#34;Mixed Reality Toolkit/Dashed Ray\u0026#34;)); GetComponent\u0026lt;MeshRenderer\u0026gt;().material = material; ","permalink":"https://blog.cassdev.com/posts/hololens-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%B8%B2%E6%9F%93%E4%B8%8D%E5%87%BA-mesh-%E9%9D%A2%E7%89%87%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","summary":"\u003ch2 id=\"问题\"\u003e问题\u003c/h2\u003e\u003cp\u003e当项目在 Unity 测试 Mesh 面片渲染正常，而打包部署到 HoloLens 后就无法正常显示 Mesh 面片了。\u003c/p\u003e\n\u003cp\u003e失败原因可能出在 Holo 不支持程序代码所用的 Shader 着色器，需要使用 MRTK3 官方提供的 Shader 着色器。\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\u003cp\u003e默认前提你的项目已经安装了 MRTK3 开发包。\u003c/p\u003e\n\u003cp\u003eMRTK3 官方可用的彩色 Mesh 着色器为 \u003ccode\u003eMixed Reality Toolkit/Dashed Ray\u003c/code\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eUnityEngine\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMesh\u003c/span\u003e \u003cspan class=\"n\"\u003emesh\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eUnityEngine\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMesh\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003emesh\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eindexFormat\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eUnityEngine\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eRendering\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eIndexFormat\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eUInt32\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\t\t\u003cspan class=\"err\"\u003e#当面片数量超过\u003c/span\u003e\u003cspan class=\"m\"\u003e65535\u003c/span\u003e\u003cspan class=\"err\"\u003e时需要设置此项\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eGetComponent\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eMeshFilter\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;().\u003c/span\u003e\u003cspan class=\"n\"\u003emesh\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emesh\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eMaterial\u003c/span\u003e \u003cspan class=\"n\"\u003ematerial\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eMaterial\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eShader\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eFind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Mixed Reality Toolkit/Dashed Ray\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eGetComponent\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eMeshRenderer\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;().\u003c/span\u003e\u003cspan class=\"n\"\u003ematerial\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ematerial\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"HoloLens 应用程序渲染不出 Mesh 面片的解决方法"},{"content":"配置步骤按下 cmd + , 打开 iTerm2 设置，选择 Profiles 面板，切换到 Keys 选项卡，点击 Configure Hotkey Windows。\n打勾 Pin hotkey window 选项。\n大功告成，配置完后鼠标在点击 iTerm2 命令行窗口以外的界面时，命令行窗口就不会自动隐藏了。\n","permalink":"https://blog.cassdev.com/posts/iterm2-%E9%85%8D%E7%BD%AE%E5%A4%B1%E5%8E%BB%E7%84%A6%E7%82%B9%E6%97%B6%E4%BF%9D%E6%8C%81%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%8C%87%E5%8D%97/","summary":"\u003ch2 id=\"配置步骤\"\u003e配置步骤\u003c/h2\u003e\u003cp\u003e按下 \u003ccode\u003ecmd\u003c/code\u003e + \u003ccode\u003e,\u003c/code\u003e 打开 iTerm2 设置，选择 Profiles 面板，切换到 Keys 选项卡，点击 Configure Hotkey Windows。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2023-11-10 at 17.09.07@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/11/10/nyprlVNkUzZuTHj.png\"\u003e\u003c/p\u003e\n\u003cp\u003e打勾 Pin hotkey window 选项。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2023-11-10 at 17.11.26@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/11/10/mjWFbGafINvCt6r.png\"\u003e\u003c/p\u003e\n\u003cp\u003e大功告成，配置完后鼠标在点击 iTerm2 命令行窗口以外的界面时，命令行窗口就不会自动隐藏了。\u003c/p\u003e","title":"iTerm2 配置失去焦点时保持命令行窗口指南"},{"content":"本文将为你介绍 Jtop，它是一个基于 Python 的系统监控工具。Jtop 通过终端界面展示系统资源的使用情况，包括 CPU、内存、磁盘、网络等。本文将详细介绍 Jtop 各个面板的作用和功能。\n安装先安装pip3\nsudo apt install python3-pip Jtop 可以通过 pip 来安装，您可以通过以下命令来安装：\nsudo pip3 install -U jetson-stats 使用在终端中输入以下命令来启动 Jtop：\njtop 在 Jtop 启动后，您可以使用键盘的左右箭头来选择面板，使用 Tab 键来切换到不同的面板，使用 Ctrl + C 命令来退出 Jtop。\n面板介绍ALL 面板ALL 面板简要展示了主板的各种信息，包括 CPU、GPU、内存、磁盘、风扇以及关于 jetson_clocks、NVPmodel 等的信息。\nGPU 面板GPU 面板主要展示了系统 GPU 的使用情况。在 GPU 面板中，您可以看到系统当前的 GPU 利用率、GPU 温度、GPU 风扇转速、 GPU 内存使用情况等信息。同时，您也可以查看各个进程对 GPU 的使用情况。\nCPU 面板CPU 面板主要展示了系统 CPU 的使用情况。在 CPU 面板中，您可以看到系统当前的 CPU 利用率、每个 CPU 核心的利用率、以及各个进程的 CPU 使用情况。您可以使用键盘上下箭头来选择进程，使用回车键来查看进程详情。\nMEM 面板内存面板主要展示了系统内存的使用情况。在内存面板中，您可以看到系统当前的内存利用率、总内存、可用内存、已经使用的内存等信息。同时，您也可以查看各个进程的内存使用情况。\nENG 面板ENG 面板主要展示了系统的发热情况。在 ENG 面板中，您可以看到系统当前的 CPU 温度、GPU 温度、以及各个进程的 CPU 温度。\nCTRL 面板CTRL 面板主要展示了系统的控制情况。在 CTRL 面板中，您可以看到系统当前的 CPU 频率、GPU 频率、以及各个进程的 CPU 频率。\nINFO 面板INFO 面板主要展示了系统的信息。在 INFO 面板中，您可以看到系统当前的 IP 地址、MAC 地址、以及各个进程的 CPU 频率。\n📝 结尾希望本文介绍的内容能够对您使用 Jtop 有所帮助。如果您在使用 Jtop 的过程中遇到了问题，可以到项目的 Github 页面中提出 issues，我们会尽快解答您的问题。同时，我们也欢迎各位开发者为 Jtop 的开发做出贡献，感谢您的支持！\n","permalink":"https://blog.cassdev.com/posts/jetson-nano-%E5%AE%89%E8%A3%85-jtop-%E5%92%8C-jtop-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e本文将为你介绍 Jtop，它是一个基于 Python 的系统监控工具。Jtop 通过终端界面展示系统资源的使用情况，包括 CPU、内存、磁盘、网络等。本文将详细介绍 Jtop 各个面板的作用和功能。\u003c/p\u003e\n\u003ch2 id=\"安装\"\u003e安装\u003c/h2\u003e\u003cp\u003e先安装\u003ccode\u003epip3\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install python3-pip\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eJtop 可以通过 pip 来安装，您可以通过以下命令来安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo pip3 install -U jetson-stats\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"使用\"\u003e使用\u003c/h2\u003e\u003cp\u003e在终端中输入以下命令来启动 Jtop：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ejtop\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 Jtop 启动后，您可以使用键盘的左右箭头来选择面板，使用 Tab 键来切换到不同的面板，使用 Ctrl + C 命令来退出 Jtop。\u003c/p\u003e\n\u003ch2 id=\"面板介绍\"\u003e面板介绍\u003c/h2\u003e\u003ch3 id=\"all-面板\"\u003eALL 面板\u003c/h3\u003e\u003cp\u003eALL 面板简要展示了主板的各种信息，包括 CPU、GPU、内存、磁盘、风扇以及关于 jetson_clocks、NVPmodel 等的信息。\u003c/p\u003e\n\u003ch3 id=\"gpu-面板\"\u003eGPU 面板\u003c/h3\u003e\u003cp\u003eGPU 面板主要展示了系统 GPU 的使用情况。在 GPU 面板中，您可以看到系统当前的 GPU 利用率、GPU 温度、GPU 风扇转速、 GPU 内存使用情况等信息。同时，您也可以查看各个进程对 GPU 的使用情况。\u003c/p\u003e\n\u003ch3 id=\"cpu-面板\"\u003eCPU 面板\u003c/h3\u003e\u003cp\u003eCPU 面板主要展示了系统 CPU 的使用情况。在 CPU 面板中，您可以看到系统当前的 CPU 利用率、每个 CPU 核心的利用率、以及各个进程的 CPU 使用情况。您可以使用键盘上下箭头来选择进程，使用回车键来查看进程详情。\u003c/p\u003e\n\u003ch3 id=\"mem-面板\"\u003eMEM 面板\u003c/h3\u003e\u003cp\u003e内存面板主要展示了系统内存的使用情况。在内存面板中，您可以看到系统当前的内存利用率、总内存、可用内存、已经使用的内存等信息。同时，您也可以查看各个进程的内存使用情况。\u003c/p\u003e","title":"Jetson nano 安装 Jtop 和 Jtop 使用指南"},{"content":"由于 Jetson 为 ARM64 (aarch64) 的系统架构，所以不能用 pip install 直接安装，需要通过源码编译。\n升级系统 JetPack由于 Open3D-ML 目前只支持 CUDA 10.0 以及 CUDA 11.*，并且 JetPack 的 CUDA 开发环境只有10.2、11.4以及12.2，所以我们只能选择 CUDA 11.4 进行安装。\n使用 jtop命令查看 JetPack 版本。如果 Jetson 系统的 JetPack 低于 5.1.2 则需要通过 SDK Manager 升级到 JetPack 5.1.2。\n如果你的系统已经是 JetPack 5.1.2 那我也推荐你通过 SDK Manager 重新安装一遍，排除难以发现的错误。\n详细指南参考文章[Jetson Xavier NX 升级或重新安装 JetPack 指南]。\n安装 PyTorch安装教程参考文章[Jetson Xavier NX 安装 CUDA 支持的 Pytorch 指南]。\n注意，PyTorch 的 CUDA 支持版本需要和 Open3D-ML 的一致，同为 CUDA 11.4。否则与最后安装 Open3D-ML 的时候会报错：\n下载源码下载 Open3D 源码如果你之前下载过则不需要再下载：\ngit clone https://github.com/isl-org/Open3D.git 下载 Open3D-ML 源码git clone https://github.com/isl-org/Open3D-ML.git 前提准备安装依赖：\ncd Open3D bash util/install_deps_ubuntu.sh pip install yapf 重新链接 6.0.29 的 libstdc++.so，否则会出现undefined reference to 'std::__throw_bad_array_new_Length()@GLIBCXX_3.4.29'的错误。\nln -sf /usr/local/lib64/libstdc++.so.6.0.29 /lib/aarch64-linux-gnu/libstdc++.so.6 编译安装国际惯例，先创建一个 build 文件夹。\nmkdir build cd build sudo cmake \\ -DBUILD_CUDA_MODULE=ON \\ -DBUILD_PYTORCH_OPS=ON \\ -DBUILD_TENSORFLOW_OPS=OFF \\ -DBUILD_EXAMPLES=OFF \\ -DBUILD_SHARED_LIBS=ON \\ -DCMAKE_BUILD_TYPE=Release \\ -DGLIBCXX_USE_CXX11_ABI=ON \\ -DBUILD_PYTHON_MODULE=ON \\ -DBUNDLE_OPEN3D_ML=ON \\ -DCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda \\ -DPython3_EXECUTABLE=/path/to/python \\ -DOPEN3D_ML_ROOT=../../Open3D-ML \\ .. -DBUILD_PYTORCH_OPS和-DBUILD_TENSORFLOW_OPS分别为构建 PyTorch 版和构建 Tensorflow 版选项，两个选择可以同时为ON，本指南只构建 PyTorch。\n-DBUILD_EXAMPLES表示是否构建官方示例，这里设置OFF不构建，可以缩短构建时间。\n如果没有使用 Python 虚拟环境，则不需要-DPython3_EXECUTABLE；如果使用了 Python 虚拟环境，需要改成虚拟环境的 Python 的路径，使用which python查看路径。\n-DOPEN3D_ML_ROOT为刚刚下载的 Open-ML 的源代码路径。\n编译：\nmake -j$(nproc) 编译过程需要数个小时的时间。\n编译完毕后需要添加一个环境变量：\nvim ~/.zsh #或者 ~/.bashrc 在文件末尾添加一行：\nexport LD_PRELOAD=/usr/local/lib/libOpen3D.so 安装 Open3D C++ 库：\nmake install 安装 Open3D 与 Open3D-ML Python 库：\nmake install-pip-package -j$(nproc) 错误解决undefined reference to \u0026lsquo;***\u0026rsquo; @GLIBCXX_3.4.29这个错误问题出在系统的 libstdc++ 版本不够高。尝试使用strings /lib/aarch64-linux-gnu/libstdc++.so.6 | grep GLIBCXX命令查看 libstdc++ 是否支持 GLIBCXX_3.4.29，如果缺少 GLIBCXX_3.4.29 则请尝试软链接 libstdc++.so.6 到正确版本。\nln -sf /usr/local/lib64/libstdc++.so.6.0.29 /lib/aarch64-linux-gnu/libstdc++.so.6 如果提示找不到 libstdc++.so.6.0.29 文件，则请升级 libstdc++ 库。\nCMAKE_CUDA_ARCHITECTURES now detected for NVCC检查系统默认 CUDA 版本是否存在 nvcc 二进制文件。\nsudo stat /usr/local/cuda/bin/nvcc 若提示不存在文件，则 CUDA 开发环境已经损坏，需要重新安装 JetPack。详细参考文章 [Jetson Xavier NX 升级或重新安装 JetPack 指南]。\n/lib/Release/libOpen3D.so: cannot allocate memory in static TLS blockvim ~/.zsh #或者 ~/.bashrc 在文件末尾添加一行：\nexport LD_PRELOAD=/usr/local/lib/libOpen3D.so ModuleNotFoundError: No module named ‘jupyter_packaging’pip install jupyter-packaging ModuleNotFoundError: No module named ‘ipywidgets’pip install ipywidgets Open3D was built with CUDA 11.4 but PyTorch was built with CUDA 10.2这个警告表示，PyTorch 的 CUDA 版本和 Open3D-ML 的 CUDA 版本不一致。需要使用与 Open3D-ML 一致的 CUDA 版本重新构建安装 PyTorch。详细请参考文章[Jetson Xavier NX 安装 CUDA 支持的 Pytorch 指南]。\n测试验证python3 -c \u0026#34;import open3d.ml.torch\u0026#34; 若无任何输出，则表示安装成功。\n","permalink":"https://blog.cassdev.com/posts/jetson-xavier-nx-arm-%E4%BD%BF%E7%94%A8-pytorch-%E5%AE%89%E8%A3%85-open3d-ml-%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e由于 Jetson 为 ARM64 (aarch64) 的系统架构，所以不能用\u003ccode\u003e pip install\u003c/code\u003e 直接安装，需要通过源码编译。\u003c/p\u003e\n\u003ch2 id=\"升级系统-jetpack\"\u003e升级系统 JetPack\u003c/h2\u003e\u003cp\u003e由于 Open3D-ML 目前只支持 CUDA 10.0 以及 CUDA 11.*，并且  JetPack 的 CUDA 开发环境只有10.2、11.4以及12.2，所以我们只能选择 CUDA 11.4 进行安装。\u003c/p\u003e\n\u003cp\u003e使用 \u003ccode\u003ejtop\u003c/code\u003e命令查看 JetPack 版本。如果 Jetson 系统的 JetPack 低于 5.1.2 则需要通过 SDK Manager 升级到 JetPack 5.1.2。\u003c/p\u003e\n\u003cp\u003e如果你的系统已经是 JetPack 5.1.2 那我也推荐你通过 SDK Manager 重新安装一遍，排除难以发现的错误。\u003c/p\u003e\n\u003cp\u003e详细指南参考文章[Jetson Xavier NX 升级或重新安装 JetPack 指南]。\u003c/p\u003e\n\u003ch2 id=\"安装-pytorch\"\u003e安装 PyTorch\u003c/h2\u003e\u003cp\u003e安装教程参考文章[Jetson Xavier NX 安装 CUDA 支持的 Pytorch 指南]。\u003c/p\u003e\n\u003cp\u003e注意，PyTorch 的 CUDA 支持版本需要和 Open3D-ML 的一致，同为 CUDA 11.4。否则与最后安装 Open3D-ML 的时候会报错：\u003c/p\u003e","title":"Jetson Xavier NX (ARM) 使用 PyTorch 安装 Open3D-ML 指南"},{"content":"本指南将帮助开发者完成在 Jetson Xavier NX 上安装 CUDA 支持的 PyTorch。\n安装方法在 Jetson 上安装 Pytorch 只有两种方法。\n一种是直接安装他人已经编译好的 PyTorch 轮子； 一种是自己从头开始开始构建 PyTorch 轮子并且安装。 使用轮子安装可以从我的 GitHub 仓库 直接下载我编译好的 PyTorch 轮子（torch-1.13.0-cuda-11.4-python-3.8-aarch64）。\n安装前先确保 python 版本为 PyTorch 轮子对应的 Python 3.8。\n下载完毕后使用pip install安装：\nsudo -H pip install torch-1.13.0a0+git7c98e70-cp38-cp38-linux_aarch64.whl 如果你以前安装过 torch 的其他版本，则需要添加--force-reinstall覆盖安装。\n其他低于 CUDA 11 的 PyTorch 轮子可以在 Qengineering 的 GitHub 仓库 寻找。\n编译源码安装接下来说一下重点，自己从源码构建轮子并安装。自行构建需要花费数个小时的时间。\nPyTroch 1.11.0 以及以上版本只能在 Ubuntu 20.04 上安装。\n安装依赖sudo apt-get update sudo apt-get upgrade sudo apt-get install ninja-build git cmake sudo apt-get install libjpeg-dev libopenmpi-dev libomp-dev ccache libopenblas-dev libblas-dev libeigen3-dev sudo pip3 install -U --user wheel mock pillow sudo -H pip3 install testresources setuptools==58.3.0 scikit-build 下载源码请克隆自己需要的 PyTorch 版本，修改-b后的版本参数。\ngit clone -b v1.13.0 --depth=1 --recursive https://github.com/pytorch/pytorch.git cd pytorch 扩大交换内存构建 PyTorch 需要大于 4GB 的 RAM 和 2GB 的交换内存。\n先使用free -m查看当前的交换内存。\n安装dphys-swapfiel：\nsudo apt-get install dphys-swapfile 需要修改两个文件/sbin/dphys-swapfile和/etc/dphys-swapfile。\n先修改/sbin/dphys-swapfile的第30行，将CONF_MAXSWAP=2048修改成4096：\nsudo vim /sbin/dphys-swapfile 再修改/etc/dphys-swapfile的第26行，将#去掉，后面加上4096：\nsudo vim /etc/dphys-swapfile 保存修改后重启系统。\nsudo reboot 重启完毕后可以使用 free -m 查看交换内存是否扩大成功。\n使用 GCC请使用 GCC 和 G++ 编译器，如果使用 GNU 编译器会导致浮点数出现错误的问题，使用 Clang 编译器在构建 CUDA 11.4 的 PyTorch 时候会报错。\n设置 CUDA 版本修改环境变量修改系统环境变量，如果你使用的是 bash 则修改 ~/.bashrc，如果使用 zsh 则修改 ~/.zshrc。\nvim ~/.zshrc #或 ~/.bashrc 在文件末尾添加三行：\nexport CUDA_HOME=/usr/local/cuda export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64:/usr/local/cuda/extras/CUPTI/lib64 export PATH=$PATH:$CUDA_HOME/bin 如果你之前添加过 CUDA 的环境变量，则直接在对应行修改。\n保存并退出，应用修改：\nsource ~/.zshrc #或 ~/.bashrc 切换 CUDA 版本先切换系统 CUDA 版本到即将编译的 CUDA 版本，这里以 CUDA 11.4 为例。\nsudo update-alternatives --config cuda 选择2，回车。\n修改 CMakeLists.txt需要在 CMakeLists.txt 文件里指定 CUDA 编译器的路径。\ncd pytorch vim CMakeLists.txt 在 project(Torch CXX C)上方添加一行 set(CMAKE_CUDA_COMPILER /usr/local/cuda/bin/nvcc)\n保存并退出。\n构建 PyTorch设置 Ninja 构建参数需要添加一些环境变量。\nexport BUILD_CAFFE2_OPS=OFF export USE_FBGEMM=OFF export USE_FAKELOWP=OFF export BUILD_TEST=OFF export USE_MKLDNN=OFF export USE_NNPACK=OFF export USE_XNNPACK=OFF export USE_QNNPACK=OFF export USE_PYTORCH_QNNPACK=OFF export USE_CUDA=ON export USE_CUDNN=ON export TORCH_CUDA_ARCH_LIST=\u0026#34;5.3;6.2;7.2\u0026#34; export USE_NCCL=OFF export USE_SYSTEM_NCCL=OFF export USE_OPENCV=OFF export MAX_JOBS=4 export PATH=/usr/lib/ccache:$PATH export CC=gcc export CXX=g++ export CUDACXX=/usr/local/cuda/bin/nvcc export CUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda sudo ln -s /usr/lib/aarch64-linux-gnu/libcublas.so /usr/local/cuda/lib64/libcublas.so 开始构建 PyTorchpython3 setup.py bdist_wheel 如果构建过程中报错，需要重新构建，请先用python3 setup.py clean重置构建。\n安装 PyTorch经过漫长的编译，编译好的.whl轮子文件会放在dist文件夹里。\ncd dist sudo -H pip3 install \u0026lt;torch文件\u0026gt;.whl 如果你以前安装过 torch 的其他版本，则需要添加--force-reinstall覆盖安装：\nsudo -H pip3 install \u0026lt;torch文件\u0026gt;.whl --force-reinstall 验证安装导入验证 torch 不能在 PyTorch 源代码目录，否则会报错，先用cd ../..退出源代码文件夹。\npython3 -c \u0026#34;import torch as t; print(t.__version__); print(t.version.cuda); print(t.cuda.is_available());\u0026#34; 大功告成！\n清理空间先停 dphys-swapfile：\nsudo /etc/init.d/dphys-swapfile stop 如果磁盘空间紧缺，可以将 PyTorch 源代码删除，不过删除前建议先将 Jetson 辛辛苦苦构建 PyTorch 轮子备份保存一下。\nmv pytorch/dist/*.whl ~ 删除源代码：\nrm -r pytorch ","permalink":"https://blog.cassdev.com/posts/jetson-xavier-nx-%E5%AE%89%E8%A3%85-cuda-%E6%94%AF%E6%8C%81%E7%9A%84-pytorch-%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e本指南将帮助开发者完成在 Jetson Xavier NX 上安装 CUDA 支持的 PyTorch。\u003c/p\u003e\n\u003ch2 id=\"安装方法\"\u003e安装方法\u003c/h2\u003e\u003cp\u003e在 Jetson 上安装 Pytorch 只有两种方法。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一种是直接安装他人已经编译好的 PyTorch 轮子；\u003c/li\u003e\n\u003cli\u003e一种是自己从头开始开始构建 PyTorch 轮子并且安装。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"使用轮子安装\"\u003e使用轮子安装\u003c/h2\u003e\u003cp\u003e可以从我的 \u003ca href=\"https://github.com/Cassius0924/JetsonPytorch/\"\u003eGitHub 仓库\u003c/a\u003e 直接下载我编译好的 PyTorch 轮子（torch-1.13.0-cuda-11.4-python-3.8-aarch64）。\u003c/p\u003e\n\u003cp\u003e安装前先确保 python 版本为 PyTorch 轮子对应的 Python 3.8。\u003c/p\u003e\n\u003cp\u003e下载完毕后使用\u003ccode\u003epip install\u003c/code\u003e安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo -H pip install torch-1.13.0a0+git7c98e70-cp38-cp38-linux_aarch64.whl\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果你以前安装过 torch 的其他版本，则需要添加\u003ccode\u003e--force-reinstall\u003c/code\u003e覆盖安装。\u003c/p\u003e\n\u003cp\u003e其他低于 CUDA 11 的 PyTorch 轮子可以在 \u003ca href=\"https://github.com/Qengineering/PyTorch-Jetson-Nano\"\u003eQengineering 的 GitHub 仓库\u003c/a\u003e 寻找。\u003c/p\u003e\n\u003ch2 id=\"编译源码安装\"\u003e编译源码安装\u003c/h2\u003e\u003cp\u003e接下来说一下重点，自己从源码构建轮子并安装。自行构建需要花费数个小时的时间。\u003c/p\u003e\n\u003cp\u003ePyTroch 1.11.0 以及以上版本只能在 Ubuntu 20.04 上安装。\u003c/p\u003e\n\u003ch3 id=\"安装依赖\"\u003e安装依赖\u003c/h3\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get update\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get upgrade\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install ninja-build git cmake \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libjpeg-dev libopenmpi-dev libomp-dev ccache libopenblas-dev libblas-dev libeigen3-dev\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo pip3 install -U --user wheel mock pillow\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo -H pip3 install testresources \u003cspan class=\"nv\"\u003esetuptools\u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e58.3.0 scikit-build\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"下载源码\"\u003e下载源码\u003c/h3\u003e\u003cp\u003e请克隆自己需要的 PyTorch 版本，修改\u003ccode\u003e-b\u003c/code\u003e后的版本参数。\u003c/p\u003e","title":"Jetson Xavier NX 安装 CUDA 支持的 PyTorch 指南"},{"content":"前提你需要拥有一台 x86 架构（非ARM64）的 Ubuntu 主机。\n下载安装 SDK Manager下载在 Nvidia SDK Manager 官网下载，下载自己系统对应的 .deb 或 .rpm 安装包。\n下载之前需要注册 Nvidia 开发者帐号，SDK Manager 也需要开发者帐号才能使用。\n安装Ubuntu 系统使用 apt 安装刚刚下载的 .deb 文件：\nsudo apt install ./sdkmanager_[version]-[build]_amd64.deb CentOS 8.0 和 8.2 系统使用 dnf 安装 .rpm 文件：\nsudo dnf install ./sdkmanager_[version]-[build].x86_64.rpm CentOS 7.6 使用 yum 安装：\nsudo yum install ./sdkmanager_[version]-[build].x86_64.rpm 启动 SDK Manager在终端使用命令启动 SDK Manager：\nsdkmanager 启动后需要登录 Nvidia 开发者帐号。\n安装 JetPack连接 Jetson先将 Jetson 与 SDK Manager 主机使用 USB to Micro-USB 数据线相连接。\n连接成功后，SDK Manager 会自动弹窗。\nSTEP 01取消选择 Host Machine，这个选项会在 SDK Manager 所在的主机上也安装开发包。\nLinux JetPack 选择自己需要的版本，这里以最新的 5.1.2 为例。\n完毕后点击左下角的 CONTINUE。\nSTEP 02如果是升级 JetPack，则需要勾选上 Jetson Linux image，重装系统。这个系统会安装在 Jetson 自带的 SSD 里，不会影响到 Jetson 的 NVMe 固态硬盘。重装系统完毕后只需要重新运行 rootOnNVMe 即可。\n如果你是重新安装 JetPack（版本不变），则只需要勾选下方 Jetson SDK Componets即可，一般不勾选 Deverloper Tools。\n勾选许可证条款，并点击 CONTINUE，如何输入 SDK Manager 主机的密码，注意这个密码不是 Jetson 的密码。\nSTEP 03输入 Jetson 的用户名和密码。\n点击 Install，开始安装，过程大约半个小时。\nSTEP 04安装完毕。\n","permalink":"https://blog.cassdev.com/posts/jetson-xavier-nx-%E5%8D%87%E7%BA%A7%E6%88%96%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85-jetpack-%E6%8C%87%E5%8D%97/","summary":"\u003ch2 id=\"前提\"\u003e前提\u003c/h2\u003e\u003cp\u003e你需要拥有一台 x86 架构（非ARM64）的 Ubuntu 主机。\u003c/p\u003e\n\u003ch2 id=\"下载安装-sdk-manager\"\u003e下载安装 SDK Manager\u003c/h2\u003e\u003ch3 id=\"下载\"\u003e下载\u003c/h3\u003e\u003cp\u003e在 \u003ca href=\"https://developer.nvidia.com/sdk-manager\"\u003eNvidia SDK Manager\u003c/a\u003e 官网下载，下载自己系统对应的 .deb 或 .rpm 安装包。\u003c/p\u003e\n\u003cp\u003e下载之前需要注册 Nvidia 开发者帐号，SDK Manager 也需要开发者帐号才能使用。\u003c/p\u003e\n\u003ch3 id=\"安装\"\u003e安装\u003c/h3\u003e\u003cp\u003eUbuntu 系统使用 apt 安装刚刚下载的 .deb 文件：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install ./sdkmanager_\u003cspan class=\"o\"\u003e[\u003c/span\u003eversion\u003cspan class=\"o\"\u003e]\u003c/span\u003e-\u003cspan class=\"o\"\u003e[\u003c/span\u003ebuild\u003cspan class=\"o\"\u003e]\u003c/span\u003e_amd64.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eCentOS 8.0 和 8.2 系统使用 dnf 安装 .rpm 文件：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo dnf install ./sdkmanager_\u003cspan class=\"o\"\u003e[\u003c/span\u003eversion\u003cspan class=\"o\"\u003e]\u003c/span\u003e-\u003cspan class=\"o\"\u003e[\u003c/span\u003ebuild\u003cspan class=\"o\"\u003e]\u003c/span\u003e.x86_64.rpm\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eCentOS 7.6 使用 yum 安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo yum install ./sdkmanager_\u003cspan class=\"o\"\u003e[\u003c/span\u003eversion\u003cspan class=\"o\"\u003e]\u003c/span\u003e-\u003cspan class=\"o\"\u003e[\u003c/span\u003ebuild\u003cspan class=\"o\"\u003e]\u003c/span\u003e.x86_64.rpm\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"启动-sdk-manager\"\u003e启动 SDK Manager\u003c/h2\u003e\u003cp\u003e在终端使用命令启动 SDK Manager：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esdkmanager\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e启动后需要登录 Nvidia 开发者帐号。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"SDK Manager Login\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/13/Za4GUdmqTVO2lij.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"安装-jetpack\"\u003e安装 JetPack\u003c/h2\u003e\u003ch3 id=\"连接-jetson\"\u003e连接 Jetson\u003c/h3\u003e\u003cp\u003e先将 Jetson 与 SDK Manager 主机使用 USB to Micro-USB 数据线相连接。\u003c/p\u003e","title":"Jetson Xavier NX 升级或重新安装 JetPack 指南"},{"content":"基于 Azure Kinect SDK 和 Open3D 实现灾害现场的三维重建。\n首先，通过获取 Kinect 的 IMU 数据、捕获彩色图像和深度图像，将图像数据转换为点云数据。 随后，根据 IMU 数据实现点云的粗配准，使用彩色ICP算法实现点云的精配准。并将点云数据转换为三角网格数据即场景模型数据。 最后，通过 Protocal Buffers 技术发送给客户端。客户端可在 HoloLens2 上进行智能可视化。\n然后，我们将点云数据转换为三角网格数据，生成场景模型数据。最后，使用 Protocal Buffers 技术将场景模型数据发送给客户端，实现在 HoloLens2 上进行可视化操作。通过完成以上步骤，我们可以高效地把灾后场景还原为一个准确的三维场景模型，使救援和重建工作变得更为快捷、高效。\n","permalink":"https://blog.cassdev.com/posts/kinect-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%96/","summary":"\u003cp\u003e基于 Azure Kinect SDK 和 Open3D 实现灾害现场的三维重建。\u003c/p\u003e\n\u003cp\u003e首先，通过获取 Kinect 的 IMU 数据、捕获彩色图像和深度图像，将图像数据转换为点云数据。\n随后，根据 IMU 数据实现点云的粗配准，使用彩色ICP算法实现点云的精配准。并将点云数据转换为三角网格数据即场景模型数据。\n最后，通过 Protocal Buffers 技术发送给客户端。客户端可在 HoloLens2 上进行智能可视化。\u003c/p\u003e\n\u003cp\u003e然后，我们将点云数据转换为三角网格数据，生成场景模型数据。最后，使用 Protocal Buffers 技术将场景模型数据发送给客户端，实现在 HoloLens2 上进行可视化操作。通过完成以上步骤，我们可以高效地把灾后场景还原为一个准确的三维场景模型，使救援和重建工作变得更为快捷、高效。\u003c/p\u003e","title":"Kinect 获取数据和可视化"},{"content":"下载Boost前往Boost官网下载源码压缩包。\n或通过 wget 下载 1.83 版本：\nwget https://boostorg.jfrog.io/artifactory/main/release/1.83.0/source/boost_1_83_0.7z 下载完毕后，解压 7z 压缩包\n7z x boost_1_83_0.7z 编译安装cd boost_1_83_0 ./bootstrap.sh --with-python=/root/.virtualenvs/ETRS/bin/python3 --with-python-version=3.8 --with-libraries=all --with-python 的路径可以通过 which python3 查看。\n--with-python-version 的版本号可以通过 python3 --version 查看，注意这里需要填成 3.x 格式 ，而不是 3.y.z，省略最后的版本号。\n运行完以上命令后，需要修改 project-config 配置文件。\nvim project-config.jam 修改第 21行，在双引号里添加两个路径，分别是当前 Python 版本的 include 路径和 lib 路径。\nPython 的 include 路径和 lib 路径可以通过下面的 Python 代码查看：\nimport sysconfig sysconfig.get_path(\u0026#39;include\u0026#39;)\t# 查看 include 路径 sysconfig.get_path(\u0026#39;stdlib\u0026#39;)\t# 查看 lib 路径 开始编译：\n./b2 开始安装：\nsudo ./b2 install --with-python include=\u0026#34;/usr/include/python3.8\u0026#34; CMakeList 配置find_package(Boost 1.83 REQUIRED COMPONENTS python38) include_directories(${Boost_INCLUDE_DIRS}) set(PYTHON_DOT_VERSION 3.8) set(PYTHON_INCLUDE /usr/include/python3.8) set(PYTHON_LIBRARY /usr/lib/python3.8/config-aarch64-linux-gnu) add_executable(BoostTest Boostt.cpp) target_link_libraries(BoostTest ${Boost_LIBRARIES} -lpython3.8 -lpython2.7 ) 3.8对应自己的 Python 的代码，例如2.7，3.4。 /usr/lib/python3.8/config-aarch64-linux-gnu 需要对应自己电脑的路径，python3.8 需要改成自己系统的 Python 环境版本，若为 ARM64 架构的系统则为config-aarch64-linux-gnu，若是64位的 x86 架构的系统则为config-x86_64-linux-gnu。 -lpython3.8 同样对应自己的 Python 环境版本。 ","permalink":"https://blog.cassdev.com/posts/linux-boost.python3-%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A-cmake-%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","summary":"\u003ch2 id=\"下载boost\"\u003e下载Boost\u003c/h2\u003e\u003cp\u003e前往\u003ca href=\"https://www.boost.org/\"\u003eBoost官网\u003c/a\u003e下载源码压缩包。\u003c/p\u003e\n\u003cp\u003e或通过 \u003ccode\u003ewget\u003c/code\u003e 下载 1.83 版本：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewget https://boostorg.jfrog.io/artifactory/main/release/1.83.0/source/boost_1_83_0.7z\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e下载完毕后，解压 7z 压缩包\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e7z x boost_1_83_0.7z\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"编译安装\"\u003e编译安装\u003c/h2\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e boost_1_83_0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e./bootstrap.sh --with-python\u003cspan class=\"o\"\u003e=\u003c/span\u003e/root/.virtualenvs/ETRS/bin/python3 --with-python-version\u003cspan class=\"o\"\u003e=\u003c/span\u003e3.8 --with-libraries\u003cspan class=\"o\"\u003e=\u003c/span\u003eall \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003e--with-python\u003c/code\u003e 的路径可以通过 \u003ccode\u003ewhich python3\u003c/code\u003e 查看。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e--with-python-version\u003c/code\u003e 的版本号可以通过 \u003ccode\u003epython3 --version\u003c/code\u003e 查看，注意这里需要填成 \u003ccode\u003e3.x\u003c/code\u003e 格式 ，而不是 \u003ccode\u003e3.y.z\u003c/code\u003e，省略最后的版本号。\u003c/p\u003e\n\u003cp\u003e运行完以上命令后，需要修改 \u003ccode\u003eproject-config\u003c/code\u003e 配置文件。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003evim project-config.jam\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e修改第 21行，在双引号里添加两个路径，分别是当前 Python 版本的 include 路径和 lib 路径。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2023-11-11 at 20.44.10@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/11/11/gKp5WhZYdrC1XAN.png\"\u003e\u003c/p\u003e\n\u003cp\u003ePython 的 include 路径和 lib 路径可以通过下面的 Python 代码查看：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003esysconfig\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003esysconfig\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eget_path\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;include\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\t\t\u003cspan class=\"c1\"\u003e# 查看 include 路径\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003esysconfig\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eget_path\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;stdlib\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\t\t\u003cspan class=\"c1\"\u003e# 查看 lib 路径\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e开始编译：\u003c/p\u003e","title":"Linux Boost.Python3 安装以及 CMake 配置指南"},{"content":"在上一篇文章中，我们学习了Linux中的文件浏览，知道了如何在Linux文件系统中定位文件。本篇文章中，我们将继续深入学习Linux中的文件及目录的读写操作。\n读取文件cat 命令：读取文件全部内容要读取一个文件的内容，可以使用cat命令，语法为：\ncat 文件名 这会将文件的全部内容输出到终端。当文件比较大时，这样的输出会刷屏，不太方便查看。\nhead 和 tail 命令：显示部分内容Linux提供了head和tail命令来显示部分内容：\nhead - 显示开头部分内容 tail - 显示结尾部分内容 head和tail可以指定显示的行数，例如：\nhead -n 3 文件名 # 显示前3行 tail -n 5 文件名 # 显示后5行 less 命令：分页显示less命令可以分页方式显示文件内容，可以上下翻阅，是文件查看的首选工具。\nless可以用方向键上下翻页，也支持各种快捷键，推荐大家阅读less的帮助文档。\n写入文件echo 命令：输出到文件使用echo命令可以向文件写入内容，语法为：\necho \u0026#34;要写入的内容\u0026#34; \u0026gt; 文件名\t这会覆盖文件原有内容。如果要附加内容，使用两个大于号：\necho \u0026#34;新增内容\u0026#34; \u0026gt;\u0026gt; 文件名 文本编辑器：vim对文件进行复杂编辑可以使用文本编辑器，Linux中的常用文本编辑器有vi、emacs、vim和nano等。这里简单介绍vim的使用。\n使用vim 文件名可以打开vim编辑器。vim有三种模式，分别是命令模式、插入模式和底线命令模式。\n命令模式：用于导航文件，可以进行复制、粘贴、删除等操作。 插入模式：用于输入文本，可以使用键盘输入文本。 底线命令模式：用于执行命令，例如保存文件、退出vim等。 初学者可以先了解以下几个快捷键：\ni - 进入插入模式 ESC - 从插入模式回到命令模式 :w - 保存文件 :q - 退出vim vim非常强大，建议大家自己练习熟悉其操作。\n删除文件和目录rm 命令：删除文件删除文件使用rm命令：\nrm 文件名 rm -r 命令：删除目录如果要删除目录，需要添加-r参数：\nrm -r 目录名 这会递归删除目录及其中的所有内容，需要小心使用。\n复制和移动文件 复制使用cp命令，添加-r参数可以复制目录\n移动使用mv命令，mv同时支持文件和目录的移动\ncp file1 file2 # 复制文件file1成为file2 cp -r dir1 dir2 # 复制目录dir1成为dir2 mv file1 file2 # 将文件file1移动并重命名为file2 mv dir1 dir2 # 将目录dir1移动并重命名为dir2 今天学习的这些基础命令非常实用，建议大家练习熟练掌握。可以在home目录下创建文件夹，在里面练习这些命令。掌握后，文件操作会更加高效。\n","permalink":"https://blog.cassdev.com/posts/linux-%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%97%85%E4%BA%8C%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E8%AF%BB%E5%86%99/","summary":"\u003cp\u003e在上一篇文章中，我们学习了Linux中的文件浏览，知道了如何在Linux文件系统中定位文件。本篇文章中，我们将继续深入学习Linux中的文件及目录的读写操作。\u003c/p\u003e\n\u003ch2 id=\"读取文件\"\u003e读取文件\u003c/h2\u003e\u003ch3 id=\"cat-命令读取文件全部内容\"\u003ecat 命令：读取文件全部内容\u003c/h3\u003e\u003cp\u003e要读取一个文件的内容，可以使用cat命令，语法为：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat 文件名\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这会将文件的全部内容输出到终端。当文件比较大时，这样的输出会刷屏，不太方便查看。\u003c/p\u003e\n\u003ch3 id=\"head-和-tail-命令显示部分内容\"\u003ehead 和 tail 命令：显示部分内容\u003c/h3\u003e\u003cp\u003eLinux提供了head和tail命令来显示部分内容：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ehead - 显示开头部分内容\u003c/li\u003e\n\u003cli\u003etail - 显示结尾部分内容\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ehead和tail可以指定显示的行数，例如：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehead -n \u003cspan class=\"m\"\u003e3\u003c/span\u003e 文件名 \u003cspan class=\"c1\"\u003e# 显示前3行 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etail -n \u003cspan class=\"m\"\u003e5\u003c/span\u003e 文件名 \u003cspan class=\"c1\"\u003e# 显示后5行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"less-命令分页显示\"\u003eless 命令：分页显示\u003c/h3\u003e\u003cp\u003eless命令可以分页方式显示文件内容，可以上下翻阅，是文件查看的首选工具。\u003c/p\u003e\n\u003cp\u003eless可以用方向键上下翻页，也支持各种快捷键，推荐大家阅读less的帮助文档。\u003c/p\u003e\n\u003ch2 id=\"写入文件\"\u003e写入文件\u003c/h2\u003e\u003ch3 id=\"echo-命令输出到文件\"\u003eecho 命令：输出到文件\u003c/h3\u003e\u003cp\u003e使用echo命令可以向文件写入内容，语法为：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;要写入的内容\u0026#34;\u003c/span\u003e \u0026gt; 文件名\t\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这会覆盖文件原有内容。如果要附加内容，使用两个大于号：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;新增内容\u0026#34;\u003c/span\u003e \u0026gt;\u0026gt; 文件名 \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"文本编辑器vim\"\u003e文本编辑器：vim\u003c/h3\u003e\u003cp\u003e对文件进行复杂编辑可以使用文本编辑器，Linux中的常用文本编辑器有vi、emacs、vim和nano等。这里简单介绍vim的使用。\u003c/p\u003e\n\u003cp\u003e使用\u003ccode\u003evim 文件名\u003c/code\u003e可以打开vim编辑器。vim有三种模式，分别是命令模式、插入模式和底线命令模式。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e命令模式：用于导航文件，可以进行复制、粘贴、删除等操作。\u003c/li\u003e\n\u003cli\u003e插入模式：用于输入文本，可以使用键盘输入文本。\u003c/li\u003e\n\u003cli\u003e底线命令模式：用于执行命令，例如保存文件、退出vim等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e初学者可以先了解以下几个快捷键：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ei\u003c/code\u003e - 进入插入模式\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eESC\u003c/code\u003e - 从插入模式回到命令模式\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:w\u003c/code\u003e - 保存文件\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:q\u003c/code\u003e - 退出vim\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003evim非常强大，建议大家自己练习熟悉其操作。\u003c/p\u003e\n\u003ch2 id=\"删除文件和目录\"\u003e删除文件和目录\u003c/h2\u003e\u003ch3 id=\"rm-命令删除文件\"\u003erm 命令：删除文件\u003c/h3\u003e\u003cp\u003e删除文件使用rm命令：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003erm 文件名\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"rm--r-命令删除目录\"\u003erm -r 命令：删除目录\u003c/h3\u003e\u003cp\u003e如果要删除目录，需要添加-r参数：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003erm -r 目录名\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这会递归删除目录及其中的所有内容，需要小心使用。\u003c/p\u003e\n\u003ch2 id=\"复制和移动文件\"\u003e复制和移动文件\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e复制使用cp命令，添加-r参数可以复制目录\u003c/p\u003e","title":"Linux 初探之旅（二）——文件与文件夹的读写"},{"content":"标准输入输出我们先从Linux最基础的交互来讲起，我们究竟是如何和Linux系统内核进行交互的？换句话说，如何通过在按下键盘，就能让系统实现对应的操作的？\n这一切都离不开它，终端——用户与Linux建立起联系的桥梁。\n当我们在终端上输入命令的时候，直到我们未按下回车键之前，我们输入的所有内容都储存在终端的缓冲区（Buffer）里。此时我们输入的内容不会被系统所读到，只有在我们按下回车键后，缓冲区里的内容才会被发往 stdin （Standrad input 标准输入），stdin 是 Linux 内核和用户交互的通道。\n接着，Shell 会介入，它会将 stdin 收到的内容翻译成操作并执行，Shell 译为壳层，与 Kernel（内核）相对应。Shell在外，Kernel在内。例如我们输入ls，那么 Shell 就会找到 ls 这条命令对应的二进制文件并执行。\n执行完命令后，Shell 会将获取到的结果发送到另一条与 stdin 相对应的通道中，即 stdout（Standard output 标准输出）。终端会不间断地从 stdout 里读取内容，然后打印到屏幕上，即我们在终端中看到的输出。\n总的来说，用户的输入的内容会发往 stdin 并被 Shell 读取，Shell 将找到内容所对应的二进制文件并执行，执行完后 Shell 会将结果发往 stdout 中，及时的显示在屏幕上。这就是一次与 Linux 交互的过程。\n我们总说，在 Linux 中一切皆为文件，那么 stdin 和 stdout 也不例外，它们也是系统的两个文件。除了 stdin 和 stdout 之外，还有第三条通道 stderr（Standard error 标准错误）。stderr 和 stdout 一样，它们都是用于存储执行结果的地方，区别在于，Shell 执行完命令后，会将正常的结果发往 stdout 里，将错误的结果发往 stderr 里。同样地，stderr 也会被终端所读取，最后显示在屏幕上。\n输出重定向理解了标准输入输出后，我们能弄懂重定向的原理了，实际上就是 Shell 执行完命令后不把输出结果存放在 stdout 或 stderr 。而是存放到另一个文件当中。\n下面说一下重定向的简单用法，即在命令后面加箭头（\u0026gt;）：\necho \u0026#34;Hello World\u0026#34; \u0026gt; test.txt #将 Hello World 覆盖式写入 test.txt 文件中 重定向还有支持更高阶的操作，比如我们可以分别指定标准输出和标准错误的输出位置。\n在重定向的时候，1代表的就是 stdin，2代表的就是 stderr。例如：\ncmd 1\u0026gt;outfile.txt 2\u0026gt;errfile.txt\t#cmd 为你想执行的命令 我们还可以将一条通道重定向到另一条通道中：\ncmd 2\u0026gt;\u0026amp;1\t#将标准错误重定向到标准输出中 当箭头后方是一条输出通道的时候，需要加上 \u0026amp; 符号，表示指定的是 1 号通道，而不是一个名为“1”的文件。\n将标准错误和标准输出都存放到一个文件内：\ncmd 1\u0026gt;outfile.txt 2\u0026gt;\u0026amp;1 注意这里的顺序，2\u0026gt;\u0026amp;1必须在后面，因为重定向并不是简单的将两个通道相连接，而是当箭头右侧为一条输出通道时，重定向会将箭头左侧的内容直接连接右侧通道的输出端。\n另外，我们可以把不希望输出的内容重定向到/dev/null中，这个文件相当于 Linux 的垃圾桶（黑洞）。\n输入重定向将箭头反过来（\u0026lt;）就表示输入重定向了。这里用 Linux 中十分常用的一条命令grep作为例子，grep的作用是在给定内容中寻找目标字符串所在的一行。\ngrep \u0026#34;int main\u0026#34; \u0026lt; Hello.cpp 管道实际上grep命令经与管道（pipe）一起用，管道符号为|，其作用也很简单，就是将管道左侧命令的标准输出与管道右侧命令的标准输入相连接。\n例如上面的grep命令的例子也能用管道实现：\ncat Hello.cpp | grep \u0026#34;int main\u0026#34; 下面再举几个|的例子：\n与ifconfig命令配合使用，查询局域网 ipv4 地址：\nifconfig | grep 192.168 与ps命令配合使用，查询后台程序是否正在运行：\nps aux | grep chrome ","permalink":"https://blog.cassdev.com/posts/linux-%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%97%85%E4%B8%89%E9%87%8D%E5%AE%9A%E5%90%91%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E7%AE%A1%E9%81%93/","summary":"\u003ch2 id=\"标准输入输出\"\u003e标准输入输出\u003c/h2\u003e\u003cp\u003e我们先从Linux最基础的交互来讲起，我们究竟是如何和Linux系统内核进行交互的？换句话说，如何通过在按下键盘，就能让系统实现对应的操作的？\u003c/p\u003e\n\u003cp\u003e这一切都离不开它，终端——用户与Linux建立起联系的桥梁。\u003c/p\u003e\n\u003cp\u003e当我们在终端上输入命令的时候，直到我们未按下回车键之前，我们输入的所有内容都储存在终端的缓冲区（Buffer）里。此时我们输入的内容不会被系统所读到，只有在我们按下回车键后，缓冲区里的内容才会被发往 stdin （Standrad input 标准输入），stdin 是 Linux 内核和用户交互的通道。\u003c/p\u003e\n\u003cp\u003e接着，Shell 会介入，它会将 stdin 收到的内容翻译成操作并执行，Shell 译为壳层，与 Kernel（内核）相对应。Shell在外，Kernel在内。例如我们输入\u003ccode\u003els\u003c/code\u003e，那么 Shell 就会找到 \u003ccode\u003els\u003c/code\u003e 这条命令对应的二进制文件并执行。\u003c/p\u003e\n\u003cp\u003e执行完命令后，Shell 会将获取到的结果发送到另一条与 stdin 相对应的通道中，即 stdout（Standard output 标准输出）。终端会不间断地从 stdout 里读取内容，然后打印到屏幕上，即我们在终端中看到的输出。\u003c/p\u003e\n\u003cp\u003e总的来说，用户的输入的内容会发往 stdin 并被 Shell 读取，Shell 将找到内容所对应的二进制文件并执行，执行完后 Shell 会将结果发往 stdout 中，及时的显示在屏幕上。这就是一次与 Linux 交互的过程。\u003c/p\u003e\n\u003cp\u003e我们总说，在 Linux 中一切皆为文件，那么 stdin 和 stdout 也不例外，它们也是系统的两个文件。除了 stdin 和 stdout 之外，还有第三条通道 stderr（Standard error 标准错误）。stderr 和 stdout 一样，它们都是用于存储执行结果的地方，区别在于，Shell 执行完命令后，会将正常的结果发往 stdout 里，将错误的结果发往 stderr 里。同样地，stderr 也会被终端所读取，最后显示在屏幕上。\u003c/p\u003e\n\u003ch2 id=\"输出重定向\"\u003e输出重定向\u003c/h2\u003e\u003cp\u003e理解了标准输入输出后，我们能弄懂重定向的原理了，实际上就是 Shell 执行完命令后不把输出结果存放在 stdout 或 stderr 。而是存放到另一个文件当中。\u003c/p\u003e","title":"Linux 初探之旅（三）——重定向、标准输入输出和管道"},{"content":"使用 bash 脚本，先创建一个 .sh 结尾的脚本：\nvim rename.sh 以下是示例 bash 脚本内容，作用是将 /path/to/dir 目录下所有包含冒号:的文件名，将冒号替换为减号。\n# !/bin/bash find /path/to/dir -type f -name \u0026#39;*:*\u0026#39; -exec bash -c \u0026#39;mv \u0026#34;$0\u0026#34; \u0026#34;${0//:/-}\u0026#34;\u0026#39; {} \\; 代码解释使用find查找需要更改的文件find /path/to/dir -type f -name \u0026#39;*:*\u0026#39; /path/to/dir 应该替换为包含你要修改文件名的文件夹的实际路径。 -type f 表示只查找普通文件，而不包括目录。 -name '*:*' 是一个查找条件，用于匹配包含冒号的文件名。 使用mv和bash执行文件名更改一旦找到需要更改的文件，可以使用mv命令结合bash来执行文件名更改操作。\nfind /path/to/dir -type f -name \u0026#39;*:*\u0026#39; -exec bash -c \u0026#39;mv \u0026#34;$0\u0026#34; \u0026#34;${0//:/-}\u0026#34;\u0026#39; {} \\; 这个命令中的 -exec 标志用于在find查找到的每个文件上执行指定的命令。bash -c之后的部分将执行文件名更改操作。\nmv \u0026quot;$0\u0026quot; \u0026quot;${0//:/-}\u0026quot; 使用mv命令将文件名中的冒号替换为减号。${0//:/-} 部分是一个bash子shell，其中的${0}表示当前文件名，//后跟着:和-是用来替换的正则表达式。 ","permalink":"https://blog.cassdev.com/posts/linux-%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e使用 bash 脚本，先创建一个 .sh 结尾的脚本：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-vim\" data-lang=\"vim\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003evim\u003c/span\u003e \u003cspan class=\"nx\"\u003erename\u003c/span\u003e.\u003cspan class=\"nx\"\u003esh\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e以下是示例 bash 脚本内容，作用是将 /path/to/dir 目录下所有包含冒号\u003ccode\u003e:\u003c/code\u003e的文件名，将冒号替换为减号。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# !/bin/bash\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /path/to/dir -type f -name \u003cspan class=\"s1\"\u003e\u0026#39;*:*\u0026#39;\u003c/span\u003e -exec bash -c \u003cspan class=\"s1\"\u003e\u0026#39;mv \u0026#34;$0\u0026#34; \u0026#34;${0//:/-}\u0026#34;\u0026#39;\u003c/span\u003e \u003cspan class=\"o\"\u003e{}\u003c/span\u003e \u003cspan class=\"se\"\u003e\\;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"代码解释\"\u003e代码解释\u003c/h2\u003e\u003ch3 id=\"使用find查找需要更改的文件\"\u003e使用\u003ccode\u003efind\u003c/code\u003e查找需要更改的文件\u003c/h3\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /path/to/dir -type f -name \u003cspan class=\"s1\"\u003e\u0026#39;*:*\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e/path/to/dir\u003c/code\u003e 应该替换为包含你要修改文件名的文件夹的实际路径。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-type f\u003c/code\u003e 表示只查找普通文件，而不包括目录。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-name '*:*'\u003c/code\u003e 是一个查找条件，用于匹配包含冒号的文件名。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"使用mv和bash执行文件名更改\"\u003e使用\u003ccode\u003emv\u003c/code\u003e和\u003ccode\u003ebash\u003c/code\u003e执行文件名更改\u003c/h3\u003e\u003cp\u003e一旦找到需要更改的文件，可以使用\u003ccode\u003emv\u003c/code\u003e命令结合\u003ccode\u003ebash\u003c/code\u003e来执行文件名更改操作。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /path/to/dir -type f -name \u003cspan class=\"s1\"\u003e\u0026#39;*:*\u0026#39;\u003c/span\u003e -exec bash -c \u003cspan class=\"s1\"\u003e\u0026#39;mv \u0026#34;$0\u0026#34; \u0026#34;${0//:/-}\u0026#34;\u0026#39;\u003c/span\u003e \u003cspan class=\"o\"\u003e{}\u003c/span\u003e \u003cspan class=\"se\"\u003e\\;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个命令中的 \u003ccode\u003e-exec\u003c/code\u003e 标志用于在\u003ccode\u003efind\u003c/code\u003e查找到的每个文件上执行指定的命令。\u003ccode\u003ebash -c\u003c/code\u003e之后的部分将执行文件名更改操作。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emv \u0026quot;$0\u0026quot; \u0026quot;${0//:/-}\u0026quot;\u003c/code\u003e 使用\u003ccode\u003emv\u003c/code\u003e命令将文件名中的冒号替换为减号。\u003ccode\u003e${0//:/-}\u003c/code\u003e 部分是一个bash子shell，其中的\u003ccode\u003e${0}\u003c/code\u003e表示当前文件名，\u003ccode\u003e//\u003c/code\u003e后跟着\u003ccode\u003e:\u003c/code\u003e和\u003ccode\u003e-\u003c/code\u003e是用来替换的正则表达式。\u003c/li\u003e\n\u003c/ul\u003e","title":"Linux 批量修改文件名指南"},{"content":"mixed-port: 7890 # Linux 和 macOS 的 redir 代理端口 redir-port: 7892 # 允许局域网的连接 allow-lan: true # 规则模式：Rule（规则） / Global（全局代理）/ Direct（全局直连） mode: rule # 设置日志输出级别 (默认级别：silent，即不输出任何内容，以避免因日志内容过大而导致程序内存溢出）。 # 5 个级别：silent / info / warning / error / debug。级别越高日志输出量越大，越倾向于调试，若需要请自行开启。 log-level: info # Clash 的 RESTful API external-controller: \u0026#39;0.0.0.0:9090\u0026#39; # RESTful API 的口令 secret: \u0026#39;\u0026#39; dns: enable: true ipv6: true listen: \u0026#39;0.0.0.0:53\u0026#39; use-hosts: true enhanced-mode: fake-ip fake-ip-range: 198.18.0.1/16 nameserver: - 202.120.224.6 - 114.114.114.114 - 223.5.5.5 - \u0026#39;tcp://223.5.5.5\u0026#39; fallback: - \u0026#39;tls://223.5.5.5:853\u0026#39; - \u0026#39;https://223.5.5.5/dns-query\u0026#39; fallback-filter: geoip: true ipcidr: - 240.0.0.0/4 # proxy provider start here proxy-providers: feiniao: type: http path: ./profiles/feiniao.yaml url: https://apiv1.v27qae.com/flydsubal/c8lr21z6wpiebqqx?clash=1\u0026amp;extend=1 interval: 36000 health-check: enable: true url: http://www.gstatic.com/generate_204 interval: 3600 yiyuan: type: http path: ./profiles/yiyuan.yaml url: https://sub1.smallstrawberry.com/api/v1/client/subscribe?token=d6e73f953b6053a3b263b73f9509375d decode-url: true interval: 36000 health-check: enable: true url: http://www.gstatic.com/generate_204 interval: 3600 # proxy provider end proxies: # socks5 - name: windowsServer type: socks5 server: 10.127.78.177 port: 7890 # username: username # password: password # tls: true # skip-cert-verify: true # udp: true # - {name: 🇮🇪 中国-爱尔兰 IPLC C04, server: ir04.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB} # - {name: 🇭🇰 香港 油尖旺御金·国峯 名氣通電訊 C02, server: hkhe02.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB} # - {name: 🇮🇪 中国-爱尔兰 IPLC C03, server: ir03.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB} # - {name: 🇭🇰 香港 油尖旺御金·国峯 名氣通電訊 C09, server: hkhe09.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB} # - {name: 🇨🇳 中国-香港 IEPL Equinix HK8 C 02 1Gbps HBO TVB, server: sg12.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB, udp: true} # - {name: 🇨🇳 中国-爱尔兰 IPLC C05, server: ir05.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB, udp: true} # - {name: 🇨🇳 中国-香港 IPLC Equinix HK2 C 06 1Gbps HBO TVB, server: sg06.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB, udp: true} proxy-groups: - name: Proxies type: select proxies: - 机场节点 - 自动选择 - 故障转移 # - name: 手动节点 # type: select # proxies: # - 🇮🇪 中国-爱尔兰 IPLC C04 # - 🇭🇰 香港 油尖旺御金·国峯 名氣通電訊 C02 # - 🇮🇪 中国-爱尔兰 IPLC C03 # - 🇭🇰 香港 油尖旺御金·国峯 名氣通電訊 C09 # - 🇨🇳 中国-香港 IEPL Equinix HK8 C 02 1Gbps HBO TVB # - 🇨🇳 中国-爱尔兰 IPLC C05 # - 🇨🇳 中国-香港 IPLC Equinix HK2 C 06 1Gbps HBO TVB - name: feiniao type: select use: - feiniao - name: yiyuan type: select use: - yiyuan - name: 机场节点 type: select proxies: - feiniao - yiyuan - name: 故障转移 type: fallback url: \u0026#39;http://www.gstatic.com/generate_204\u0026#39; interval: 7200 proxies: - feiniao - yiyuan - name: 自动选择 type: url-test url: \u0026#39;http://www.gstatic.com/generate_204\u0026#39; interval: 300 use: - feiniao - yiyuan rule-providers: reject: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/reject.txt\u0026#34; path: ./ruleset/reject.yaml interval: 86400 icloud: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/icloud.txt\u0026#34; path: ./ruleset/icloud.yaml interval: 86400 apple: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/apple.txt\u0026#34; path: ./ruleset/apple.yaml interval: 86400 google: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/google.txt\u0026#34; path: ./ruleset/google.yaml interval: 86400 proxy: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/proxy.txt\u0026#34; path: ./ruleset/proxy.yaml interval: 86400 direct: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/direct.txt\u0026#34; path: ./ruleset/direct.yaml interval: 86400 private: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/private.txt\u0026#34; path: ./ruleset/private.yaml interval: 86400 gfw: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/gfw.txt\u0026#34; path: ./ruleset/gfw.yaml interval: 86400 tld-not-cn: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/tld-not-cn.txt\u0026#34; path: ./ruleset/tld-not-cn.yaml interval: 86400 telegramcidr: type: http behavior: ipcidr url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/telegramcidr.txt\u0026#34; path: ./ruleset/telegramcidr.yaml interval: 86400 cncidr: type: http behavior: ipcidr url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/cncidr.txt\u0026#34; path: ./ruleset/cncidr.yaml interval: 86400 lancidr: type: http behavior: ipcidr url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/lancidr.txt\u0026#34; path: ./ruleset/lancidr.yaml interval: 86400 applications: type: http behavior: classical url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/applications.txt\u0026#34; path: ./ruleset/applications.yaml interval: 86400 rules: - DOMAIN-SUFFIX,visualstudio.com,DIRECT - DOMAIN-SUFFIX,azure.com,DIRECT - DOMAIN-SUFFIX,vscode.dev,Proxies - RULE-SET,applications,DIRECT - DOMAIN,clash.razord.top,DIRECT - DOMAIN,yacd.haishan.me,DIRECT - RULE-SET,private,DIRECT - RULE-SET,reject,REJECT - RULE-SET,tld-not-cn,Proxies - RULE-SET,gfw,Proxies - RULE-SET,telegramcidr,Proxies - MATCH,DIRECT ","permalink":"https://blog.cassdev.com/posts/macos-clashx-pro-%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","summary":"\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emixed-port: 7890\n\n# Linux 和 macOS 的 redir 代理端口\nredir-port: 7892\n\n# 允许局域网的连接\nallow-lan: true\n\n# 规则模式：Rule（规则） / Global（全局代理）/ Direct（全局直连）\nmode: rule\n\n# 设置日志输出级别 (默认级别：silent，即不输出任何内容，以避免因日志内容过大而导致程序内存溢出）。\n# 5 个级别：silent / info / warning / error / debug。级别越高日志输出量越大，越倾向于调试，若需要请自行开启。\nlog-level: info\n# Clash 的 RESTful API\nexternal-controller: \u0026#39;0.0.0.0:9090\u0026#39;\n\n# RESTful API 的口令\nsecret: \u0026#39;\u0026#39;\n\ndns:\n  enable: true\n  ipv6: true\n  listen: \u0026#39;0.0.0.0:53\u0026#39;\n  use-hosts: true\n  enhanced-mode: fake-ip\n  fake-ip-range: 198.18.0.1/16\n  nameserver:\n    - 202.120.224.6\n    - 114.114.114.114\n    - 223.5.5.5\n    - \u0026#39;tcp://223.5.5.5\u0026#39;\n  fallback:\n    - \u0026#39;tls://223.5.5.5:853\u0026#39;\n    - \u0026#39;https://223.5.5.5/dns-query\u0026#39;\n  fallback-filter:\n    geoip: true\n    ipcidr:\n      - 240.0.0.0/4\n# proxy provider start here\nproxy-providers:\n  feiniao:\n    type: http\n    path: ./profiles/feiniao.yaml\n    url: https://apiv1.v27qae.com/flydsubal/c8lr21z6wpiebqqx?clash=1\u0026amp;extend=1\n    interval: 36000\n    health-check:\n      enable: true\n      url: http://www.gstatic.com/generate_204\n      interval: 3600\n  yiyuan:\n    type: http\n    path: ./profiles/yiyuan.yaml\n    url: https://sub1.smallstrawberry.com/api/v1/client/subscribe?token=d6e73f953b6053a3b263b73f9509375d\n    decode-url: true\n    interval: 36000\n    health-check:\n      enable: true\n      url: http://www.gstatic.com/generate_204\n      interval: 3600\n\n\n# proxy provider end\nproxies:\n    # socks5\n  - name: windowsServer\n    type: socks5\n    server: 10.127.78.177\n    port: 7890\n    # username: username\n    # password: password\n    # tls: true\n    # skip-cert-verify: true\n    # udp: true\n\n  # - {name: 🇮🇪 中国-爱尔兰 IPLC C04, server: ir04.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB}\n  # - {name: 🇭🇰 香港 油尖旺御金·国峯 名氣通電訊 C02, server: hkhe02.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB}\n  # - {name: 🇮🇪 中国-爱尔兰 IPLC C03, server: ir03.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB}\n  # - {name: 🇭🇰 香港 油尖旺御金·国峯 名氣通電訊 C09, server: hkhe09.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB}\n  # - {name: 🇨🇳 中国-香港 IEPL Equinix HK8 C 02 1Gbps HBO TVB, server: sg12.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB, udp: true}\n  # - {name: 🇨🇳 中国-爱尔兰 IPLC C05, server: ir05.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB, udp: true}\n  # - {name: 🇨🇳 中国-香港 IPLC Equinix HK2 C 06 1Gbps HBO TVB, server: sg06.cathayroute.com, port: 33400, type: ss, cipher: rc4-md5, password: SRCFiB, udp: true}\n\nproxy-groups:\n  - name: Proxies\n    type: select\n    proxies:\n      - 机场节点\n      - 自动选择\n      - 故障转移\n\n  # - name: 手动节点\n  #   type: select\n  #   proxies:\n  #     - 🇮🇪 中国-爱尔兰 IPLC C04\n  #     - 🇭🇰 香港 油尖旺御金·国峯 名氣通電訊 C02\n  #     - 🇮🇪 中国-爱尔兰 IPLC C03\n  #     - 🇭🇰 香港 油尖旺御金·国峯 名氣通電訊 C09   \n  #     - 🇨🇳 中国-香港 IEPL Equinix HK8 C 02 1Gbps HBO TVB\n  #     - 🇨🇳 中国-爱尔兰 IPLC C05\n  #     - 🇨🇳 中国-香港 IPLC Equinix HK2 C 06 1Gbps HBO TVB\n\n  - name: feiniao\n    type: select\n    use:\n     - feiniao\n\n  - name: yiyuan\n    type: select\n    use:\n     - yiyuan\n\n  - name: 机场节点\n    type: select\n    proxies:\n     - feiniao\n     - yiyuan\n\n\n  - name: 故障转移\n    type: fallback\n    url: \u0026#39;http://www.gstatic.com/generate_204\u0026#39;\n    interval: 7200\n    proxies:\n     - feiniao\n     - yiyuan\n\n  - name: 自动选择\n    type: url-test\n    url: \u0026#39;http://www.gstatic.com/generate_204\u0026#39;\n    interval: 300\n    use:\n      - feiniao\n      - yiyuan\n\nrule-providers:\n  reject:\n    type: http\n    behavior: domain\n    url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/reject.txt\u0026#34;\n    path: ./ruleset/reject.yaml\n    interval: 86400\n\n  icloud:\n    type: http\n    behavior: domain\n    url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/icloud.txt\u0026#34;\n    path: ./ruleset/icloud.yaml\n    interval: 86400\n\n  apple:\n    type: http\n    behavior: domain\n    url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/apple.txt\u0026#34;\n    path: ./ruleset/apple.yaml\n    interval: 86400\n\n  google:\n    type: http\n    behavior: domain\n    url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/google.txt\u0026#34;\n    path: ./ruleset/google.yaml\n    interval: 86400\n\n  proxy:\n    type: http\n    behavior: domain\n    url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/proxy.txt\u0026#34;\n    path: ./ruleset/proxy.yaml\n    interval: 86400\n\n  direct:\n    type: http\n    behavior: domain\n    url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/direct.txt\u0026#34;\n    path: ./ruleset/direct.yaml\n    interval: 86400\n\n  private:\n    type: http\n    behavior: domain\n    url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/private.txt\u0026#34;\n    path: ./ruleset/private.yaml\n    interval: 86400\n\n  gfw:\n    type: http\n    behavior: domain\n    url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/gfw.txt\u0026#34;\n    path: ./ruleset/gfw.yaml\n    interval: 86400\n\n  tld-not-cn:\n    type: http\n    behavior: domain\n    url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/tld-not-cn.txt\u0026#34;\n    path: ./ruleset/tld-not-cn.yaml\n    interval: 86400\n\n  telegramcidr:\n    type: http\n    behavior: ipcidr\n    url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/telegramcidr.txt\u0026#34;\n    path: ./ruleset/telegramcidr.yaml\n    interval: 86400\n\n  cncidr:\n    type: http\n    behavior: ipcidr\n    url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/cncidr.txt\u0026#34;\n    path: ./ruleset/cncidr.yaml\n    interval: 86400\n\n  lancidr:\n    type: http\n    behavior: ipcidr\n    url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/lancidr.txt\u0026#34;\n    path: ./ruleset/lancidr.yaml\n    interval: 86400\n\n  applications:\n    type: http\n    behavior: classical\n    url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/applications.txt\u0026#34;\n    path: ./ruleset/applications.yaml\n    interval: 86400\n\nrules:\n  - DOMAIN-SUFFIX,visualstudio.com,DIRECT\n  - DOMAIN-SUFFIX,azure.com,DIRECT\n  - DOMAIN-SUFFIX,vscode.dev,Proxies\n  - RULE-SET,applications,DIRECT\n  - DOMAIN,clash.razord.top,DIRECT\n  - DOMAIN,yacd.haishan.me,DIRECT\n  - RULE-SET,private,DIRECT\n  - RULE-SET,reject,REJECT\n  - RULE-SET,tld-not-cn,Proxies\n  - RULE-SET,gfw,Proxies\n  - RULE-SET,telegramcidr,Proxies\n  - MATCH,DIRECT\n\u003c/code\u003e\u003c/pre\u003e","title":"macOS ClashX Pro 配置指南"},{"content":"Microsoft Word在macOS平台上是一款功能强大的文字处理工具，然而，要使其与macOS原生编辑器更好地无缝切换，合理配置快捷键是至关重要的。本指南将介绍一些新的macOS Word的快捷键，使您能够更高效地编辑文档，同时保持与系统级快捷键的一致性。\n快捷键 Word快捷键名 备注 Ctrl + A StartOfLine 跳到行首 Ctrl + E EndOfLine 跳到行尾 Ctrl + N LineDown 下一行 Ctrl + P LineUp 上一行 Ctrl + F CharRight 下一个字符 Ctrl + B CharLeft 上一个字符 Ctrl + J NextPage 跳到下一页 Ctrl + K PrevPage 跳到上一页 Ctrl + V PasteTextOnly 无格式粘贴 Ctrl + H Highlight 高亮选中的文字 Ctrl + T TableInsertTable 插入表格 Cmd + Shift + F NavPaneSearch 高级面板搜索 Option + Return TableInsertRowBelow 在表格下方插入一行 ","permalink":"https://blog.cassdev.com/posts/macos-word-%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003eMicrosoft Word在macOS平台上是一款功能强大的文字处理工具，然而，要使其与macOS原生编辑器更好地无缝切换，合理配置快捷键是至关重要的。本指南将介绍一些新的macOS Word的快捷键，使您能够更高效地编辑文档，同时保持与系统级快捷键的一致性。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e快捷键\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003eWord快捷键名\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e备注\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eCtrl + A\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eStartOfLine\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e跳到行首\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eCtrl + E\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eEndOfLine\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e跳到行尾\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eCtrl + N\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eLineDown\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e下一行\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eCtrl + P\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eLineUp\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e上一行\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eCtrl + F\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eCharRight\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e下一个字符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eCtrl + B\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eCharLeft\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e上一个字符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eCtrl + J\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eNextPage\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e跳到下一页\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eCtrl + K\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003ePrevPage\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e跳到上一页\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eCtrl + V\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003ePasteTextOnly\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e无格式粘贴\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eCtrl + H\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eHighlight\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e高亮选中的文字\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eCtrl + T\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eTableInsertTable\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e插入表格\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eCmd + Shift + F\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eNavPaneSearch\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e高级面板搜索\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eOption + Return\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eTableInsertRowBelow\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e在表格下方插入一行\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"macOS Word 更好的快捷键配置指南"},{"content":"正文字体大小默认12，两端对齐，1.5倍行距。字体类型选择 Latin 文字，将字体改成 Times New Roman，再将字体类型改成 Asian 亚洲文字，将字体改成 SimHei（黑体）。\n带首行缩进的正文打开样式面板，点击 New Style。\n输入样式名称“Indent”，继承于 Normal 样式。\n左下角选择 Paragraph 面板，将 Special 改成 First line，后面填 0.86cm。\n各级标题一级标题打开 Heading 1 一级标题的设置。\n字体大小默认16，加粗，黑色，居中对齐，1.5倍行距。字体类型选择 Latin 文字，将字体改成 Times New Roman，再将字体类型改成 Asian 亚洲文字，将字体改成 SimHei（黑体）。\n左下角选择 Paragraph 面板，将 Special 改成 none，取消继承于正文样式（Normal）的值。\n左下角选择 Numbering 面板，切换到 Outline Numbered，选择图示的排列格式，点击右下角 Customize。\n选择 Level 1 一级标题，先将 Number style 改成中文简体数字，然后在上方的“一”前后分别输入“第”和“章”，Follow number with 选择 Space，Link level to style 选择 Heading 1。\n二级标题同样打开 Heading 2 二级标题的设置，除了字体大小13和居左对齐外，其他设置均与一级标题一致。\n打开 Outline Numbering list 编辑面板，选择 Level 2，勾选 Legal style numbering，再勾选 Restart numbering after，选择上一级 Level 1。Follow number with 一样选择 Space。\n三级标题三级标题与二级标题同理，字体大小为12。\n有序列表数字括号列表新建一个 Style，取个名字，然后样式继承于正文（Normal）样式。\n打开 Numbering 面板，切换到 Numbered 选项卡，选择括号样式（也有可能是仅右括号样式），接着点击 Customize。\n按下图输入。\n无序列表目录页码图片和表格图片表格新建一个名为 My Table 的样式，继承于 Normal 样式。改为单倍行距即可。\n图注和表注头注和尾注头注在 Styles Pane 里找到 Header，将其字体大小修改成 9。\n代码块应用设置快捷键在每个样式的设置里都有快捷键设置，位于样式设置面板的左下角里的 Shortcut Key。\n先录制快捷键，这里的快捷键可以自己设置，录制完毕后，点击 Assign。\n快捷键设置推荐：\n一级标题（Heading 1）：command + 1 二级标题（Heading 2）：command + 2 三级标题（Heading 3）：command + 3 正文（Normal）：command + 0 带缩进的正文（Indent）：command + 4 保存样式集最后介绍一下如何将这个样式集保存起来，方便应用在其他 Word 文件中。\n按下 command + , 打开 Word 设置面板，点击第一列的 Ribbon \u0026amp; Toolbar。\n切换到 Quick Access Toolbar 选项卡，左边栏选择 Commands Not in the Ribbon，接着找到并选中 Style Set，点击右箭头。最后保存即可。\n保存此样式集。\n","permalink":"https://blog.cassdev.com/posts/macos-word-%E8%AE%BE%E7%BD%AE%E8%AE%BA%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/","summary":"\u003ch2 id=\"正文\"\u003e正文\u003c/h2\u003e\u003cp\u003e字体大小默认12，两端对齐，1.5倍行距。字体类型选择 Latin 文字，将字体改成 Times New Roman，再将字体类型改成 Asian 亚洲文字，将字体改成 SimHei（黑体）。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2023-10-22 at 21.46.45@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/22/hzB69WHcKSLDYdT.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"带首行缩进的正文\"\u003e带首行缩进的正文\u003c/h2\u003e\u003cp\u003e打开样式面板，点击 New Style。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2023-11-29 at 19.45.34@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/11/29/TacpfhOd6IuNqzJ.png\"\u003e\u003c/p\u003e\n\u003cp\u003e输入样式名称“Indent”，继承于 Normal 样式。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2023-11-29 at 19.46.56@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/11/29/ynCkXH7jRTfrBce.png\"\u003e\u003c/p\u003e\n\u003cp\u003e左下角选择 Paragraph 面板，将 Special 改成 First line，后面填 0.86cm。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2023-10-22 at 21.54.02@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/22/bmk8YnCLD17cBKH.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"各级标题\"\u003e各级标题\u003c/h2\u003e\u003ch3 id=\"一级标题\"\u003e一级标题\u003c/h3\u003e\u003cp\u003e打开 Heading 1 一级标题的设置。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2023-10-22 at 21.31.53@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/22/IhjbkadGzHcfZoO.png\"\u003e\u003c/p\u003e\n\u003cp\u003e字体大小默认16，加粗，黑色，居中对齐，1.5倍行距。字体类型选择 Latin 文字，将字体改成 Times New Roman，再将字体类型改成 Asian 亚洲文字，将字体改成 SimHei（黑体）。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2023-10-22 at 20.43.56@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/22/6WeTgSpLbyVMClD.png\"\u003e\u003c/p\u003e\n\u003cp\u003e左下角选择 Paragraph 面板，将 Special 改成 none，取消继承于正文样式（Normal）的值。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2023-11-29 at 19.04.12@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/11/29/l7spaX1t8oTMv6E.png\"\u003e\u003c/p\u003e","title":"macOS Word 设置论文排版指南"},{"content":"前提 接受短信验证码的 SMI 卡必须在上 iPhone iPhone 和 macOS 须登录同一个 iCloud 打开短信转发打开 iPhone 的设置，找到 Message 短信 App 的设置。\n往下拉，找到 Text Message Forwarding 短信转发并点击，打开需要被转发的 Mac 电脑。若你有 iPda，也可以顺便转发至 iPad。\n打开 macOS 的 Message 短信应用，按下快捷键 command+, 打开设置。打开 iMessage 面板，勾选需要接受的短信来源。\n下载 MessAuto点击跳转 Github 下载地址\n下载自己电脑对应的版本，M系列的芯片下载第一个，Intel芯片下载第二个。\n下载完毕后，解压压缩包会直接得到一个名为 MessAuto.app 的应用程序文件，需要将它拖进 Applicatioin 文件夹里。\n打开 Finder，按下快捷键command+ T 创建新的标签页，再按下 command+shift+A打开 Application 应用程序文件夹。\n回到第一个标签页，将 MessAuto.app 拖到 Application 文件夹下。\n由于 MessAuto 没有 Apple 的开发者证书，所以 M 系列芯片的电脑不能直接打开无需安装的应用程序，所以需要运行命令：\nxattr -cr /Applications/MessAuto.app 运行完毕后方可正常打开 MessAuto。\nMessAuto 是一个没有 GUI 的菜单栏应用程序。需要授予完全磁盘访问权限以及辅助功能权限。\nMessAuto 会自动检测你的短信验证码并复制到系统的剪贴板中。\nAuto paste 即为自动粘贴短信验证码，Auto return 为粘贴验证码后自动回车，Hide icon 为隐藏 MessAuto 的菜单栏图标，Launch at login 为开机自启动，Listen email 为监听邮件验证码。Float window 为悬浮窗功能。\n如果开启了 Listen email，则需要邮件 App 常驻后台，否则无法实时获取到最新的邮件。\n","permalink":"https://blog.cassdev.com/posts/macos-%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%A4%8D%E5%88%B6%E6%B6%88%E6%81%AF%E9%AA%8C%E8%AF%81%E7%A0%81%E6%8C%87%E5%8D%97/","summary":"\u003ch2 id=\"前提\"\u003e前提\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e接受短信验证码的 SMI 卡必须在上 iPhone\u003c/li\u003e\n\u003cli\u003eiPhone 和 macOS 须登录同一个 iCloud\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"打开短信转发\"\u003e打开短信转发\u003c/h2\u003e\u003cp\u003e打开 iPhone 的设置，找到 Message 短信 App 的设置。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"IMG_4653\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/30/qHoz7iTwOhpkuW5.png\"\u003e\u003c/p\u003e\n\u003cp\u003e往下拉，找到 Text Message Forwarding 短信转发并点击，打开需要被转发的 Mac 电脑。若你有 iPda，也可以顺便转发至 iPad。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"IMG_4654\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/30/jbnJeSd87K5IRZP.png\"\u003e\u003c/p\u003e\n\u003cp\u003e打开 macOS 的 Message 短信应用，按下快捷键 \u003ccode\u003ecommand\u003c/code\u003e+\u003ccode\u003e,\u003c/code\u003e 打开设置。打开 iMessage 面板，勾选需要接受的短信来源。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2023-10-30 at 10.56.26@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/30/2wzkGOfLyrCbiTQ.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"下载-messauto\"\u003e下载 MessAuto\u003c/h2\u003e\u003cp\u003e点击跳转 \u003ca href=\"https://github.com/LeeeSe/MessAuto\"\u003eGithub 下载地址\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e下载自己电脑对应的版本，M系列的芯片下载第一个，Intel芯片下载第二个。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2023-10-29 at 23.24.22@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/29/UMl8vyE1OsXCQnP.png\"\u003e\u003c/p\u003e\n\u003cp\u003e下载完毕后，解压压缩包会直接得到一个名为 MessAuto.app 的应用程序文件，需要将它拖进 Applicatioin 文件夹里。\u003c/p\u003e\n\u003cp\u003e打开 Finder，按下快捷键\u003ccode\u003ecommand\u003c/code\u003e+ \u003ccode\u003eT\u003c/code\u003e 创建新的标签页，再按下 \u003ccode\u003ecommand\u003c/code\u003e+\u003ccode\u003eshift\u003c/code\u003e+\u003ccode\u003eA\u003c/code\u003e打开 Application 应用程序文件夹。\u003c/p\u003e\n\u003cp\u003e回到第一个标签页，将 MessAuto.app 拖到 Application 文件夹下。\u003c/p\u003e\n\u003cp\u003e由于 MessAuto 没有 Apple 的开发者证书，所以 M 系列芯片的电脑不能直接打开无需安装的应用程序，所以需要运行命令：\u003c/p\u003e","title":"macOS 设置自动复制消息验证码指南"},{"content":"本指南旨在帮助 macOS 开发者为 Google Coral Dev Board （Google Edege TPU） 通过 OTG 刷入 Mendel Linux 系统。\n第一步：连接到开发板串行控制台安装 USB 转 UART Bridge VCP 驱动程序官方下载地址：https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers?tab=downloads\n下载完成后，双击运行并安装即可。\n安装辅助程序通过 Homebrew 安装：\nsudo brew install screen fastboot 连接开发板先不给开发板供电，使用 micro-B USB 线将 Mac 连接到开发板。连接成功后会开发板会亮起绿色🟩和橙色🟧指示灯。\n随后使用命令查看串口连接是否正常工作：\nls /dev/cu* 连接正常应该会列出/dev/cu.SLAB_USBtoUART，如下图所示。\n然后使用screen命令连接开发板串行命令行：\nscreen /dev/cu.SLAB_USBtoUART 115200 此时命令行应为空白，因为开发板未供电开机。\n给开发板供电如图所示，将开发板电源插入，电源接口为右边的 USB-C 接口。\n连接后开发板会亮起电源指示灯并转动风扇。串行命令行则会打印开发板的开机信息：\n接着在串行命令行输入命令使开发板进入 fastboot 模式：\nfastboot 0 第二步：刷入 Mendel Linux 系统下载 Mendel Linux 系统镜像回到 Mac，下载 Mendel Linux 系统镜像，官方下载地址：https://coral.ai/software/#mendel-dev-board\n下载完成后解压。\n刷入系统如图所示，给开发板插入 OTG 数据线。\n在 Mac 中新建一个终端界面，输入命令：\nfastboot devices 若 OTG 连接成功，则会显示一串序列号1b0741d6f0609912 fastboot。\n连接成功后，转到刚刚下载的 Mendel Linux 文件夹，运行刷入脚本：\nbash flash.sh 刷入过程大约5分钟，刷入成功后，开发板将会自动重启。\n连接网络刷完系统后，需要先登录用户，敲击几下回车键。\n输入用户名：mendel\n输入密码：mendel\n进入系统后先连接好网络，方便后续远程连接到开发板。\n可以使用有线连接，也可以使用 Wi-Fi 连接。Wi-Fi 连接则运行以下命令：\nnmtui 然后选择 Activate a connection 并按照命令行 UI 连接网络即可。\n第三步：配置 SSH 免密登录由于从 MacOS 10.15 (Catalina) 开始，MDT 无法通过 USB 创建到开发板，但还可以通过 SSH 远程连接。\n创建 Mendel SSH 密钥在 Mac 上新建一个终端，输入命令：\nssh-keygen -t rsa -m PEM 输入文件名“mendel”，密码则留空。\n这将在当前目录中创建一个名为 mendel 的私钥和一个名为 mendel.pub 的公钥。\n修改文件权限：\nchmod 600 mendel 将文件移动到 MDT 文件夹：\nmkdir -p ~/.config/mdt/keys \u0026amp;\u0026amp; mv mendel ~/.config/mdt/keys/mdt.key 将公钥复制到开发板输入cat mendel.pub并复制公钥内容。\n转到串行控制台，为 SSH 密钥创建一个新文件：（注意是在开发板上创建）\nmkdir /home/mendel/.ssh \u0026amp;\u0026amp; vi /home/mendel/.ssh/authorized_keys 然后粘贴刚刚复制的公钥内容。完成之后保存并关闭（:wq）。\n开启 SSH 密码登录权限因为 Coral Dev Board 默认禁用了 SSH 密码登录权限，需要手动开启。\n在串行命令行中打开 SSH 配置文件：\nvim /etc/ssh/sshd_config 找到PasswordAuthentication no并修改为PasswordAuthentication yes。\n重启 SSH 服务：\n/etc/init.d/sshd restart 第四步： 安装 MDT 开发工具Mendel Development Tool（MDT）是一个命令行工具，可让你的电脑与 Mendel Linux 系统的设备进行通信。\n使用以下命令方式安装 MDT：\npython3 -m pip install --user mendel-development-tool 安装完毕后需要配置环境变量：\necho \u0026#39;export PATH=\u0026#34;$PATH:$HOME/Library/Python/3.11/bin/\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile 此处的路径与你所使用的Python版本有关。\n使用以下命令连接开发板。\nmdt shell 若提示未找到命令，则表示为环境变量为配置正确，尝试重新配置。\n成功进入提示如下图：\n","permalink":"https://blog.cassdev.com/posts/macos-%E4%B8%BA-google-coral-dev-board-%E5%88%B7%E5%85%A5%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e本指南旨在帮助 macOS 开发者为 Google Coral Dev Board （Google Edege TPU） 通过 OTG 刷入 Mendel Linux 系统。\u003c/p\u003e\n\u003ch2 id=\"第一步连接到开发板串行控制台\"\u003e第一步：连接到开发板串行控制台\u003c/h2\u003e\u003ch3 id=\"安装-usb-转-uart-bridge-vcp-驱动程序\"\u003e安装 USB 转 UART Bridge VCP 驱动程序\u003c/h3\u003e\u003cp\u003e官方下载地址：\u003ca href=\"https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers?tab=downloads\"\u003ehttps://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers?tab=downloads\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CP210x VCP\" loading=\"lazy\" src=\"https://s2.loli.net/2023/07/25/5n7sKqk1ValvcFR.png\"\u003e\u003c/p\u003e\n\u003cp\u003e下载完成后，双击运行并安装即可。\u003c/p\u003e\n\u003ch3 id=\"安装辅助程序\"\u003e安装辅助程序\u003c/h3\u003e\u003cp\u003e通过 Homebrew 安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo brew install screen fastboot\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"连接开发板\"\u003e连接开发板\u003c/h3\u003e\u003cp\u003e先不给开发板供电，使用 micro-B USB 线将 Mac 连接到开发板。连接成功后会开发板会亮起绿色🟩和橙色🟧指示灯。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"micro USB\" loading=\"lazy\" src=\"https://s2.loli.net/2023/07/26/8miISKlWOMy149J.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e随后使用命令查看串口连接是否正常工作：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003els /dev/cu*\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e连接正常应该会列出\u003ccode\u003e/dev/cu.SLAB_USBtoUART\u003c/code\u003e，如下图所示。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"ls /dev/cu*\" loading=\"lazy\" src=\"https://s2.loli.net/2023/07/26/yafnbF9HUe8DQqT.png\"\u003e\u003c/p\u003e\n\u003cp\u003e然后使用\u003ccode\u003escreen\u003c/code\u003e命令连接开发板串行命令行：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003escreen /dev/cu.SLAB_USBtoUART \u003cspan class=\"m\"\u003e115200\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e此时命令行应为空白，因为开发板未供电开机。\u003c/p\u003e\n\u003ch3 id=\"给开发板供电\"\u003e给开发板供电\u003c/h3\u003e\u003cp\u003e如图所示，将开发板电源插入，电源接口为右边的 USB-C 接口。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Power\" loading=\"lazy\" src=\"https://s2.loli.net/2023/07/26/sHYdWNjafQCeTwl.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e连接后开发板会亮起电源指示灯并转动风扇。串行命令行则会打印开发板的开机信息：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Coral Dev Board power on\" loading=\"lazy\" src=\"https://s2.loli.net/2023/07/26/h8JnuNpzWBsG25I.png\"\u003e\u003c/p\u003e\n\u003cp\u003e接着在串行命令行输入命令使开发板进入 fastboot 模式：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efastboot \u003cspan class=\"m\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg alt=\"fastboot 0\" loading=\"lazy\" src=\"https://s2.loli.net/2023/07/26/owkygYAm5JTUxjt.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"第二步刷入-mendel-linux-系统\"\u003e第二步：刷入 Mendel Linux 系统\u003c/h2\u003e\u003ch3 id=\"下载-mendel-linux-系统镜像\"\u003e下载 Mendel Linux 系统镜像\u003c/h3\u003e\u003cp\u003e回到 Mac，下载 Mendel Linux 系统镜像，官方下载地址：\u003ca href=\"https://coral.ai/software/#mendel-dev-board\"\u003ehttps://coral.ai/software/#mendel-dev-board\u003c/a\u003e\u003c/p\u003e","title":"macOS 为 Google Coral Dev Board 刷入系统镜像指南"},{"content":"参考链接：https://unix.stackexchange.com/questions/209746/how-to-resolve-no-protocol-specified-for-su-user\n","permalink":"https://blog.cassdev.com/posts/ssh-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%90%8E%E8%A7%A3%E5%86%B3-no-protocol-specified-%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e参考链接：https://unix.stackexchange.com/questions/209746/how-to-resolve-no-protocol-specified-for-su-user\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"CleanShot 2023-09-27 at 02.08.27@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/09/27/jhPz5KiALJke7NF.png\"\u003e\u003c/p\u003e","title":"SSH 远程连接后解决 No protocol specified 指南"},{"content":"安装不建议使用apt安装，因为apt安装的版本总是不是最新版。一些neovim插件依赖于高版本的neovim，因此使用apt安装可能会导致一些插件无法正常使用。\n下面介绍安装最新版neovim的方法。\n下载安装压缩包：\nwget https://github.com/neovim/neovim/releases/latest/download/nvim-linux64.tar.gz 安装：\ntar xzvf nvim-linux64.tar.gz cp ./nvim-linux64/bin/nvim /usr/bin/ 测试：\nnvim -v nvim配置核心配置配置 nvim 需要先创建配置文件的文件夹。\ncd ~ mkdir -r .config/nvim cd .config/nvim nvim 使用 lua 语言作为配置文件语言，新建 init.lua，该文件是 nvim 的配置的入口。\ntouch init.lua 模块化配置nvim 支持模块化配置，所以可以在 nvim 文件夹下创建多个配置模块：\nmkdir -r lua/core cd lua/core core 文件夹存放 nvim 的核心配置，例如 nvim 基础配置（options.lua）和快捷键配置（keymaps）：\ntouch options.lua keymaps.lua 此时，neovim 的配置文件结构如下所示：\n~ `--.config `-- nvim |-- init.lua |-- lua | |-- core | | |-- keymaps.lua | | `-- options.lua | `-- plugins | `-- plugins-setup.lua `-- plugin `-- packer_compiled.lua 回到 init.lua 文件，在 init.lua 中调用刚刚新建的两个模块：\nrequire(\u0026#34;core.options\u0026#34;) require(\u0026#34;core.keymaps\u0026#34;) 插件管理使用 lazy.vim 作为插件管理工具，\n主题","permalink":"https://blog.cassdev.com/posts/ubuntu-neovim-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","summary":"\u003ch2 id=\"安装\"\u003e安装\u003c/h2\u003e\u003cp\u003e不建议使用\u003ccode\u003eapt\u003c/code\u003e安装，因为\u003ccode\u003eapt\u003c/code\u003e安装的版本总是不是最新版。一些neovim插件依赖于高版本的neovim，因此使用apt安装可能会导致一些插件无法正常使用。\u003c/p\u003e\n\u003cp\u003e下面介绍安装最新版neovim的方法。\u003c/p\u003e\n\u003cp\u003e下载安装压缩包：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewget https://github.com/neovim/neovim/releases/latest/download/nvim-linux64.tar.gz\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar xzvf nvim-linux64.tar.gz\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecp ./nvim-linux64/bin/nvim /usr/bin/\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e测试：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003envim -v\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg alt=\"CleanShot 2023-12-31 at 15.15.57@2x\" loading=\"lazy\" src=\"https://s2.loli.net/2023/12/31/SlKxdfWtwNFCOzy.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"nvim配置\"\u003envim配置\u003c/h2\u003e\u003ch3 id=\"核心配置\"\u003e核心配置\u003c/h3\u003e\u003cp\u003e配置 nvim 需要先创建配置文件的文件夹。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emkdir -r .config/nvim\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e .config/nvim\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003envim 使用 lua 语言作为配置文件语言，新建 init.lua，该文件是 nvim 的配置的入口。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etouch init.lua\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"模块化配置\"\u003e模块化配置\u003c/h3\u003e\u003cp\u003envim 支持模块化配置，所以可以在 nvim 文件夹下创建多个配置模块：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emkdir -r lua/core\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e lua/core\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ecore 文件夹存放 nvim 的核心配置，例如 nvim 基础配置（options.lua）和快捷键配置（keymaps）：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etouch options.lua keymaps.lua\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e此时，neovim 的配置文件结构如下所示：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e~\n`--.config\n   `-- nvim\n       |-- init.lua\n       |-- lua\n       |   |-- core\n       |   |   |-- keymaps.lua\n       |   |   `-- options.lua\n       |   `-- plugins\n       |       `-- plugins-setup.lua\n       `-- plugin\n           `-- packer_compiled.lua\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e回到 init.lua 文件，在 init.lua 中调用刚刚新建的两个模块：\u003c/p\u003e","title":"Ubuntu Neovim 安装和配置指南"},{"content":"连接硬盘先将硬盘与主机相连接，然后运行fdisk命令查看系统的硬盘分区。\nsudo fdisk -l 找到自己连接的硬盘，一般为/dev/sda1。\n查看硬盘UUID运行命令\nsudo blkid 找到自己硬盘的 UUID 和 TYPE，记录下它们。三星 T7 硬盘默认为兼容性较好的 exfat 格式。\n配置开机自动挂载接着修改系统/etc/fstab文件。\nvim /etc/fstab 在文件最后添加一行：\nUUID=C65A-E9E1 ~/disk exfat defaults,nofail,utf8,dmask=022,fmask=133 0 0 内容格式为：\nUUID=\u0026lt;UUID\u0026gt; \u0026lt;挂载目录\u0026gt; \u0026lt;硬盘格式\u0026gt; \u0026lt;挂载参数\u0026gt; \u0026lt;是否自动备份\u0026gt; \u0026lt;开机是否自检\u0026gt; 挂载参数中可以设置：\ndefauls：默认挂载参数；\ndmask=：目录的默认权限；\nfmask=：文件的默认权限；\nuid=：挂载硬盘的用户id；\ngid=：挂载硬盘的组id；\nutf8：字符编码；\nnofail：错误忽略，如果硬盘不存在依然正常开机。\n设置完毕后保存并退出文件。\n重启 Ubuntusudo reboot 重启后将自动挂载硬盘到指定目录。\n","permalink":"https://blog.cassdev.com/posts/ubuntu-%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E4%B8%89%E6%98%9F-t7-%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%E6%8C%87%E5%8D%97/","summary":"\u003ch2 id=\"连接硬盘\"\u003e连接硬盘\u003c/h2\u003e\u003cp\u003e先将硬盘与主机相连接，然后运行\u003ccode\u003efdisk\u003c/code\u003e命令查看系统的硬盘分区。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo fdisk -l\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg alt=\"fdisk -l\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/19/kvu6H917eayRX3Y.png\"\u003e\u003c/p\u003e\n\u003cp\u003e找到自己连接的硬盘，一般为\u003ccode\u003e/dev/sda1\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"查看硬盘uuid\"\u003e查看硬盘UUID\u003c/h2\u003e\u003cp\u003e运行命令\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo blkid\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg alt=\"blkid\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/19/WTeys8u3ElFNxf2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e找到自己硬盘的 UUID 和 TYPE，记录下它们。三星 T7 硬盘默认为兼容性较好的 exfat 格式。\u003c/p\u003e\n\u003ch2 id=\"配置开机自动挂载\"\u003e配置开机自动挂载\u003c/h2\u003e\u003cp\u003e接着修改系统\u003ccode\u003e/etc/fstab\u003c/code\u003e文件。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003evim /etc/fstab\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在文件最后添加一行：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eUUID=C65A-E9E1 ~/disk exfat defaults,nofail,utf8,dmask=022,fmask=133 0 0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e内容格式为：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eUUID=\u0026lt;UUID\u0026gt; \u0026lt;挂载目录\u0026gt; \u0026lt;硬盘格式\u0026gt; \u0026lt;挂载参数\u0026gt; \u0026lt;是否自动备份\u0026gt; \u0026lt;开机是否自检\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e挂载参数中可以设置：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003edefauls\u003c/code\u003e：默认挂载参数；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003edmask=\u003c/code\u003e：目录的默认权限；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003efmask=\u003c/code\u003e：文件的默认权限；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003euid=\u003c/code\u003e：挂载硬盘的用户id；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003egid=\u003c/code\u003e：挂载硬盘的组id；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eutf8\u003c/code\u003e：字符编码；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003enofail\u003c/code\u003e：错误忽略，如果硬盘不存在依然正常开机。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e设置完毕后保存并退出文件。\u003c/p\u003e\n\u003ch2 id=\"重启-ubuntu\"\u003e重启 Ubuntu\u003c/h2\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo reboot\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e重启后将自动挂载硬盘到指定目录。\u003c/p\u003e","title":"Ubuntu 配置开机自动挂载三星 T7 固态硬盘指南"},{"content":"待优化！\n基于 Visual Studio\n{ IndentWidth: 4, IndentCaseLabels: true, ColumnLimit: 120, NamespaceIndentation: All, IndentAccessModifiers: false, AccessModifierOffset: -4, AlignTrailingComments: true, AlwaysBreakTemplateDeclarations: true } IndentWidth: 缩进4格 ","permalink":"https://blog.cassdev.com/posts/vs-code-clang-%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%85%8D%E7%BD%AE/","summary":"\u003cp\u003e待优化！\u003c/p\u003e\n\u003cp\u003e基于 Visual Studio\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"err\"\u003eIndentWidth:\u003c/span\u003e \u003cspan class=\"err\"\u003e4,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"err\"\u003eIndentCaseLabels:\u003c/span\u003e \u003cspan class=\"err\"\u003etrue,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"err\"\u003eColumnLimit:\u003c/span\u003e \u003cspan class=\"err\"\u003e120,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"err\"\u003eNamespaceIndentation:\u003c/span\u003e \u003cspan class=\"err\"\u003eAll,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"err\"\u003eIndentAccessModifiers:\u003c/span\u003e \u003cspan class=\"err\"\u003efalse,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"err\"\u003eAccessModifierOffset:\u003c/span\u003e \u003cspan class=\"err\"\u003e-4,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"err\"\u003eAlignTrailingComments:\u003c/span\u003e \u003cspan class=\"err\"\u003etrue,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"err\"\u003eAlwaysBreakTemplateDeclarations:\u003c/span\u003e \u003cspan class=\"err\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eIndentWidth: 缩进4格\u003c/li\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"VS Code Clang 语法格式化配置"},{"content":"当你使用 VS Code 时，有时你可能需要配置网络代理来访问特定的网络资源（魔法）。\n例如在局域网远程开发时使用 GitHub Copilot Chat 插件并且远程主机无魔法时就可以进行配置网络代理。\n配置教程打开设置，搜索 proxy 找到 Http: Proxy，填入代理地址即可。\n注意在远程开发时只能设置远程主机的Http代理，无法设置 VS Code 本机的网络代理。\n","permalink":"https://blog.cassdev.com/posts/vs-code-%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e当你使用 VS Code 时，有时你可能需要配置网络代理来访问特定的网络资源（魔法）。\u003c/p\u003e\n\u003cp\u003e例如在局域网远程开发时使用 GitHub Copilot Chat 插件并且远程主机无魔法时就可以进行配置网络代理。\u003c/p\u003e\n\u003ch2 id=\"配置教程\"\u003e配置教程\u003c/h2\u003e\u003cp\u003e打开设置，搜索 proxy 找到 Http: Proxy，填入代理地址即可。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"VSCode Proxy\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/30/tQqCS5XvzgmLbFK.png\"\u003e\u003c/p\u003e\n\u003cp\u003e注意在远程开发时只能设置远程主机的Http代理，无法设置 VS Code 本机的网络代理。\u003c/p\u003e","title":"VS Code 设置网络代理指南"},{"content":"可以说，YOLO各代升级的改进点都是提升检测效果mAP和速度FPS。\nPrecision精度与Recall召回率要计算精度与召回率（查全率），我们需要先了解四个值：\nTP（True Positives） FP（False Positives） FN（False Negatives） TN（True Negatives） 相关（Relevant），正类 无关（NonRelevant），负类 被检索到（Retrieved） TP，正类判定为正类。 FP，负类判定为正类 未被检索到（Not Retrieved） FN，正类判定为负类 TN，负类判断为负类 记忆方法我们只需要记住这里面的四个单词的中文意思方可推断出四个值的含义。True 正确的、False 错误的、Positives 正类以及 Negatives 负类。\nTrue Positives（\u0026#x2795;\u0026#x2795;）——正确的判断为正类，即将正类判定为正类。\nFalse Positives（\u0026#x2796;\u0026#x2795;）——错误的判定为正类，即将负类判定为正类。\nFalse Negatives（\u0026#x2795;\u0026#x2796;）——错误的判定为负类，即将正类判定为正类。\nTrue Negatives（\u0026#x2796;\u0026#x2796;）——正确的判定为负类，即将负类判定为负类。\n计算公式$$ Precision = \\frac{TP}{TP+FP} $$\n$$ Recall = \\frac{TP}{TP + FN} $$\n为了方便理解，我画了一个草图，以格子为单位。其中蓝色框代表实际值，橙色框代表预测值。\n真正的正类（蓝色框内）共20个格子，真正的负类（蓝色框外）共10个格子。判定的正类（橙色框内），判定的负类（橙色框外）\nTP值（正确的判断为正类），真正的正类与判定的正类的交集，即涂黄色的格子，共9个格子。\nFP值（错误的判定为正类），真正的负类与判定的正类的交集，即涂绿色的格子，共6个格子。\nFN值（错误的判定为负类），真正的正类与判定的负类的交集，即涂蓝色的格子，共11个格子。\nTN值（正确的判定为负类），真正的负类与判定的负类的交集，即涂红色的格子，共4个格子。\n例子已知条件：班级总人数100人，其中男生80人，女生20人。 目标：找出所有的女生。 结果：从班级中选择了50人，其中20人是女生，还错误的把30名男生挑选出来了。\nTP = 20; FP = 30; FN = 0; TN = 50\nmAP指标目标检测不可单看精度（Precision）或召回率（Recall），因为两者为此消彼长的关系。所以需要一个新的指标用于综合的衡量目标检测的效果。\nmAP（mean Average Precision）指标，又名全类平均精度，用于综合衡量目标检测的效果。\n它是多种类别的AP值的平均值。关于AP值如何计算将在下面介绍。\nIoU指标IoU（Intersection of unit）意思就是交集和并集的比值。在目标检测中，即真实值（蓝色框）和预测值（橙色框）的交集和其并集的比值。\nIoU值越高表示预测值和真实值越吻合，即检测越准确。\n检测任务中的检测指标置信度置信度(Confidence)是模型对检测出的每个目标框预测正确的概率或确信程度。\n例如下面三图中，绿色框左上角的红色数字0.9、0.8和0.7都代表这个框内物体为人脸的概率。\n计算精度和召回率在一次检测任务中，一般基于置信度阈值来计算此次检测任务的精度和召回率。\n在一次检测中，算法会产生很多的检测框，框的置信度不一，因此需要设置一个置信度阈值来过滤掉置信度较低的框，只留下置信度高的检测框。\n还是上图，当置信度阈值为0.9时，只有左图置信度大于等于0.9，因此TP = 1、FP = 0、FN = 2；\n计算可得精度 Precision = 1/1； 召回率Recall = 1/3。\n计算AP值与mAP值计算mAP值之前需要先计算某一类别的AP值，如人脸检测的AP值。将精度Precision和召回率Recall分别放在直角坐标系的Y轴和X轴，这样就得到了PR图（Precision x Recall curve）。\n左图中蓝实线 Precision 为原始精度，为锯齿状，不符合一般化规律。 红虚线 Interpolated precision 为插值后的精度，插值方法简单来说就是将某点的精确率替换为该召回率右侧的所有召回率对应的精确率的最大值。\n如右图所示，AP值即为红虚线（插值后的精度）下方的面积。\n计算出各个种类（人脸、苹果、骑车）的AP值后，再求它们的平均值即为mAP值。\n","permalink":"https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/","summary":"\u003cp\u003e可以说，YOLO各代升级的改进点都是提升检测效果mAP和速度FPS。\u003c/p\u003e\n\u003ch2 id=\"precision精度与recall召回率\"\u003ePrecision精度与Recall召回率\u003c/h2\u003e\u003cp\u003e要计算精度与召回率（查全率），我们需要先了解四个值：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTP（True Positives）\u003c/li\u003e\n\u003cli\u003eFP（False Positives）\u003c/li\u003e\n\u003cli\u003eFN（False Negatives）\u003c/li\u003e\n\u003cli\u003eTN（True Negatives）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e相关（Relevant），正类\u003c/th\u003e\n          \u003cth\u003e无关（NonRelevant），负类\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e被检索到（Retrieved）\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eTP，正类判定为正类。\u003c/td\u003e\n          \u003ctd\u003eFP，负类判定为正类\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e未被检索到（Not Retrieved）\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eFN，正类判定为负类\u003c/td\u003e\n          \u003ctd\u003eTN，负类判断为负类\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"记忆方法\"\u003e记忆方法\u003c/h3\u003e\u003cp\u003e我们只需要记住这里面的四个单词的中文意思方可推断出四个值的含义。True 正确的、False 错误的、Positives 正类以及 Negatives 负类。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTrue Positives（\u0026#x2795;\u0026#x2795;）——正确的判断为正类，即将正类判定为正类。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFalse Positives（\u0026#x2796;\u0026#x2795;）——错误的判定为正类，即将负类判定为正类。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFalse Negatives（\u0026#x2795;\u0026#x2796;）——错误的判定为负类，即将正类判定为正类。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTrue Negatives（\u0026#x2796;\u0026#x2796;）——正确的判定为负类，即将负类判定为负类。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"计算公式\"\u003e计算公式\u003c/h3\u003e\u003cp\u003e$$\nPrecision = \\frac{TP}{TP+FP}\n$$\u003c/p\u003e\n\u003cp\u003e$$\nRecall = \\frac{TP}{TP + FN}\n$$\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"IMG_4784\" loading=\"lazy\" src=\"https://s2.loli.net/2023/08/28/DLUk8I91clvCbwd.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e为了方便理解，我画了一个草图，以格子为单位。其中蓝色框代表实际值，橙色框代表预测值。\u003c/p\u003e\n\u003cp\u003e真正的正类（蓝色框内）共20个格子，真正的负类（蓝色框外）共10个格子。判定的正类（橙色框内），判定的负类（橙色框外）\u003c/p\u003e\n\u003cp\u003eTP值（正确的判断为正类），真正的正类与判定的正类的交集，即涂黄色的格子，共9个格子。\u003c/p\u003e\n\u003cp\u003eFP值（错误的判定为正类），真正的负类与判定的正类的交集，即涂绿色的格子，共6个格子。\u003c/p\u003e\n\u003cp\u003eFN值（错误的判定为负类），真正的正类与判定的负类的交集，即涂蓝色的格子，共11个格子。\u003c/p\u003e\n\u003cp\u003eTN值（正确的判定为负类），真正的负类与判定的负类的交集，即涂红色的格子，共4个格子。\u003c/p\u003e\n\u003ch3 id=\"例子\"\u003e例子\u003c/h3\u003e\u003cp\u003e已知条件：班级总人数100人，其中男生80人，女生20人。\n目标：找出所有的女生。\n结果：从班级中选择了50人，其中20人是女生，还错误的把30名男生挑选出来了。\u003c/p\u003e\n\u003cp\u003eTP = 20; FP = 30; FN = 0; TN = 50\u003c/p\u003e\n\u003ch2 id=\"map指标\"\u003emAP指标\u003c/h2\u003e\u003cp\u003e目标检测不可单看精度（Precision）或召回率（Recall），因为两者为此消彼长的关系。所以需要一个新的指标用于综合的衡量目标检测的效果。\u003c/p\u003e\n\u003cp\u003emAP（mean Average Precision）指标，又名全类平均精度，用于综合衡量目标检测的效果。\u003c/p\u003e","title":"YOLO 目标检测算法学习笔记（二）"},{"content":"YOLO-V1YOLO，全称 You Only Look Once。名字已经说明了一切！\nYOLO 这是一个经典的 one-stage 方法，把检测问题转换为回归问题，一个CNN就可以搞定。\nYOLO 相比于 Faster R-CNN 虽然在 mAP 值上略逊一筹，但其 FPS 值是远远高于 Faster R-CNN 的，因此2016年的时，YOLO爆火。\n核心思想\n将输入图像分割成 SxS 个网格（如7x7），每个网格负责检测本身区域是否含有物体。\n每个网格会预测 B 个边界框（在YOLO-V1中，B值等于2），边界框由四个变量表示 x、y、w、h，以及每个边界框的置信度，置信度用 c 表示。置信度表示边界框包含物体的概率。\n过滤掉置信度低的边界框。\n由于整个检测只需要一个前向传播，没有区域提议生成候选框的过程，所以速度非常快。\n网络架构\n将输入图像（在YOLO-V1中限制了输入图像的大小）进行通过卷积神经网络进行特征提取，获得 7x7x1024 的特征图，再进入全连接层，得到 1470 个特征，随后 Reshape 成 7x7x30 的特征图。\n下面解释一下 7x7x30 的含义。\n7x7 表示输入图像最后分割的网格大小。\n30 分为 5+5+20，其中前两个5代表两个边界框的 x、y、w、h和c；最后的20表示当前格子属于数据集中的各个类别的概率。\n注意，这里三个值都不是固定不变的，会由于YOLO版本的更新和训练数据集的变化而改变。\n总结一下 ，如上图所示，输入图像最后会被分割成许多个网格，每个网格都包含了若干值。\nS：网格边长；B：预测边界框数量；C：数据集中的类别个数。 $$ (S * S) * (B * 5 + C) $$\n损失函数\n","permalink":"https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/","summary":"\u003ch2 id=\"yolo-v1\"\u003eYOLO-V1\u003c/h2\u003e\u003cp\u003eYOLO，全称 You Only Look Once。名字已经说明了一切！\u003c/p\u003e\n\u003cp\u003eYOLO 这是一个经典的 one-stage 方法，把检测问题转换为回归问题，一个CNN就可以搞定。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"YOLO-V1 mAP\" loading=\"lazy\" src=\"https://s2.loli.net/2023/08/30/UHC9IP5gSdZfolr.png\"\u003e\u003c/p\u003e\n\u003cp\u003eYOLO 相比于 Faster R-CNN 虽然在 mAP 值上略逊一筹，但其 FPS 值是远远高于 Faster R-CNN 的，因此2016年的时，YOLO爆火。\u003c/p\u003e\n\u003ch2 id=\"核心思想\"\u003e核心思想\u003c/h2\u003e\u003cp\u003e\u003cimg alt=\"YOLO 核心思想\" loading=\"lazy\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e将输入图像分割成 SxS 个网格（如7x7），每个网格负责检测本身区域是否含有物体。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e每个网格会预测 B 个边界框（在YOLO-V1中，B值等于2），边界框由四个变量表示 x、y、w、h，以及每个边界框的置信度，置信度用 c 表示。置信度表示边界框包含物体的概率。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e过滤掉置信度低的边界框。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e由于整个检测只需要一个前向传播，没有区域提议生成候选框的过程，所以速度非常快。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"网络架构\"\u003e网络架构\u003c/h2\u003e\u003cp\u003e\u003cimg alt=\"YOLO 网络架构\" loading=\"lazy\"\u003e\u003c/p\u003e\n\u003cp\u003e将输入图像（在YOLO-V1中限制了输入图像的大小）进行通过卷积神经网络进行特征提取，获得 7x7x1024 的特征图，再进入全连接层，得到 1470 个特征，随后 Reshape 成 7x7x30 的特征图。\u003c/p\u003e\n\u003cp\u003e下面解释一下 7x7x30 的含义。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e7x7  表示输入图像最后分割的网格大小。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e30 分为 5+5+20，其中前两个5代表两个边界框的 x、y、w、h和c；最后的20表示当前格子属于数据集中的各个类别的概率。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e注意，这里三个值都不是固定不变的，会由于YOLO版本的更新和训练数据集的变化而改变。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"YOLO 网络架构简化\" loading=\"lazy\" src=\"https://s2.loli.net/2023/08/30/3iVITLdxk4RA5Hf.png\"\u003e\u003c/p\u003e\n\u003cp\u003e总结一下 ，如上图所示，输入图像最后会被分割成许多个网格，每个网格都包含了若干值。\u003c/p\u003e\n\u003cp\u003eS：网格边长；B：预测边界框数量；C：数据集中的类别个数。\n$$\n(S * S) * (B * 5 + C)\n$$\u003c/p\u003e","title":"YOLO 目标检测算法学习笔记（三）"},{"content":"YOLO-V2下图为YOLO-V2相较于YOLO-V1的改进点，以及改进后 mAP 值的变化。\nBatch NormalizationV2 版本舍弃了 Dropout，不再有全连接层（Fully connected layers，FC）。每次卷积后都加入 Batch Normalization，对网络的每一层的输入都进行归一化，使收敛更容易。\n经过 Batch Normalization 处理后的网络会提升2%的mAP值。\n从现在的角度来看，Batch Normatlization 已经称为卷积神经网络处理必备处理了。\nHigh Resolution ClassifierHigh Resolution Classifier，即高分辨率分类器，高分辨率分类器。\n在 V1 版本，训练时用的是224*224分辨率的图片，测试时又使用448*448分辨率的图片，这会导致模型“水土不服”。\n针对这一问题，V2 版本在模型训练时额外进行了10次448*448的微调。经过微调后，V2 版本的 mAP 值提升了约4%。\nConvolutional","permalink":"https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/","summary":"\u003ch2 id=\"yolo-v2\"\u003eYOLO-V2\u003c/h2\u003e\u003cp\u003e下图为YOLO-V2相较于YOLO-V1的改进点，以及改进后 mAP 值的变化。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"YOLO-V2\" loading=\"lazy\" src=\"https://s2.loli.net/2023/08/30/CmvK9W1bdpauPtR.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"batch-normalization\"\u003eBatch Normalization\u003c/h2\u003e\u003cp\u003eV2 版本舍弃了 Dropout，不再有全连接层（Fully connected layers，FC）。每次卷积后都加入 Batch Normalization，对网络的每一层的输入都进行归一化，使收敛更容易。\u003c/p\u003e\n\u003cp\u003e经过 Batch Normalization 处理后的网络会提升2%的mAP值。\u003c/p\u003e\n\u003cp\u003e从现在的角度来看，Batch Normatlization 已经称为卷积神经网络处理必备处理了。\u003c/p\u003e\n\u003ch2 id=\"high-resolution-classifier\"\u003eHigh Resolution Classifier\u003c/h2\u003e\u003cp\u003eHigh Resolution Classifier，即高分辨率分类器，高分辨率分类器。\u003c/p\u003e\n\u003cp\u003e在 V1 版本，训练时用的是224*224分辨率的图片，测试时又使用448*448分辨率的图片，这会导致模型“水土不服”。\u003c/p\u003e\n\u003cp\u003e针对这一问题，V2 版本在模型训练时额外进行了10次448*448的微调。经过微调后，V2 版本的 mAP 值提升了约4%。\u003c/p\u003e\n\u003ch2 id=\"convolutional\"\u003eConvolutional\u003c/h2\u003e","title":"YOLO 目标检测算法学习笔记（四）"},{"content":"深度学习经典检测方法 one-stage（单阶段）：YOLO系列\ntwo-stage（双阶段）：Faster-Rcnn、Mask-Rcnn系列\nFaster-Rcnn：物体检测开山之作。\none-stage 单阶段检测优势：速度快，适合做实时检测任务。\n缺点：效果不佳。\n目标检测的两个主要指标：mAP和FPS。\nmAP：检测效果的综合指标。（mAP值越大效果越好）\ntwo-stage 双阶段检测优势：效果较好。\n缺点：速度较慢、不适合用于视频流的实时检测。\nMask-Rcnn是一个非常实用的通用框架（建议了解）。\n","permalink":"https://blog.cassdev.com/posts/yolo-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/","summary":"\u003ch2 id=\"深度学习经典检测方法\"\u003e深度学习经典检测方法\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eone-stage（单阶段）：YOLO系列\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003etwo-stage（双阶段）：Faster-Rcnn、Mask-Rcnn系列\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"深度学习经典检测方法\" loading=\"lazy\" src=\"https://s2.loli.net/2023/08/28/mX5t61TwqAR3nHB.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFaster-Rcnn：物体检测开山之作。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"one-stage-单阶段检测\"\u003eone-stage 单阶段检测\u003c/h2\u003e\u003cp\u003e优势：速度快，适合做实时检测任务。\u003c/p\u003e\n\u003cp\u003e缺点：效果不佳。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"one-stage 单阶段检测\" loading=\"lazy\" src=\"https://s2.loli.net/2023/08/28/rFkyvMngZcAJPDo.png\"\u003e\u003c/p\u003e\n\u003cp\u003e目标检测的两个主要指标：mAP和FPS。\u003c/p\u003e\n\u003cp\u003emAP：检测效果的综合指标。（mAP值越大效果越好）\u003c/p\u003e\n\u003ch2 id=\"two-stage-双阶段检测\"\u003etwo-stage 双阶段检测\u003c/h2\u003e\u003cp\u003e优势：效果较好。\u003c/p\u003e\n\u003cp\u003e缺点：速度较慢、不适合用于视频流的实时检测。\u003c/p\u003e\n\u003cp\u003eMask-Rcnn是一个非常实用的通用框架（建议了解）。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"two-stage 双阶段检测\" loading=\"lazy\" src=\"https://s2.loli.net/2023/08/28/qcefLK8pBjFnsMa.png\"\u003e\u003c/p\u003e","title":"YOLO 目标检测算法学习笔记（一）"},{"content":"蓝牙 BLE 是什么蓝牙BLE，即蓝牙低功耗 （Bluetooth Lower Energy）是一种蓝牙通信标准，设计用于短距离通信和低功耗应用。\n相比经典蓝牙，BLE 更加节能，传输距离更远，连接更快。BLE 主要用于健身设备、医疗设备、家居自动化等场景。\n蓝牙 BLE 设备的连接信道L2CAP的基本概念是信道（Signaling Channel）。信道是个抽象概念，表示两个设备某个协议层之间的通道。每个信道分配一个2字节的信道ID——CID（Channel ID），每个信道功用不同，比如CID=0x0004的信道表示属性协议（Attribute Protocol）专用信道。对于BLE协议，L2CAP共有三个信道ID：\n0x0004 – 属性协议 0x0005 – 低功耗信令信道 0x0006 – 安全管理协议 其他信道则用于经典蓝牙。协议复用可以理解为，不同的协议走不同的信道，互不干扰。\n代码#define ATT_CID 4; // 创建 L2CAP socket int s = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP); // 绑定 L2CAP socket struct sockaddr_l2 bind_addr = {0}; bind_addr.l2_family = AF_BLUETOOTH; bind_addr.l2_cid = htobs(ATT_CID); // ATT 信道 CID bdaddr_t any_addr = {{0, 0, 0, 0, 0, 0}}; bacpy(\u0026amp;bind_addr.l2_bdaddr, \u0026amp;any_addr); bind_addr.l2_bdaddr_type = BDADDR_LE_PUBLIC; int err = bind(s, (struct sockaddr *)\u0026amp;bind_addr, sizeof(bind_addr)); if (err) { return -1; } // 连接 L2CAP socket struct sockaddr_l2 conn_addr = {0}; conn_addr.l2_family = AF_BLUETOOTH; conn_addr.l2_cid = htobs(ATT_CID); // ATT CID str2ba(mac_address.c_str(), \u0026amp;conn_addr.l2_bdaddr); conn_addr.l2_bdaddr_type = BDADDR_LE_PUBLIC; err = connect(s, (struct sockaddr *)\u0026amp;conn_addr, sizeof(conn_addr)); if (err) { exit(-1); } L2CAP 数据包解析L2CAP（Logical Linked Control and Adaptation Protocol 逻辑链路控制与适配协议）工作在链路层,为上层协议提供数据通道。它支持数据分片与重组,确保数据完整可靠地传输。\n它位于BLE协议的主机（Host）部分，承担着协议复用（Protocol Multiplex）的任务。\nMTUMTU，即最大传输单元（Maximum Transmission Unit）。BLE协议默认的MTU为23字节。MTU包括三个部分：OP Code（1Byte），Handler（2Byte），Payload。\nOP Code (1 byte) Handle (2 byte 小端) Payload (0 - 20 byte) OP Code 属性操作码下表为各个 OP Code 属性操作码的名称和参数。其中以 REQ (Requset) 结尾的为请求信息，以 RSP (Response) 结尾的为回应信息。\n属性 PDU 名称 属性 Opcode 参数 ATT_ERROR_RSP 0x01 请求操作码错误、属性句柄错误、错误代码 ATT_EXCHANGE_MTU_REQ 0x02 客户端接收 MTU ATT_EXCHANGE_MTU_RSP 0x03 服务器接收 MTU ATT_FIND_INFORMATION_REQ 0x04 起始句柄、结束句柄 ATT_FIND_INFORMATION_RSP 0x05 格式、信息数据 ATT_FIND_BY_TYPE_VALUE_REQ 0x06 起始 Handle，结束 Handle，属性类型，属性值 ATT_FIND_BY_TYPE_VALUE_RSP 0x07 Handle 信息列表 ATT_READ_BY_TYPE_REQ 0x08 起始 Handle，结束 Handle，UUID ATT_READ_BY_TYPE_RSP 0x09 长度，属性数据列表 ATT_READ_REQ 0x0A 属性 Handle ATT_READ_RSP 0x0B 属性值 ATT_READ_BLOB_REQ 0x0C 属性 Handle，值偏移 ATT_READ_BLOB_RSP 0x0D 零件属性值 ATT_READ_MULTIPLE_REQ 0x0E Handle 集合 ATT_READ_MULTIPLE_RSP 0x0F 值集合 ATT_READ_BY_GROUP_TYPE_REQ 0x10 起始 Handle，终止 Handle，UUID ATT_READ_BY_GROUP_TYPE_RSP 0x11 长度，属性数据列表 ATT_WRITE_REQ 0x12 属性 Handle，属性值 ATT_WRITE_RSP 0x13 —— ATT_WRITE_CMD 0x52 属性 Handle，属性值 详见：蓝牙核心规范版本 5.3 |第 3 卷，F 部分：3.4.8 Attribute Opcode summary\nHandle 属性句柄使用 gatttool 命令行工具蓝牙BLE设备的 Handle 信息\ngatttool -i hci0 -b \u0026lt;蓝牙BLE设备MAC地址\u0026gt; --characteristics gatttool -i hci0 -b \u0026lt;蓝牙BLE设备MAC地址\u0026gt; --primary Payload 实际数据Payload 实际数据就是你所需要发送的数据包\n代码示例#define ATT_CID 4; int ble_connect_l2cap(string mac_address) { // arm mac address: 08:B6:1F:C1:DB:1A int s = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP); if (s \u0026lt; 0) { return -1; } struct sockaddr_l2 bind_addr = {0}; bind_addr.l2_family = AF_BLUETOOTH; bind_addr.l2_cid = htobs(ATT_CID); // ATT CID bdaddr_t any_addr = {{0, 0, 0, 0, 0, 0}}; bacpy(\u0026amp;bind_addr.l2_bdaddr, \u0026amp;any_addr); bind_addr.l2_bdaddr_type = BDADDR_LE_PUBLIC; int err = bind(s, (struct sockaddr *)\u0026amp;bind_addr, sizeof(bind_addr)); if (err) { Debug::CoutError(\u0026#34;{}，绑定L2CAP socket失败\u0026#34;, mac_address); return -1; } struct sockaddr_l2 conn_addr = {0}; conn_addr.l2_family = AF_BLUETOOTH; conn_addr.l2_cid = htobs(ATT_CID); // ATT CID str2ba(mac_address.c_str(), \u0026amp;conn_addr.l2_bdaddr); conn_addr.l2_bdaddr_type = BDADDR_LE_PUBLIC; err = connect(s, (struct sockaddr *)\u0026amp;conn_addr, sizeof(conn_addr)); if (err) { Debug::CoutError(\u0026#34;{}，连接L2CAP socket失败\u0026#34;, mac_address); return -1; } // MTU默认23字节： op code(1 字节)，handle(2 字节，小端)，payload(0-20字节) // char on[] = {0x12, 0x2d, 0x00, 0xFE, 0xFE, 0x0F, 0x22, 0x00, 0x00, 0x00, 0x00, // 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0xFA}; char op[] = {0x12}; char ha[] = {0x2d, 0x00}; char on[] = {0xFE, 0xFE, 0x0F, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0xFA}; ble_send_l2cap(s, (unsigned char *)op, (unsigned char *)ha, (unsigned char *)on); return s; } // MTU默认23字节： op code(1 字节)，handle(2 字节，小端)，payload(0-20字节) int ble_send_l2cap(int fd, const unsigned char *op_code, const unsigned char *handle, const unsigned char *data) { // 将 op code, handle, data 拼接成一个数组，使用拼接函数 unsigned char buf[23]; memcpy(buf, op_code, 1); memcpy(buf + 1, handle, 2); memcpy(buf + 3, data, 20); int len = -1; if (len = write(fd, buf, sizeof(buf)) \u0026lt; 0) { Debug::CoutError(\u0026#34;发送数据失败\u0026#34;); return -1; } return len; } 参考文章 BLE协议栈 – L2CAP Maximum Packet Size According to MTU – KBA203312 ","permalink":"https://blog.cassdev.com/posts/%E5%9F%BA%E4%BA%8E-l2cap-%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%93%9D%E7%89%99-ble-%E8%AE%BE%E5%A4%87%E9%80%9A%E4%BF%A1%E6%8C%87%E5%8D%97/","summary":"\u003ch2 id=\"蓝牙-ble-是什么\"\u003e蓝牙 BLE 是什么\u003c/h2\u003e\u003cp\u003e蓝牙BLE，即蓝牙低功耗 （Bluetooth Lower Energy）是一种蓝牙通信标准，设计用于短距离通信和低功耗应用。\u003c/p\u003e\n\u003cp\u003e相比经典蓝牙，BLE 更加节能，传输距离更远，连接更快。BLE 主要用于健身设备、医疗设备、家居自动化等场景。\u003c/p\u003e\n\u003ch2 id=\"蓝牙-ble-设备的连接\"\u003e蓝牙 BLE 设备的连接\u003c/h2\u003e\u003ch2 id=\"信道\"\u003e信道\u003c/h2\u003e\u003cp\u003eL2CAP的基本概念是信道（Signaling Channel）。信道是个抽象概念，表示两个设备某个协议层之间的通道。每个信道分配一个2字节的信道ID——CID（Channel ID），每个信道功用不同，比如CID=0x0004的信道表示属性协议（Attribute Protocol）专用信道。对于BLE协议，L2CAP共有三个信道ID：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e0x0004 – 属性协议\u003c/li\u003e\n\u003cli\u003e0x0005 – 低功耗信令信道\u003c/li\u003e\n\u003cli\u003e0x0006 – 安全管理协议\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e其他信道则用于经典蓝牙。协议复用可以理解为，不同的协议走不同的信道，互不干扰。\u003c/p\u003e\n\u003ch2 id=\"代码\"\u003e代码\u003c/h2\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#define ATT_CID 4;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 创建 L2CAP socket\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003esocket\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePF_BLUETOOTH\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eSOCK_SEQPACKET\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBTPROTO_L2CAP\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 绑定 L2CAP socket\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"nc\"\u003esockaddr_l2\u003c/span\u003e \u003cspan class=\"n\"\u003ebind_addr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ebind_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003el2_family\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eAF_BLUETOOTH\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ebind_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003el2_cid\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ehtobs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eATT_CID\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e// ATT 信道 CID\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003ebdaddr_t\u003c/span\u003e \u003cspan class=\"n\"\u003eany_addr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{{\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e}};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ebacpy\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ebind_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003el2_bdaddr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eany_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ebind_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003el2_bdaddr_type\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBDADDR_LE_PUBLIC\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eerr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"nc\"\u003esockaddr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ebind_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebind_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eerr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 连接 L2CAP socket\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"nc\"\u003esockaddr_l2\u003c/span\u003e \u003cspan class=\"n\"\u003econn_addr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003econn_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003el2_family\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eAF_BLUETOOTH\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003econn_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003el2_cid\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ehtobs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eATT_CID\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e// ATT CID\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estr2ba\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emac_address\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ec_str\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003econn_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003el2_bdaddr\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003econn_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003el2_bdaddr_type\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBDADDR_LE_PUBLIC\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eerr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003econnect\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"nc\"\u003esockaddr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003econn_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econn_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eerr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"l2cap-数据包解析\"\u003eL2CAP 数据包解析\u003c/h2\u003e\u003cp\u003eL2CAP（Logical Linked Control and Adaptation Protocol 逻辑链路控制与适配协议）工作在链路层,为上层协议提供数据通道。它支持数据分片与重组,确保数据完整可靠地传输。\u003c/p\u003e","title":"基于 L2CAP 协议的蓝牙 BLE 设备通信指南"},{"content":"简单粗暴，给本地主机和远程主机都安装上C/C++插件即可。\n","permalink":"https://blog.cassdev.com/posts/%E8%A7%A3%E5%86%B3vscode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91c++%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%97%A0%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA%E9%97%AE%E9%A2%98/","summary":"\u003cp\u003e简单粗暴，给本地主机和远程主机都安装上C/C++插件即可。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"C/C++ Plugin\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/21/eBLlkS63OX2roTV.png\"\u003e\u003c/p\u003e","title":"解决VScode远程开发C++项目时无代码提示问题"},{"content":"在编写点云变换和姿态估计代码时，我们经常需要从结果的变换矩阵中提取平移信息，并分析平移量的大小，帮助判断结果的准确性。\n本文将介绍如何从变换矩阵中提取平移向量，并计算其欧几里得长度。\n提取平移向量假设我们通过某种姿态估计算法得到了一个4x4的变换矩阵 result.transformation_ ,其中包含了旋转和平移信息。\n我们可以通过以下代码提取出平移部分:（以Open3D为例）\ncore::Tensor translation = result.transformation_.Slice(0, 0, 3).Slice(1, 3, 4); Slice(0,0,3);表示从矩阵的第0维(行)，第0行开始，取3行，即前3行；Slice(1,3,4);表示从矩阵的第1维(列)，第3列开始，取1列，即第4列。 最后获得一个3x1的平移向量，包含x、y、z三个方向的平移量。\n计算欧几里得长度有了平移向量后,我们可以计算其欧几里得长度,表示平移量的大小:\ndouble translation_norm = std::sqrt((translation * translation).Sum({0, 1}).Item\u0026lt;double\u0026gt;()); std::sqrt计算平方根，translation * translation 计算向量每个元素的平方，Sum 聚合，最终得到平移向量的L2范数，即欧几里得长度。\n分析平移量通过提取并计算平移向量的模长，我们可以分析相机或物体的移动距离，以及姿态估计结果的准确性。\n如果 translation_norm 的值过大，可能表示估计存在误差，需要反复优化算法。\n设置不同的阈值可以根据实际场景需求，判断平移量是否在允许的范围内。\n以上是从变换矩阵中提取和利用平移信息的简单示例，可以提供点云变换和姿态估计任务有用的辅助分析。\n","permalink":"https://blog.cassdev.com/posts/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%AC%94%E8%AE%B0%E4%BB%8E%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%8F%90%E5%8F%96%E5%B9%B6%E5%88%86%E6%9E%90%E5%B9%B3%E7%A7%BB%E9%87%8F/","summary":"\u003cp\u003e在编写点云变换和姿态估计代码时，我们经常需要从结果的变换矩阵中提取平移信息，并分析平移量的大小，帮助判断结果的准确性。\u003c/p\u003e\n\u003cp\u003e本文将介绍如何从变换矩阵中提取平移向量，并计算其欧几里得长度。\u003c/p\u003e\n\u003ch2 id=\"提取平移向量\"\u003e提取平移向量\u003c/h2\u003e\u003cp\u003e假设我们通过某种姿态估计算法得到了一个4x4的变换矩阵 result.transformation_ ,其中包含了旋转和平移信息。\u003c/p\u003e\n\u003cp\u003e我们可以通过以下代码提取出平移部分:（以Open3D为例）\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecore\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eTensor\u003c/span\u003e \u003cspan class=\"n\"\u003etranslation\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etransformation_\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSlice\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eSlice\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eSlice(0,0,3);\u003c/code\u003e表示从矩阵的第0维(行)，第0行开始，取3行，即前3行；\u003ccode\u003eSlice(1,3,4);\u003c/code\u003e表示从矩阵的第1维(列)，第3列开始，取1列，即第4列。\n最后获得一个3x1的平移向量，包含x、y、z三个方向的平移量。\u003c/p\u003e\n\u003ch2 id=\"计算欧几里得长度\"\u003e计算欧几里得长度\u003c/h2\u003e\u003cp\u003e有了平移向量后,我们可以计算其欧几里得长度,表示平移量的大小:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003etranslation_norm\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003esqrt\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003etranslation\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003etranslation\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eSum\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e}).\u003c/span\u003e\u003cspan class=\"n\"\u003eItem\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003estd::sqrt\u003c/code\u003e计算平方根，\u003ccode\u003etranslation * translation\u003c/code\u003e 计算向量每个元素的平方，\u003ccode\u003eSum\u003c/code\u003e 聚合，最终得到平移向量的L2范数，即\u003cstrong\u003e欧几里得长度\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"分析平移量\"\u003e分析平移量\u003c/h2\u003e\u003cp\u003e通过提取并计算平移向量的模长，我们可以分析相机或物体的移动距离，以及姿态估计结果的准确性。\u003c/p\u003e\n\u003cp\u003e如果 translation_norm 的值过大，可能表示估计存在误差，需要反复优化算法。\u003c/p\u003e\n\u003cp\u003e设置不同的阈值可以根据实际场景需求，判断平移量是否在允许的范围内。\u003c/p\u003e\n\u003cp\u003e以上是从变换矩阵中提取和利用平移信息的简单示例，可以提供点云变换和姿态估计任务有用的辅助分析。\u003c/p\u003e","title":"三维重建笔记——从变换矩阵中提取并分析平移量"},{"content":"起因是我放假回家，想在家里通过 SSH 连接放在学校的无显示器的 Linux，但是学校的 Linux 是内网，无法直接连接，且无显示器无法使用向日葵等远程桌面软件，所以想到了使用 frp 的反向代理功能实现内网穿透，进而实现异地 SSH 连接。\n前提 一台具有公网 IP 的服务器（阿里云、腾讯云等） 配置远程主机我们需要有三台主机，分别是：自己的电脑、远程 Linux 主机和具有公网 IP 的服务器。\n只需要在远程 Linux 和具有公网 IP 的服务器上配置 frp 即可。\n首先在远程 Linux 上下载 frp，Github 下载地址。下载远程主机对应的版本，我这里是 ARM64 架构的 Linux，所以下载 frp_0.51.2_linux_arm64.tar.gz。\n下载完毕后解压：\ntar -xvf frp_0.51.2_linux_arm64.tar.gz cd frp_0.51.2_linux_arm64 远程 Linux 为客户端，所以只需要保留 frpc* 文件即可，frps可以删除。\nrm frps* 修改frpc.ini，只需要将server_addr修改为服务器的 IP 地址即可，local_ip不变。server_port和remote_port一般不变，若与其他服务冲突了可以修改。\nvim frpc.ini\t#:wq 退出 配置服务器同样下载好对应系统版本的 frp，解压后删除frpc*文件。\nrm frpc* 修改frpc.ini，确保bind_port与 frpc 客户端，即远程主机的server_port一致。\n再前往阿里云或腾讯云官网配置服务器防火墙规则，开放服务器的 6000 和 7000 端口（若修改了则开放修改后的端口）。\n启动 frp先启动服务器的frps：\n./frps -c frps.ini 显示以下三行则代表启动成功：\n再启动远程主机的frpc：\n./frpc -c frpc.ini 连接远程主机启动成功后就可以尝试 SSH 连接远程 Linux 主机了：\nssh -p \u0026lt;server_port\u0026gt; \u0026lt;user\u0026gt;@\u0026lt;server_addr\u0026gt; 其中，\u0026lt;server_port\u0026gt;为上面frpc.ini里的server_port，\u0026lt;server_addr\u0026gt;为上面frpc.ini里的server_port，为远程 Linux 的用户名。\n","permalink":"https://blog.cassdev.com/posts/%E9%80%9A%E8%BF%87-frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%9C%B0-ssh-%E8%BF%9E%E6%8E%A5%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/","summary":"\u003cp\u003e起因是我放假回家，想在家里通过 SSH 连接放在学校的无显示器的 Linux，但是学校的 Linux 是内网，无法直接连接，且无显示器无法使用向日葵等远程桌面软件，所以想到了使用 frp 的反向代理功能实现内网穿透，进而实现异地 SSH 连接。\u003c/p\u003e\n\u003ch2 id=\"前提\"\u003e前提\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e一台具有公网 IP 的服务器（阿里云、腾讯云等）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"配置远程主机\"\u003e配置远程主机\u003c/h2\u003e\u003cp\u003e我们需要有三台主机，分别是：自己的电脑、远程 Linux 主机和具有公网 IP 的服务器。\u003c/p\u003e\n\u003cp\u003e只需要在远程 Linux 和具有公网 IP 的服务器上配置 frp 即可。\u003c/p\u003e\n\u003cp\u003e首先在远程 Linux 上下载 frp，\u003ca href=\"https://github.com/fatedier/frp/releases\"\u003eGithub 下载地址\u003c/a\u003e。下载远程主机对应的版本，我这里是 ARM64 架构的 Linux，所以下载 \u003ccode\u003efrp_0.51.2_linux_arm64.tar.gz\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"frp GitHub\" loading=\"lazy\" src=\"https://s2.loli.net/2023/08/01/P5MzmKDEeBjdJF3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e下载完毕后解压：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar -xvf frp_0.51.2_linux_arm64.tar.gz\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e frp_0.51.2_linux_arm64\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e远程 Linux 为客户端，所以只需要保留 \u003ccode\u003efrpc*\u003c/code\u003e 文件即可，\u003ccode\u003efrps\u003c/code\u003e可以删除。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003erm frps*\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e修改\u003ccode\u003efrpc.ini\u003c/code\u003e，只需要将\u003ccode\u003eserver_addr\u003c/code\u003e修改为服务器的 IP 地址即可，\u003ccode\u003elocal_ip\u003c/code\u003e不变。\u003ccode\u003eserver_port\u003c/code\u003e和\u003ccode\u003eremote_port\u003c/code\u003e一般不变，若与其他服务冲突了可以修改。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003evim frpc.ini\t\u003cspan class=\"c1\"\u003e#:wq 退出\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg alt=\"vim frpc.ini\" loading=\"lazy\" src=\"https://s2.loli.net/2023/08/01/r6dks5YSEm9WUXl.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"配置服务器\"\u003e配置服务器\u003c/h2\u003e\u003cp\u003e同样下载好对应系统版本的 frp，解压后删除\u003ccode\u003efrpc*\u003c/code\u003e文件。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003erm frpc*\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e修改\u003ccode\u003efrpc.ini\u003c/code\u003e，确保\u003ccode\u003ebind_port\u003c/code\u003e与 frpc 客户端，即远程主机的\u003ccode\u003eserver_port\u003c/code\u003e一致。\u003c/p\u003e\n\u003cp\u003e再前往阿里云或腾讯云官网配置服务器防火墙规则，开放服务器的 6000 和 7000 端口（若修改了则开放修改后的端口）。\u003c/p\u003e","title":"通过 frp 内网穿透实现异地 SSH 连接（反向代理）"},{"content":"Copy\u0026amp;Swap 是什么Copy\u0026amp;Swap 是一种 C++ 中常用的编程技巧，用于实现类的赋值运算符（operator=）。\n实现传统写法先看看未使用 Copy\u0026amp;Swap 的赋值运算符写法：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; class OldAClass { private: int _count; std::string _str; std::vector\u0026lt;int\u0026gt; _vec; public: OldAClass() : _count(0), _vec(10) {} // 拷贝构造函数 和 拷贝赋值运算符 OldAClass(OldAClass \u0026amp;a) : _count(a._count), _str(a._str), _vec(a._vec) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy constructor called\\n\u0026#34;; } OldAClass \u0026amp;operator=(OldAClass \u0026amp;a) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy Assignment operator called\\n\u0026#34;; if (this != \u0026amp;a) { //判断传入的 a 是否是自己 _count = a._count; _str = a._str; _vec = a._vec; } return *this; } // 移动构造函数 和 移动赋值运算符 OldAClass(OldAClass \u0026amp;\u0026amp;a) noexcept : _count(a._count), _str(std::move(a._str)), _vec(std::move(a._vec)) { std::cout \u0026lt;\u0026lt; \u0026#34;Move constructor called\\n\u0026#34;; } OldAClass \u0026amp;operator=(OldAClass \u0026amp;\u0026amp;a) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;Move Assignment operator called\\n\u0026#34;; if (this != \u0026amp;a) { _count = a._count; _str = std::move(a._str); _vec = std::move(a._vec); } return *this; } }; 可以看到，这种写法需要重复写两次赋值运算符，并且每次都需要判断传入的参数是否是自己，而且代码重复度高。\nCopy\u0026amp;Swap 写法class AClass { private: int _count; std::string _str; std::vector\u0026lt;int\u0026gt; _vec; public: AClass() : _count(0), _vec(10) {} static void swap(AClass \u0026amp;a, AClass \u0026amp;b) { std::swap(a._count, b._count); std::swap(a._str, b._str); std::swap(a._vec, b._vec); } // 拷贝构造函数 AClass(AClass \u0026amp;a) : _count(a._count), _str(a._str), _vec(a._vec) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy constructor called\\n\u0026#34;; } // 移动构造函数 AClass(AClass \u0026amp;\u0026amp;a) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;Move constructor called\\n\u0026#34;; swap(*this, a); } // 赋值运算符 AClass \u0026amp;operator=(AClass a) { // 注意这里的参数是值传递，会调用拷贝构造函数 std::cout \u0026lt;\u0026lt; \u0026#34;Assignment operator called\\n\u0026#34;; swap(*this, a); return *this; } }; 这种写法只需要写一次赋值运算符，代码更简洁，而且不需要判断传入的参数是否是自己。\n至于为什么要这样写，我们先看看拷贝赋值运算符和移动赋值运算符的本质，他们都是为了将自己的值改变为另一个对象的值。区别只在于是否保留原对象的值。\n拷贝赋值运算符（copy）：修改自己的值为另一个对象的值，但是保留原对象的值。 移动赋值运算符（move）：修改自己的值为另一个对象的值，不保留原对象的值，或者不关心原对象的值。 对于移动赋值运算符，由于传进来的是一个右值引用，也就是一个将亡值，所以我们可以直接使用 swap 函数，交换他们的值。\n那么对于拷贝赋值运算符是否也可以用 swap 函数呢？如果直接修改函数实现当然是不可以的，因为拷贝赋值运算符传入的是一个引用类型的参数，如果直接交换，那么会导致原对象被修改。所以我们可以将参数改为值传递，先调用拷贝构造器生成一个临时对象，然后再调用 swap 函数，这样就可以实现拷贝赋值运算符的功能。\n更好的 swap 函数定义class BetterAClass { private: int _count; std::string _str; std::vector\u0026lt;int\u0026gt; _vec; public: BetterAClass() : _count(0), _vec(10) { std::cout \u0026lt;\u0026lt; \u0026#34;Default constructor called\\n\u0026#34;; _str = \u0026#34;Hello\u0026#34;; _vec.assign(10, 1); } friend void swap(BetterAClass \u0026amp;a, BetterAClass \u0026amp;b) { //定义成友元是为了访问私有成员 using std::swap; //开启 ADL （Argument-Dependent Lookup 参数依赖查找） swap(a._count, b._count); swap(a._str, b._str); swap(a._vec, b._vec); } BetterAClass(const BetterAClass \u0026amp;a) : _count(a._count), _str(a._str), _vec(a._vec) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy constructor called\\n\u0026#34;; } BetterAClass(BetterAClass \u0026amp;\u0026amp;a) noexcept { using std::swap; std::cout \u0026lt;\u0026lt; \u0026#34;Move constructor called\\n\u0026#34;; swap(*this, a); } BetterAClass \u0026amp;operator=(BetterAClass a) { using std::swap; std::cout \u0026lt;\u0026lt; \u0026#34;Assignment operator called\\n\u0026#34;; swap(*this, a); return *this; } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const BetterAClass \u0026amp;a) { os \u0026lt;\u0026lt; \u0026#34;AClass: count = \u0026#34; \u0026lt;\u0026lt; a._count \u0026lt;\u0026lt; \u0026#34;, str = \u0026#34; \u0026lt;\u0026lt; a._str \u0026lt;\u0026lt; \u0026#34;, vec size = \u0026#34; \u0026lt;\u0026lt; a._vec.size(); return os; } }; class TestClass { public: AClass a; BetterAClass ba; TestClass() = default; friend void swap(TestClass \u0026amp;a, TestClass \u0026amp;b) { AClass::swap(a.a, b.a); using std::swap; // 开启 ADL，保证 std::swap 被调用 swap(a.ba, b.ba); } }; 如果我们的类需要被其他类作为成员变量，那么我们的 swap 函数就需要调用这些类的 swap 函数，如果按照原来的写法调用静态成员函数，如果不想多写 AClass::，那么就需要将 swap 函数定义为普通函数，但是普通函数并不能访问类的私有成员，所以我们需要将 swap 函数定义为友元函数。\n并且这样做有一个额外的好处，我们可以开启 ADL（Argument-Dependent Lookup 参数依赖查找），这样我们就可以直接调用 swap 函数，无论传入的是什么类型，都会调用对应的最匹配的 swap 函数。如果找不到对应的 swap 函数，那么就会调用 std::swap 函数。\n参考 [C++] 经典的 Copy \u0026amp; Swap（视频）\n[C++] Copy \u0026amp; Swap 续：更好的 swap 定义（视频）\n","permalink":"https://blog.cassdev.com/posts/c++-copyswap-%E6%83%AF%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97/","summary":"\u003ch2 id=\"copyswap-是什么\"\u003eCopy\u0026amp;Swap 是什么\u003c/h2\u003e\u003cp\u003eCopy\u0026amp;Swap 是一种 C++ 中常用的编程技巧，用于实现类的赋值运算符（\u003ccode\u003eoperator=\u003c/code\u003e）。\u003c/p\u003e\n\u003ch2 id=\"实现\"\u003e实现\u003c/h2\u003e\u003ch3 id=\"传统写法\"\u003e传统写法\u003c/h3\u003e\u003cp\u003e先看看未使用 Copy\u0026amp;Swap 的赋值运算符写法：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eOldAClass\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eOldAClass\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 拷贝构造函数 和 拷贝赋值运算符\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003eOldAClass\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eOldAClass\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Copy constructor called\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eOldAClass\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eOldAClass\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Copy Assignment operator called\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"c1\"\u003e//判断传入的 a 是否是自己\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"n\"\u003e_count\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003e_str\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003e_vec\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 移动构造函数 和 移动赋值运算符\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003eOldAClass\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eOldAClass\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003enoexcept\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003emove\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e)),\u003c/span\u003e \u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003emove\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Move constructor called\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eOldAClass\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eOldAClass\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003enoexcept\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Move Assignment operator called\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003e_count\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003e_str\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003emove\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003e_vec\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003emove\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e可以看到，这种写法需要重复写两次赋值运算符，并且每次都需要判断传入的参数是否是自己，而且代码重复度高。\u003c/p\u003e\n\u003ch3 id=\"copyswap-写法\"\u003eCopy\u0026amp;Swap 写法\u003c/h3\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eAClass\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eAClass\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eswap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eAClass\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eAClass\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eswap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eswap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eswap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 拷贝构造函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003eAClass\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eAClass\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_count\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_str\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Copy constructor called\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 移动构造函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003eAClass\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eAClass\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003enoexcept\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Move constructor called\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eswap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 赋值运算符\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003eAClass\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eAClass\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 注意这里的参数是值传递，会调用拷贝构造函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Assignment operator called\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eswap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这种写法只需要写一次赋值运算符，代码更简洁，而且不需要判断传入的参数是否是自己。\u003c/p\u003e","title":"C++ Copy\u0026Swap 惯用法指南"},{"content":"简介本文旨在帮助用户在 Jetson 上的 Ubuntu Arm64 系统上安装 Bazel。Bazel 是一个开源的构建工具，它专注于构建和测试大型软件项目，并且被广泛应用于机器学习和深度学习领域。通过使用 Bazel，您可以更高效地管理和构建您的项目。\n步骤 1：安装OpenJDK在开始安装 Bazel 之前，我们需要安装 OpenJDK。在终端中执行以下命令：\nsudo add-apt-repository ppa:webupd8team/java sudo apt-get update sudo apt-get install openjdk-11-jdk 步骤 2：下载 Bazel 安装包在安装 OpenJDK 之后，我们需要下载 Bazel 的安装包。在终端中执行以下命令：\nwget https://github.com/bazelbuild/bazel/releases/download/6.2.1/bazel-6.2.1-dist.zip 或者，您也可以从 Bazel 的 Github 仓库下载最新版本的安装包。（必须下载dist.zip文件）\n步骤 3：安装 Bazel下载完成后，我们可以使用以下命令来安装 Bazel：\nunzip bazel-6.2.1-dist.zip -d bazel-6.2.1 bash./compile.sh sudo cp output/bazel /usr/local/bin 步骤 4：验证安装安装完成后，我们可以验证 Bazel 是否成功安装。在终端中执行以下命令：\nbazel version 如果一切正常，您应该能够看到如下输出： ","permalink":"https://blog.cassdev.com/posts/jetson-ubuntu-arm64-%E5%AE%89%E8%A3%85-bazel/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\u003cp\u003e本文旨在帮助用户在 Jetson 上的 Ubuntu Arm64 系统上安装 Bazel。Bazel 是一个开源的构建工具，它专注于构建和测试大型软件项目，并且被广泛应用于机器学习和深度学习领域。通过使用 Bazel，您可以更高效地管理和构建您的项目。\u003c/p\u003e\n\u003ch2 id=\"步骤-1安装openjdk\"\u003e步骤 1：安装OpenJDK\u003c/h2\u003e\u003cp\u003e在开始安装 Bazel 之前，我们需要安装 OpenJDK。在终端中执行以下命令：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo add-apt-repository ppa:webupd8team/java\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get update\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install openjdk-11-jdk\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"步骤-2下载-bazel-安装包\"\u003e步骤 2：下载 Bazel 安装包\u003c/h2\u003e\u003cp\u003e在安装 OpenJDK 之后，我们需要下载 Bazel 的安装包。在终端中执行以下命令：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewget https://github.com/bazelbuild/bazel/releases/download/6.2.1/bazel-6.2.1-dist.zip\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e或者，您也可以从\u003ca href=\"https://github.com/bazelbuild/bazel/releases\"\u003e Bazel 的 Github 仓库\u003c/a\u003e下载最新版本的安装包。（必须下载dist.zip文件）\u003c/p\u003e\n\u003ch2 id=\"步骤-3安装-bazel\"\u003e步骤 3：安装 Bazel\u003c/h2\u003e\u003cp\u003e下载完成后，我们可以使用以下命令来安装 Bazel：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eunzip bazel-6.2.1-dist.zip -d bazel-6.2.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ebash./compile.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo cp output/bazel /usr/local/bin\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"步骤-4验证安装\"\u003e步骤 4：验证安装\u003c/h2\u003e\u003cp\u003e安装完成后，我们可以验证 Bazel 是否成功安装。在终端中执行以下命令：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ebazel version\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果一切正常，您应该能够看到如下输出：\n\u003cimg alt=\"bazel version\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/14/emMDIGbSiWsKgo9.png\"\u003e\u003c/p\u003e","title":"Jetson (Ubuntu Arm64) 安装 Bazel"},{"content":"Protobuf（Protocol Buffers）是一种轻量级的数据交换格式，常用于高效地序列化结构化数据。本指南将介绍如何在 Ubuntu 上安装 Protobuf。\n步骤 1：更新系统在安装 Protobuf 之前，我们首先需要确保系统已经更新到最新版本。打开终端并执行以下命令：\nsudo apt update sudo apt upgrade 这将更新系统的软件包并安装最新的安全补丁。\n步骤 2：安装编译工具和依赖项在安装 Protobuf 之前，我们需要安装一些编译工具和依赖项。执行以下命令来安装它们：\nsudo apt install build-essential autoconf libtool 这些工具和依赖项将帮助我们编译和构建 Protobuf。\n步骤 3：下载和编译 Protobuf 首先，我们需要下载 Protobuf 的源代码。这里选择下载v3.20.3版本的Protobuf源码压缩包。（必须下载-all压缩包）\n解压压缩包\ntar -zxvf protobuf-all-3.20.3.tar.gz 这将克隆 Protobuf 的源代码到当前目录。\n进入克隆下来的 Protobuf 目录： cd protobuf-all-3.20.3 在源代码目录中，运行以下命令来生成配置文件和构建系统： ./autogen.sh 接下来，我们需要运行 configure 脚本来配置编译选项。可以使用以下命令进行配置： ./configure 配置完成后，我们可以使用以下命令编译和安装 Protobuf： sudo make sudo make check #这一步可能会报错，解决方法见下文 sudo make install sudo ldconfig 编译过程可能需要一些时间，请耐心等待。\n步骤 4：验证安装安装完成后，我们可以验证 Protobuf 是否成功安装。执行以下命令来检查 Protobuf 的版本信息：\nprotoc --version 如果安装成功，将显示 Protobuf 的版本号。\n解决 make check 报错在执行 make check 时，可能会报错，错误信息如下：\nFAIL: protobuf-test PASS: protobuf-lazy-descriptor-test PASS: protobuf-lite-test PASS: google/protobuf/compiler/zip_output_unittest.sh PASS: google/protobuf/io/gzip_stream_unittest.sh PASS: protobuf-lite-arena-test PASS: no-warning-test ============================================================================ Testsuite summary for Protocol Buffers 3.19.4 ============================================================================ # TOTAL: 7 # PASS: 6 # SKIP: 0 # XFAIL: 0 # FAIL: 1 # XPASS: 0 # ERROR: 0 ============================================================================ See src/test-suite.log Please report to protobuf@googlegroups.com ============================================================================ protobuf-test 测试不通过，这个错误是因为加载大型数据集时内存溢出导致的。\n解决方法是加大可用内存或增加内存 Swap 分区，这里以 Jetson Xavier NX 增加内存 Swap 分区为例，此前请先确保已经安装 Jtop 工具：\nsudo jtop 先切换到4号内存面板，接着点击右边的 Create new 按钮，点击三次，创建三个内存 Swap 分区即可。\n最后按Q退出 Jtop 工具。\n重新执行 make check 即可。\n","permalink":"https://blog.cassdev.com/posts/ubuntu-%E5%AE%89%E8%A3%85-protobuf/","summary":"\u003cp\u003eProtobuf（Protocol Buffers）是一种轻量级的数据交换格式，常用于高效地序列化结构化数据。本指南将介绍如何在 Ubuntu 上安装 Protobuf。\u003c/p\u003e\n\u003ch2 id=\"步骤-1更新系统\"\u003e步骤 1：更新系统\u003c/h2\u003e\u003cp\u003e在安装 Protobuf 之前，我们首先需要确保系统已经更新到最新版本。打开终端并执行以下命令：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt upgrade\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这将更新系统的软件包并安装最新的安全补丁。\u003c/p\u003e\n\u003ch2 id=\"步骤-2安装编译工具和依赖项\"\u003e步骤 2：安装编译工具和依赖项\u003c/h2\u003e\u003cp\u003e在安装 Protobuf 之前，我们需要安装一些编译工具和依赖项。执行以下命令来安装它们：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install build-essential autoconf libtool\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这些工具和依赖项将帮助我们编译和构建 Protobuf。\u003c/p\u003e\n\u003ch2 id=\"步骤-3下载和编译-protobuf\"\u003e步骤 3：下载和编译 Protobuf\u003c/h2\u003e\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e首先，我们需要下载 Protobuf 的源代码。这里选择下载\u003ca href=\"https://github.com/protocolbuffers/protobuf/releases/tag/v3.20.3\"\u003ev3.20.3版本的Protobuf源码压缩包\u003c/a\u003e。（必须下载-all压缩包）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e解压压缩包\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar -zxvf protobuf-all-3.20.3.tar.gz\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这将克隆 Protobuf 的源代码到当前目录。\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e进入克隆下来的 Protobuf 目录：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e protobuf-all-3.20.3\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"4\"\u003e\n\u003cli\u003e在源代码目录中，运行以下命令来生成配置文件和构建系统：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e./autogen.sh\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"5\"\u003e\n\u003cli\u003e接下来，我们需要运行 \u003ccode\u003econfigure\u003c/code\u003e 脚本来配置编译选项。可以使用以下命令进行配置：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e./configure\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"6\"\u003e\n\u003cli\u003e配置完成后，我们可以使用以下命令编译和安装 Protobuf：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo make\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo make check \u003cspan class=\"c1\"\u003e#这一步可能会报错，解决方法见下文\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo make install\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ldconfig\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e编译过程可能需要一些时间，请耐心等待。\u003c/p\u003e\n\u003ch2 id=\"步骤-4验证安装\"\u003e步骤 4：验证安装\u003c/h2\u003e\u003cp\u003e安装完成后，我们可以验证 Protobuf 是否成功安装。执行以下命令来检查 Protobuf 的版本信息：\u003c/p\u003e","title":"Ubuntu 安装 Protobuf 指南"},{"content":"当你的 Open3D 项目同时使用了 OpenCV 或 Protobuf 等其他库时，在链接库时可能会出现 Undefined Reference 的错误。这是因为 Open3D 默认使用的 C++ ABI 版本与其他库不一致导致的。\n为了解决这个问题，可以在重新编译安装 Open3D 时打开 -DGLIBCXX_USE_CXX11_ABI=ON 选项，即使用 C++11 ABI 版本。以下是具体的步骤：\n解决方法找到 Open3D 源码cd open3d 找不到请在 Github 上重新下载。\n重新编译安装 Open3D进入 Open3D 的源代码目录的 build 子目录进行编译安装。\ncd build 在 build 子目录中执行 CMake 命令生成 Makefile。在命令行中添加 -DGLIBCXX_USE_CXX11_ABI=ON 选项。\ncmake .. -DBUILD_SHARED_LIBS=ON -DGLIBCXX_USE_CXX11_ABI=ON -DCMAKE_BUILD_TYPE=Release 最后，执行 make 命令编译并安装 Open3D。\nmake -j6 sudo make install 使用 Open3D重新编译安装后的 Open3D 就能够正常链接其他库了。\n","permalink":"https://blog.cassdev.com/posts/%E8%A7%A3%E5%86%B3-open3d-%E5%90%8C%E6%97%B6%E9%93%BE%E6%8E%A5%E5%85%B6%E4%BB%96%E5%BA%93%E6%97%B6%E7%9A%84-undefined-reference-%E9%94%99%E8%AF%AF/","summary":"\u003cp\u003e当你的 Open3D 项目同时使用了 OpenCV 或 Protobuf 等其他库时，在链接库时可能会出现 Undefined Reference 的错误。这是因为 Open3D 默认使用的 C++ ABI 版本与其他库不一致导致的。\u003c/p\u003e\n\u003cp\u003e为了解决这个问题，可以在重新编译安装 Open3D 时打开 \u003ccode\u003e-DGLIBCXX_USE_CXX11_ABI=ON\u003c/code\u003e 选项，即使用 C++11 ABI 版本。以下是具体的步骤：\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\u003ch3 id=\"找到-open3d-源码\"\u003e找到 Open3D 源码\u003c/h3\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e open3d\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e找不到请在 Github 上重新下载。\u003c/p\u003e\n\u003ch3 id=\"重新编译安装-open3d\"\u003e重新编译安装 Open3D\u003c/h3\u003e\u003cp\u003e进入 Open3D 的源代码目录的 \u003ccode\u003ebuild\u003c/code\u003e 子目录进行编译安装。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e build\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003ebuild\u003c/code\u003e 子目录中执行 CMake 命令生成 Makefile。\u003cstrong\u003e在命令行中添加 \u003ccode\u003e-DGLIBCXX_USE_CXX11_ABI=ON\u003c/code\u003e 选项。\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecmake .. -DBUILD_SHARED_LIBS\u003cspan class=\"o\"\u003e=\u003c/span\u003eON -DGLIBCXX_USE_CXX11_ABI\u003cspan class=\"o\"\u003e=\u003c/span\u003eON -DCMAKE_BUILD_TYPE\u003cspan class=\"o\"\u003e=\u003c/span\u003eRelease\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e最后，执行 \u003ccode\u003emake\u003c/code\u003e 命令编译并安装 Open3D。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emake -j6\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo make install\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"使用-open3d\"\u003e使用 Open3D\u003c/h3\u003e\u003cp\u003e重新编译安装后的 Open3D 就能够正常链接其他库了。\u003c/p\u003e","title":"解决 Open3D 同时链接其他库时的 Undefined Reference 错误"},{"content":"本文旨在教大家如何在 Unity 中使用 NuGet 安装解决方案包。\nVisual Studio 集成了 NuGet 管理器，可以方便的安装和卸载解决方案包。但在使用 Viusal Studio 开发 Unity C# 脚本时，不能直接在内置的 NuGet 管理器安装解决方案包。因为 Unity 工程打开或运行时会刷新工程文件，导致我们在 Visual Studio 内置 NuGet 管理器安装的解决方案包失效。所以 Unity 使用 NuGet 安装解决方案包需要特殊步骤。\n步骤下载解决方案包在NuGet官网下载你需要解决方案包，例如Google.Protobuf。\n直接下载会下载最新预览版，稳定版需要点击右上角的 Full stats，查看所有版本。\n找到稳定版 3.22.4，点击即可下载。\n解压包下载后会得到拓展名为.nupkg的文件，先将文件拓展名改为.zip，接着解压即可。\n导入dll文件解压后可以得到 dll 文件，位于 google.protobuf.3.22.4/lib/**/Google.Protobuf.dll ，将dll文件复制到 Unity 工程文件夹的 Assets/Plugins 文件夹下，若没有这个文件夹自己手动新建一个。\n配置Unity项目接着需要将 Unity 项目的 Api Compatibility Level 更改为与 dll 文件对应的版本。打开 Unity 的 Project Settings，找到 Player \u0026gt; Other Settings \u0026gt; Api Compatibility Level。\n重启 Unity 项目如果 Unity 报错提示刚刚导入的解决方案包 unsafe 的话，重启 Unity 项目即可。\n这样就愉快的可以在 Unity C# 脚本中使用刚刚导入的解决方案包啦。\n","permalink":"https://blog.cassdev.com/posts/unity-%E4%BD%BF%E7%94%A8-nuget-%E5%AE%89%E8%A3%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%8C%85/","summary":"\u003cp\u003e本文旨在教大家如何在 Unity 中使用 NuGet 安装解决方案包。\u003c/p\u003e\n\u003cp\u003eVisual Studio 集成了 NuGet 管理器，可以方便的安装和卸载解决方案包。但在使用 Viusal Studio 开发 Unity C# 脚本时，不能直接在内置的 NuGet 管理器安装解决方案包。因为 Unity 工程打开或运行时会刷新工程文件，导致我们在 Visual Studio 内置 NuGet 管理器安装的解决方案包失效。所以 Unity 使用 NuGet 安装解决方案包需要特殊步骤。\u003c/p\u003e\n\u003ch2 id=\"步骤\"\u003e步骤\u003c/h2\u003e\u003ch3 id=\"下载解决方案包\"\u003e下载解决方案包\u003c/h3\u003e\u003cp\u003e在\u003ca href=\"https://www.nuget.org/\"\u003eNuGet官网\u003c/a\u003e下载你需要解决方案包，例如Google.Protobuf。\u003c/p\u003e\n\u003cp\u003e直接下载会下载最新预览版，稳定版需要点击右上角的 Full stats，查看所有版本。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Full stats\" loading=\"lazy\" src=\"https://s2.loli.net/2023/05/08/1mRe8FJbMDO3q2i.png\"\u003e\u003c/p\u003e\n\u003cp\u003e找到稳定版 3.22.4，点击即可下载。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Protobuf 3.22.4\" loading=\"lazy\" src=\"https://s2.loli.net/2023/05/08/S8LCYDNglpVZbP7.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"解压包\"\u003e解压包\u003c/h3\u003e\u003cp\u003e下载后会得到拓展名为\u003ccode\u003e.nupkg\u003c/code\u003e的文件，先将文件拓展名改为\u003ccode\u003e.zip\u003c/code\u003e，接着解压即可。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Unzip\" loading=\"lazy\" src=\"https://s2.loli.net/2023/05/08/RvoI35FghtaudVO.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"导入dll文件\"\u003e导入dll文件\u003c/h3\u003e\u003cp\u003e解压后可以得到 dll 文件，位于 google.protobuf.3.22.4/lib/**/Google.Protobuf.dll ，将dll文件复制到 Unity 工程文件夹的 Assets/Plugins 文件夹下，若没有这个文件夹自己手动新建一个。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Google.Protobuf.dll\" loading=\"lazy\" src=\"https://s2.loli.net/2023/05/08/LXITjqHRUPaVSvK.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"配置unity项目\"\u003e配置Unity项目\u003c/h3\u003e\u003cp\u003e接着需要将 Unity 项目的 Api Compatibility Level 更改为与 dll 文件对应的版本。打开 Unity 的 Project Settings，找到 Player \u0026gt; Other Settings \u0026gt; Api Compatibility Level。\u003c/p\u003e","title":"Unity 脚本使用 NuGet 安装解决方案包"},{"content":"\n这是一个你的项目应该遵循的垃圾代码书写准则的列表，把称为适当的垃圾代码。\n来自GitHub开源项目State-of-the-art。\n准则💩 以一种代码已经被混淆的方式命名变量如果我们键入的东西越少，那么就有越多的时间去思考代码逻辑等问题。\nGood 👍🏻\nlet a = 42; Bad 👎🏻\nlet age = 42; 💩 多用拼音命名变量和函数写拼音多方便，我们要推崇。\nGood 👍🏻\nfunction hqtpgd(tp) { //获取图片高度 return tp.height; //图片 } Bad 👎🏻\nfunction getImageHeight(image) { return image.height; } 💩 变量/函数混合命名风格为不同庆祝一下。\nGood 👍🏻\nlet wWidth = 640; let w_height = 480; Bad 👎🏻\nlet windowWidth = 640; let windowHeight = 480; 💩 不要写注释反正没人会读你的代码。\nGood 👍🏻\nconst cdr = 700; Bad 👎🏻\n更多时候，评论应该包含一些“为什么”，而不是一些“是什么”。如果“什么”在代码中不清楚，那么代码可能太混乱了。\n// 700ms的数量是根据UX A/B测试结果进行经验计算的。 // @查看: \u0026lt;详细解释700的一个链接\u0026gt; const callbackDebounceRate = 700; 💩 使用母语写注释如果您违反了“无注释”原则，那么至少尝试用一种不同于您用来编写代码的语言来编写注释。如果你的母语是英语，你可能会违反这个原则。\nGood 👍🏻\n// Закриваємо модальне віконечко при виникненні помилки. toggleModal(false); Bad 👎🏻\n// 隐藏错误弹窗 toggleModal(false); 💩 尽可能混合不同的格式为不同庆祝一下。\nGood 👍🏻\nlet i = [\u0026#39;tomato\u0026#39;, \u0026#39;onion\u0026#39;, \u0026#39;mushrooms\u0026#39;]; let d = [ \u0026#34;ketchup\u0026#34;, \u0026#34;mayonnaise\u0026#34; ]; Bad 👎🏻\nlet ingredients = [\u0026#39;tomato\u0026#39;, \u0026#39;onion\u0026#39;, \u0026#39;mushrooms\u0026#39;]; let dressings = [\u0026#39;ketchup\u0026#39;, \u0026#39;mayonnaise\u0026#39;]; 💩 尽可能把代码写成一行Good 👍🏻\ndocument.location.search.replace(/(^\\?)/,\u0026#39;\u0026#39;).split(\u0026#39;\u0026amp;\u0026#39;).reduce(function(o,n){n=n.split(\u0026#39;=\u0026#39;);o[n[0]]=n[1];return o},{}) Bad 👎🏻\ndocument.location.search .replace(/(^\\?)/, \u0026#39;\u0026#39;) .split(\u0026#39;\u0026amp;\u0026#39;) .reduce((searchParams, keyValuePair) =\u0026gt; { keyValuePair = keyValuePair.split(\u0026#39;=\u0026#39;); searchParams[keyValuePair[0]] = keyValuePair[1]; return searchParams; }, {} ) 💩 不要处理特殊情况不理代码中的特殊情况，直接把大象塞进冰箱，任其崩溃。\nGood 👍🏻\nfunction divide(x, y) { return x / y; } console.log(divide(10, 2)); console.log(divide(10, 0)); // 整个代码都会崩溃 Bad 👎🏻\nfunction divide(x, y) { if (y === 0) { console.error(\u0026#34;除数不能为0\u0026#34;); return null; } return x / y; } console.log(divide(10, 2)); console.log(divide(10, 0)); 💩 捕获到错误也不管无论何时发现错误，都没有必要让任何人知道它。没有日志，没有错误弹框。\nGood 👍🏻\ntry { // 意料之外的情况。 } catch (error) { // 嘘... 🤫 } Bad 👎🏻\ntry { // 意料之外的情况。 } catch (error) { setErrorMessage(error.message); // and/or logError(error); } 💩 反模块化准则为什么要使用模块系统来组织您的代码呢？所有的函数和变量都可以在全局范围内定义。\nGood 👍🏻\nlet username = \u0026#34;John Doe\u0026#34;; function greet() { console.log(`Hello, ${username}!`); } greet(); Bad 👎🏻\n// main.js import { username } from \u0026#39;./user.js\u0026#39;; import { greet } from \u0026#39;./greeting.js\u0026#39;; greet(username); // user.js export const username = \u0026#39;John Doe\u0026#39;; // greeting.js export function greet(username) { console.log(`Hello, ${username}!`); } 💩 广泛使用全局变量全球化的原则。多方便啊全局变量，想用就用。\nGood 👍🏻\nlet x = 5; function square() { x = x ** 2; } square(); // 现在x是25 Bad 👎🏻\nlet x = 5; function square(num) { return num ** 2; } x = square(x); // 现在x是25 💩 创建你不会使用的变量以防万一。\nGood 👍🏻\nfunction sum(a, b, c) { const timeout = 1300; const result = a + b; return a + b; } Bad 👎🏻\nfunction sum(a, b) { return a + b; } 💩 如果语言允许，不要指定类型和/或不执行类型检查。Good 👍🏻\nfunction sum(a, b) { return a + b; } // 在这里享受没有注释的快乐 const guessWhat = sum([], {}); // -\u0026gt; \u0026#34;[object Object]\u0026#34; const guessWhatAgain = sum({}, []); // -\u0026gt; 0 Bad 👎🏻\nfunction sum(a: number, b: number): ?number { // 当我们在JS中不做置换和/或流类型检查时，覆盖这种情况。 if (typeof a !== \u0026#39;number\u0026#39; \u0026amp;\u0026amp; typeof b !== \u0026#39;number\u0026#39;) { return undefined; } return a + b; } // 这个应该在转换/编译期间失败。 const guessWhat = sum([], {}); // -\u0026gt; undefined 💩 你应该有不能到达的代码这是你的 \u0026ldquo;Plan B\u0026rdquo;.\nGood 👍🏻\nfunction square(num) { if (typeof num === \u0026#39;undefined\u0026#39;) { return undefined; } else { return num ** 2; } return null; // 这就是我的\u0026#34;Plan B\u0026#34;. } Bad 👎🏻\nfunction square(num) { if (typeof num === \u0026#39;undefined\u0026#39;) { return undefined; } return num ** 2; } 💩 三角法则就像鸟巢，鸟巢，鸟巢。\nGood 👍🏻\nfunction someFunction() { if (condition1) { if (condition2) { asyncFunction(params, (result) =\u0026gt; { if (result) { for (;;) { if (condition3) { } } } }) } } } Bad 👎🏻\nasync function someFunction() { if (!condition1 || !condition2) { return; } const result = await asyncFunction(params); if (!result) { return; } for (;;) { if (condition3) { } } } 💩 不要使用空格或缩进这样可以省略不必要的字符，少敲几下键盘，早点下班。\nGood 👍🏻\nlet x=5; if(x===5){ console.log(\u0026#34;x is 5\u0026#34;); } Bad 👍🏻\nlet x = 5; if (x === 5) { console.log(\u0026#34;x is 5\u0026#34;); } 💩 混合缩进避免缩进，因为它们会使复杂的代码在编辑器中占用更多的空间。如果你不喜欢回避他们，那就和他们捣乱。\nGood 👍🏻\nconst fruits = [\u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;pineapple\u0026#39;]; const toppings = [\u0026#39;syrup\u0026#39;, \u0026#39;cream\u0026#39;, \u0026#39;jam\u0026#39;, \u0026#39;chocolate\u0026#39;]; const desserts = []; fruits.forEach(fruit =\u0026gt; { toppings.forEach(topping =\u0026gt; { desserts.push([ fruit,topping]); });}) Bad 👎🏻\nconst fruits = [\u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;pineapple\u0026#39;]; const toppings = [\u0026#39;syrup\u0026#39;, \u0026#39;cream\u0026#39;, \u0026#39;jam\u0026#39;, \u0026#39;chocolate\u0026#39;]; const desserts = []; fruits.forEach(fruit =\u0026gt; { toppings.forEach(topping =\u0026gt; { desserts.push([fruit, topping]); }); }) 💩 避免代码风格统一编写您想要的代码，特别是在一个团队中有多个开发人员的情况下。这是“自由”原则。\nGood 👍🏻\n// A哥写的 function greet() { var str = \u0026#34;Hello!\u0026#34;; console.log(str); } // B哥写的 function sayHi(){ let str = \u0026#34;Hi!\u0026#34;; console.log(str); } Bad 👎🏻\n// A哥写的 function greet(){ let str = \u0026#34;Hello!\u0026#34;; console.log(str); } // B哥写的 function sayHi(){ let str = \u0026#34;Hi!\u0026#34;; console.log(str); } 💩 不要锁住你的依赖项以非受控方式更新每个新安装的依赖项。为什么坚持使用过去的版本，让我们使用最先进的库版本。更新就对了。\nGood 👍🏻\n$ ls -la package.json Bad 👎🏻\n$ ls -la package.json package-lock.json 💩 函数长的比短的好不要把程序逻辑分成可读的部分。如果IDE的搜索停止，而您无法找到所需的文件或函数，该怎么办?\n一个文件中10000行代码是OK的。 一个函数体有1000行代码是OK的。 在一个\u0026rsquo; service.js \u0026rsquo; 中处理许多服务(第三方库和内部库、一些工具、手写的数据库ORM和jQuery滑块)? 这是OK的。 💩 不要测试你的代码这是重复且不需要的工作。感觉它能运行它就能运行。\n💩 构建新项目不需要 README 文档一开始我们就应该保持。\n💩 保存不必要的代码不要删除不用的代码，最多注释掉。\n","permalink":"https://blog.cassdev.com/posts/%E5%9E%83%E5%9C%BE%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99%E5%87%86%E5%88%99/","summary":"\u003cp\u003e\u003ca href=\"https://github.com/trekhleb/state-of-the-art-shitcode\"\u003e\u003cimg alt=\"State-of-the-art Shitcode\" loading=\"lazy\" src=\"https://img.shields.io/static/v1?label=State-of-the-art\u0026message=Shitcode\u0026color=7B5804\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e这是一个你的项目应该遵循的垃圾代码书写准则的列表，把称为适当的垃圾代码。\u003c/p\u003e\n\u003cp\u003e来自GitHub开源项目\u003ca href=\"https://github.com/trekhleb/state-of-the-art-shitcode\"\u003eState-of-the-art\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"准则\"\u003e准则\u003c/h2\u003e\u003ch3 id=\"-以一种代码已经被混淆的方式命名变量\"\u003e💩 以一种代码已经被混淆的方式命名变量\u003c/h3\u003e\u003cp\u003e如果我们键入的东西越少，那么就有越多的时间去思考代码逻辑等问题。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eGood 👍🏻\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cem\u003eBad 👎🏻\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003eage\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"-多用拼音命名变量和函数\"\u003e💩 多用拼音命名变量和函数\u003c/h3\u003e\u003cp\u003e写拼音多方便，我们要推崇。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eGood 👍🏻\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003ehqtpgd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003etp\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e   \u003cspan class=\"c1\"\u003e//获取图片高度\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003etp\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eheight\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e     \u003cspan class=\"c1\"\u003e//图片\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cem\u003eBad 👎🏻\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003egetImageHeight\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eimage\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003eimage\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eheight\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"-变量函数混合命名风格\"\u003e💩 变量/函数混合命名风格\u003c/h3\u003e\u003cp\u003e为不同庆祝一下。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eGood 👍🏻\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003ewWidth\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e640\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003ew_height\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e480\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cem\u003eBad 👎🏻\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003ewindowWidth\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e640\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003ewindowHeight\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e480\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"-不要写注释\"\u003e💩 不要写注释\u003c/h3\u003e\u003cp\u003e反正没人会读你的代码。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eGood 👍🏻\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003ecdr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e700\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cem\u003eBad 👎🏻\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e更多时候，评论应该包含一些“为什么”，而不是一些“是什么”。如果“什么”在代码中不清楚，那么代码可能太混乱了。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 700ms的数量是根据UX A/B测试结果进行经验计算的。\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// @查看: \u0026lt;详细解释700的一个链接\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003ecallbackDebounceRate\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e700\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"-使用母语写注释\"\u003e💩 使用母语写注释\u003c/h3\u003e\u003cp\u003e如果您违反了“无注释”原则，那么至少尝试用一种不同于您用来编写代码的语言来编写注释。如果你的母语是英语，你可能会违反这个原则。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eGood 👍🏻\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// Закриваємо модальне віконечко при виникненні помилки.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"nx\"\u003etoggleModal\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kc\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cem\u003eBad 👎🏻\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 隐藏错误弹窗\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"nx\"\u003etoggleModal\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kc\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"-尽可能混合不同的格式\"\u003e💩 尽可能混合不同的格式\u003c/h3\u003e\u003cp\u003e为不同庆祝一下。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eGood 👍🏻\u003c/em\u003e\u003c/p\u003e","title":"垃圾代码书写准则"},{"content":"本文旨在为 Linux 用户介绍提供关于使用命令行连接网络的方法。 本文将详细介绍利用 nmcli 工具连接 Wi-Fi 和以太网的教程，包括查看连接状态、控制 Wi-Fi、控制以太网等等。\n安装 nmclinmcli 是 NetworkManager 的命令行工具，它可以用于管理和配置网络连接。如果你的 Linux 系统上没有安装 nmcli，请使用以下命令进行安装：\nsudo apt-get install network-manager 查看连接状态在连接网络之前，我们需要先查看网络状态。使用以下命令可以查看当前网络状态：\nnmcli general status 以上命令可以简写为：\nnmcli g # g 表示 general，默认为 status STATE：这是 NetworkManager 的当前状态。它可以是 \u0026ldquo;connected\u0026rdquo;、\u0026ldquo;connecting\u0026rdquo;、\u0026ldquo;disconnected\u0026rdquo;、\u0026ldquo;disconnecting\u0026rdquo; 或 \u0026ldquo;asleep\u0026rdquo; 等。\nConnectd Connecting Disconnected Disconnecting Asleep 已连接 连接中 未连接 断连中 休眠 CONNECTIVITY：这是系统的网络连接状态。它可以是 \u0026ldquo;full\u0026rdquo;、\u0026ldquo;limited\u0026rdquo; 、\u0026ldquo;Portal\u0026rdquo; 或 \u0026ldquo;none\u0026rdquo;。\nFull Limited Portal None 已联网，可上网 已联网，但不可上网 已联网，但需要认证 未联网 WIFI-HW：这是 WiFi 硬件的状态。它可以是 \u0026ldquo;enabled\u0026rdquo; 或 \u0026ldquo;disabled\u0026rdquo;。\nWIFI：这是 WiFi 的状态。它可以是 \u0026ldquo;enabled\u0026rdquo; 或 \u0026ldquo;disabled\u0026rdquo;。\nWWAN-HW：这是无线广域网（WWAN）硬件的状态。它可以是 \u0026ldquo;enabled\u0026rdquo; 或 \u0026ldquo;disabled\u0026rdquo;。\nWWAN：这是 WWAN 的状态。它可以是 \u0026ldquo;enabled\u0026rdquo; 或 \u0026ldquo;disabled\u0026rdquo;。\nEnabled Disabled 已启用 未启用 打开和关闭 Wi-Fi如果你的 Linux 系统支持 Wi-Fi，你可以使用以下命令打开或关闭 Wi-Fi：\nnmcli radio wifi on # 打开 Wi-Fi nmcli radio wifi off # 关闭 Wi-Fi 以上命令可以简写为：\nnmcli r w on # r 表示 radio，w 表示 wifi nmcli r w off 查看 Wi-Fi查看当前可用的 Wi-Fi 网络：\nnmcli dev wifi 以上命令可以简写为：\nnmcli d w # d 表示 dev，w 表示 wifi 带*星号的当前目前连接的Wi-Fi。\n连接和断开 Wi-Fi连接 Wi-Fi 网络需要知道网络名称和密码。使用以下命令连接一个 Wi-Fi 网络：\nnmcli dev wifi con \u0026lt;network-name\u0026gt; password \u0026lt;password\u0026gt; 以上命令可以简写为：\nnmcli d w c \u0026lt;network-name\u0026gt; password \u0026lt;password\u0026gt; # d 表示 dev，c 表示 con 如果连接成功，命令行将不会输出任何信息。使用以下命令查看当前连接的 Wi-Fi 网络：\nnmcli con show 以上命令可以简写为：\nnmcli c # c 表示 con，默认为 show 如果你需要断开当前连接的 Wi-Fi 网络，可以使用以下命令：\nnmcli con down \u0026lt;connection-name\u0026gt; 其中， 是需要断开的连接名称。\n以上命令可以简写为：\nnmcli c d \u0026lt;connection-name\u0026gt; # d 表示 down 忘记 Wi-Fi如果你不再需要连接到某个 Wi-Fi 网络，可以使用以下命令忘记该网络：\nnmcli connection delete \u0026lt;connection-name\u0026gt; 其中， 是需要忘记的连接名称。\n以上命令可以简写为：\nnmcli c de \u0026lt;connection-name\u0026gt; # de 表示 delete 连接以太网如果你需要连接以太网，你可以使用以下命令连接：\nnmcli dev con \u0026lt;interface-name\u0026gt; 其中， 是需要连接的网络接口名称。\n以上命令可以简写为：\nnmcli d c \u0026lt;interface-name\u0026gt; 查看以太网查看当前可用的以太网网络：\nnmcli dev status 以上命令可以简写为：\nnmcli d # d 表示 dev，默认为 status 断开以太网如果你需要断开当前连接的以太网网络，可以使用以下命令：\nnmcli dev discon \u0026lt;interface-name\u0026gt; 其中， 是需要断开的网络接口名称。\n以上命令可以简写为：\nnmcli d d \u0026lt;interface-name\u0026gt; # d 表示 discon 更多信息若想了解更多关于 nmcli 的信息，可以使用nmcli -h命令查看帮助信息。或者访问 NetworkManager 官方文档。\n","permalink":"https://blog.cassdev.com/posts/linux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e本文旨在为 Linux 用户介绍提供关于使用命令行连接网络的方法。 本文将详细介绍利用 nmcli 工具连接 Wi-Fi 和以太网的教程，包括查看连接状态、控制 Wi-Fi、控制以太网等等。\u003c/p\u003e\n\u003ch2 id=\"安装-nmcli\"\u003e安装 nmcli\u003c/h2\u003e\u003cp\u003enmcli 是 NetworkManager 的命令行工具，它可以用于管理和配置网络连接。如果你的 Linux 系统上没有安装 nmcli，请使用以下命令进行安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install network-manager\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看连接状态\"\u003e查看连接状态\u003c/h2\u003e\u003cp\u003e在连接网络之前，我们需要先查看网络状态。使用以下命令可以查看当前网络状态：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enmcli general status\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e以上命令可以简写为：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enmcli g   \u003cspan class=\"c1\"\u003e# g 表示 general，默认为 status\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg alt=\"nmcli general status\" loading=\"lazy\" src=\"https://s2.loli.net/2023/04/14/H59AWqixYr4O3eC.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eSTATE\u003c/code\u003e：这是 NetworkManager 的当前状态。它可以是 \u0026ldquo;connected\u0026rdquo;、\u0026ldquo;connecting\u0026rdquo;、\u0026ldquo;disconnected\u0026rdquo;、\u0026ldquo;disconnecting\u0026rdquo; 或 \u0026ldquo;asleep\u0026rdquo; 等。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eConnectd\u003c/th\u003e\n          \u003cth\u003eConnecting\u003c/th\u003e\n          \u003cth\u003eDisconnected\u003c/th\u003e\n          \u003cth\u003eDisconnecting\u003c/th\u003e\n          \u003cth\u003eAsleep\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e已连接\u003c/td\u003e\n          \u003ctd\u003e连接中\u003c/td\u003e\n          \u003ctd\u003e未连接\u003c/td\u003e\n          \u003ctd\u003e断连中\u003c/td\u003e\n          \u003ctd\u003e休眠\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eCONNECTIVITY\u003c/code\u003e：这是系统的网络连接状态。它可以是 \u0026ldquo;full\u0026rdquo;、\u0026ldquo;limited\u0026rdquo; 、\u0026ldquo;Portal\u0026rdquo; 或 \u0026ldquo;none\u0026rdquo;。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eFull\u003c/th\u003e\n          \u003cth\u003eLimited\u003c/th\u003e\n          \u003cth\u003ePortal\u003c/th\u003e\n          \u003cth\u003eNone\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e已联网，可上网\u003c/td\u003e\n          \u003ctd\u003e已联网，但不可上网\u003c/td\u003e\n          \u003ctd\u003e已联网，但需要认证\u003c/td\u003e\n          \u003ctd\u003e未联网\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eWIFI-HW\u003c/code\u003e：这是 WiFi 硬件的状态。它可以是 \u0026ldquo;enabled\u0026rdquo; 或 \u0026ldquo;disabled\u0026rdquo;。\u003c/p\u003e","title":"Linux 命令行网络连接指南"},{"content":"在 macOS 系统设置中，我们可以轻松地设置软件的语言，但有些应用程序如 App Store 和 Maps 却无法直接在设置中修改语言。这可能会让我们在使用这些应用程序时感到困惑，尤其是当我们需要使用不同语言的应用程序时。\n本文提供了一种简单的方法，让您能够修改 App Store 和 Maps 的语言设置，以便在需要时更轻松地使用这些应用程序。\n修改方法修改苹果地图的语言为简体中文：\nsudo defaults write com.apple.Maps AppleLanguages \u0026#39;(\u0026#34;zh-CN\u0026#34;)\u0026#39; 修改 App Store 的语言为美式英语：\nsudo defaults write com.apple.AppStore AppleLanguages \u0026#39;(\u0026#34;en-US\u0026#34;)\u0026#39; 其他软件其他软件均可在系统设置里直接设置。\n其他语言同理，其他语言只需修改命令最后的**「语言区域码」**即可。\n语言名称 代码 中文（简体） zh-CN 中文（繁体） zh-TW 英语（美国） en-US 英语（英国） en-GB 日语 ja 法语 fr 德语 de 西班牙语 es 韩语 ko 俄语 ru 葡萄牙语（巴西） pt-BR 阿拉伯语 ar 意大利语 it 土耳其语 tr 印地语 hi 印尼语 id 荷兰语 nl 波兰语 pl 瑞典语 sv 丹麦语 da 芬兰语 fi 挪威语 no 希腊语 el ","permalink":"https://blog.cassdev.com/posts/macos-%E4%BF%AE%E6%94%B9-app-store-%E5%92%8C%E5%9C%B0%E5%9B%BE%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e在 macOS 系统设置中，我们可以轻松地设置软件的语言，但有些应用程序如 App Store 和 Maps 却无法直接在设置中修改语言。这可能会让我们在使用这些应用程序时感到困惑，尤其是当我们需要使用不同语言的应用程序时。\u003c/p\u003e\n\u003cp\u003e本文提供了一种简单的方法，让您能够修改 App Store 和 Maps 的语言设置，以便在需要时更轻松地使用这些应用程序。\u003c/p\u003e\n\u003ch2 id=\"修改方法\"\u003e修改方法\u003c/h2\u003e\u003cp\u003e修改\u003cstrong\u003e苹果地图\u003c/strong\u003e的语言为简体中文：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo defaults write com.apple.Maps AppleLanguages \u003cspan class=\"s1\"\u003e\u0026#39;(\u0026#34;zh-CN\u0026#34;)\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e修改 \u003cstrong\u003eApp Store\u003c/strong\u003e 的语言为美式英语：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo defaults write com.apple.AppStore AppleLanguages \u003cspan class=\"s1\"\u003e\u0026#39;(\u0026#34;en-US\u0026#34;)\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"其他软件\"\u003e其他软件\u003c/h2\u003e\u003cp\u003e其他软件均可在系统设置里直接设置。\u003c/p\u003e\n\u003ch2 id=\"其他语言\"\u003e其他语言\u003c/h2\u003e\u003cp\u003e同理，其他语言只需修改命令最后的**「语言区域码」**即可。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e语言名称\u003c/th\u003e\n          \u003cth\u003e代码\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e中文（简体）\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ezh-CN\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e中文（繁体）\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ezh-TW\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e英语（美国）\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003een-US\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e英语（英国）\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003een-GB\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e日语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eja\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e法语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003efr\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e德语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ede\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e西班牙语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ees\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e韩语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eko\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e俄语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eru\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e葡萄牙语（巴西）\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ept-BR\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e阿拉伯语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ear\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e意大利语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eit\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e土耳其语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003etr\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e印地语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ehi\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e印尼语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eid\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e荷兰语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003enl\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e波兰语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003epl\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e瑞典语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003esv\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e丹麦语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eda\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e芬兰语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003efi\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e挪威语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eno\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e希腊语\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eel\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"MacOS 修改 App Store 和地图软件语言指南"},{"content":"该文章旨在帮助在 MacOS 系统下想要学习汇编语言的开发者配置 MASM + DOSBox 环境。\n配置步骤 克隆该项目到本地： git clone https://github.com/cassius0924/MASMForMac.git 将项目文件夹移动某个位置：\n例如我将这个文件夹放到了 ~/Documents/中\nmv MASMForMac ~/Documents/. 安装 DOSBox：\n用 Finder 打开 MASMForMac/mac 目录，打开 dmg 安装包。再打开 Application 文件夹，将 DOSBox 应用程序拖入 Application 文件夹中。\n在 DOSBox 中挂载目录：\nmount c ~/Documents/MASMForMac 此目录将会把~/Documents/MASMForMac挂载到 C 盘。路径根据自己情况修改。\n每次打开 DOSBox 应用程序都需要挂载目录。可以配置自动挂载，详见下文**「配置文件」**。\n在 DOSBox 中进入 C 盘： c: 编译 hello.asm 文件： 已经预先写好了一个hello.asm汇编测试示例，用于测试汇编环境。\nmasm hello.asm 连按三下回车，此命令会生成obj文件。\n生成hello.exe可执行文件： link hello.obj 同样连按三下回车。\n运行 hello.exe 文件： hello.exe 正常情况，会输出字符串：Hello world!\n文件结构. ├── CREF.EXE ├── ERROUT.EXE ├── EXEMOD.EXE ├── EXEPACK.EXE ├── LIB.EXE ├── LINK.EXE ├── MAKE.EXE ├── MASM.EXE ├── README.DOC ├── SETENV.EXE ├── debug.exe ├── hello.asm └── mac ├── DOSBox-0.74-3-3.dmg └── masm5.zip 配置文件MacOS 的 DOSBox 配置文件位于 ~/Library/Preferences/DOSBox\\ 0.74-3-3\\ Preferences\nvim ~/Library/Preferences/DOSBox\\ 0.74-3-3\\ Preferences 配置自动挂载在文件末尾加入两行命令：\nmount c ~/Documents/MASMForMac c: 每次启动 DOSBox 将会自动运行这两行命令。\n调整窗口大小找到windowresolution=origin，将origin修改成 长度x高度。例如：\nwindowresolution=1024x680 其他配置更多配置详解见官方说明。\n","permalink":"https://blog.cassdev.com/posts/macos-%E9%85%8D%E7%BD%AE-masm-+-dosbox-%E6%B1%87%E7%BC%96%E7%8E%AF%E5%A2%83/","summary":"\u003cp\u003e该文章旨在帮助在 MacOS 系统下想要学习汇编语言的开发者配置 MASM + DOSBox 环境。\u003c/p\u003e\n\u003ch2 id=\"配置步骤\"\u003e配置步骤\u003c/h2\u003e\u003col\u003e\n\u003cli\u003e克隆该项目到本地：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit clone https://github.com/cassius0924/MASMForMac.git\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003cp\u003e将项目文件夹移动某个位置：\u003c/p\u003e\n\u003cp\u003e例如我将这个文件夹放到了 \u003ccode\u003e~/Documents/\u003c/code\u003e中\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emv MASMForMac ~/Documents/.\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e\n\u003cp\u003e安装 DOSBox：\u003c/p\u003e\n\u003cp\u003e用 Finder 打开 MASMForMac/mac 目录，打开 dmg 安装包。再打开 Application 文件夹，将 DOSBox 应用程序拖入 Application 文件夹中。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Install DOSBox\" loading=\"lazy\" src=\"https://s2.loli.net/2023/04/12/VFnbHXMK2WDEJ49.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在 DOSBox 中挂载目录：\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emount c ~/Documents/MASMForMac\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e此目录将会把\u003ccode\u003e~/Documents/MASMForMac\u003c/code\u003e挂载到 C 盘。路径根据自己情况修改。\u003c/p\u003e\n\u003cp\u003e每次打开 DOSBox 应用程序都需要挂载目录。可以配置自动挂载，详见下文**「配置文件」**。\u003c/p\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e在 DOSBox 中进入 C 盘：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ec:\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"6\"\u003e\n\u003cli\u003e编译 \u003ccode\u003ehello.asm\u003c/code\u003e 文件：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e已经预先写好了一个\u003ccode\u003ehello.asm\u003c/code\u003e汇编测试示例，用于测试汇编环境。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emasm hello.asm\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e连按三下回车，此命令会生成\u003ccode\u003eobj\u003c/code\u003e文件。\u003c/p\u003e\n\u003col start=\"7\"\u003e\n\u003cli\u003e生成\u003ccode\u003ehello.exe\u003c/code\u003e可执行文件：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003elink hello.obj\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e同样连按三下回车。\u003c/p\u003e\n\u003col start=\"7\"\u003e\n\u003cli\u003e运行 \u003ccode\u003ehello.exe\u003c/code\u003e 文件：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehello.exe\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e正常情况，会输出字符串：Hello world!\u003c/p\u003e","title":"MacOS 配置 MASM + DOSBox 汇编环境"},{"content":"本文介绍如何使用 Open3D C++ 库来进行点云的配准、相加和可视化显示。Open3D 是一个开源的多维数据处理工具箱，支持点云、图像和三维几何等多种类型的数据处理和可视化。\n点云读取使用 ReadPointCloud() 函数可以轻松读取 pcd 和 ply 点云文件：\n// 读取 pcd 和 ply 点云文件 auto source = std::make_shared\u0026lt;open3d::geometry::PointCloud\u0026gt;(); auto target = std::make_shared\u0026lt;open3d::geometry::PointCloud\u0026gt;(); open3d::io::ReadPointCloud(\u0026#34;pcd-data/1.pcd\u0026#34;, *source); open3d::io::ReadPointCloud(\u0026#34;pcd-data/2.pcd\u0026#34;, *target); // ply 文件同理 // open3d::io::ReadPointCloud(\u0026#34;pcd-data/1.ply\u0026#34;, *source); // open3d::io::ReadPointCloud(\u0026#34;pcd-data/2.ply\u0026#34;, *target); 点云上色为两份点云上上不同的颜色：\nsource-\u0026gt;PaintUniformColor({1, 0.706, 0}); // source 为黄色 target-\u0026gt;PaintUniformColor({0, 0.651, 0.929});// target 为蓝色 点云配准使用 Open3D 提供的 RegistrationICP() 函数进行点云配准。代码如下：\n// 为两个点云分别进行outlier removal //auto processed_source = source-\u0026gt;RadiusOutlierRemoval(16, 0.5); //auto processed_target = target-\u0026gt;RadiusOutlierRemoval(16, 0.5); double threshold = 1.0; // 移动范围的阀值 Eigen::Matrix4d trans_init = Eigen::Matrix4d::Identity(); // 运行ICP配准 open3d::pipelines::registration::RegistrationResult reg_p2p; // 这一步会返回点云的变换矩阵 reg_p2p = open3d::pipelines::registration::RegistrationICP( *source, *target, threshold, trans_init, open3d::pipelines::registration::TransformationEstimationPointToPoint()); // 将点云依照输出的变换矩阵进行变换 source-\u0026gt;Transform(reg_p2p.transformation_); 点云相加这一步很简单，使用重载运算符 += 将两份点云数据相加：\n*source += *target; 点云显示将两份点云数据在同一个窗口进行可视化显示：\nstd::vector\u0026lt;std::shared_ptr\u0026lt;const open3d::geometry::Geometry\u0026gt;\u0026gt; geometries; geometries.push_back(source); geometries.push_back(target); // 使用 `DrawGeometries()` 函数来显示点云 open3d::visualization::DrawGeometries(geometries); ","permalink":"https://blog.cassdev.com/posts/%E5%9F%BA%E4%BA%8E-open3d-c++-%E7%89%88%E5%AE%9E%E7%8E%B0%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E7%9A%84%E9%85%8D%E5%87%86%E5%92%8C%E7%9B%B8%E5%8A%A0/","summary":"\u003cp\u003e本文介绍如何使用 Open3D C++ 库来进行点云的配准、相加和可视化显示。Open3D 是一个开源的多维数据处理工具箱，支持点云、图像和三维几何等多种类型的数据处理和可视化。\u003c/p\u003e\n\u003ch2 id=\"点云读取\"\u003e点云读取\u003c/h2\u003e\u003cp\u003e使用 \u003ccode\u003eReadPointCloud()\u003c/code\u003e 函数可以轻松读取 pcd 和 ply 点云文件：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 读取 pcd 和 ply 点云文件\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"n\"\u003esource\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003emake_shared\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eopen3d\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003egeometry\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ePointCloud\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003emake_shared\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eopen3d\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003egeometry\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ePointCloud\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eopen3d\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eio\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"nf\"\u003eReadPointCloud\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;pcd-data/1.pcd\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003esource\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eopen3d\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eio\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"nf\"\u003eReadPointCloud\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;pcd-data/2.pcd\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// ply 文件同理\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// open3d::io::ReadPointCloud(\u0026#34;pcd-data/1.ply\u0026#34;, *source);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// open3d::io::ReadPointCloud(\u0026#34;pcd-data/2.ply\u0026#34;, *target);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"点云上色\"\u003e点云上色\u003c/h2\u003e\u003cp\u003e为两份点云上上不同的颜色：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003esource\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"nf\"\u003ePaintUniformColor\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.706\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e});\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// source 为黄色\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"nf\"\u003ePaintUniformColor\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.651\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.929\u003c/span\u003e\u003cspan class=\"p\"\u003e});\u003c/span\u003e\u003cspan class=\"c1\"\u003e// target 为蓝色\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"点云配准\"\u003e点云配准\u003c/h2\u003e\u003cp\u003e使用 Open3D 提供的 \u003ccode\u003eRegistrationICP()\u003c/code\u003e 函数进行点云配准。代码如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 为两个点云分别进行outlier removal\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e//auto processed_source = source-\u0026gt;RadiusOutlierRemoval(16, 0.5);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e//auto processed_target = target-\u0026gt;RadiusOutlierRemoval(16, 0.5);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003ethreshold\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mf\"\u003e1.0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 移动范围的阀值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eEigen\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eMatrix4d\u003c/span\u003e \u003cspan class=\"n\"\u003etrans_init\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eEigen\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eMatrix4d\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"nf\"\u003eIdentity\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 运行ICP配准\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eopen3d\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003epipelines\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eregistration\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eRegistrationResult\u003c/span\u003e \u003cspan class=\"n\"\u003ereg_p2p\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 这一步会返回点云的变换矩阵\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003ereg_p2p\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eopen3d\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003epipelines\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eregistration\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"nf\"\u003eRegistrationICP\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \t\t\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003esource\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ethreshold\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003etrans_init\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"n\"\u003eopen3d\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003epipelines\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eregistration\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"nf\"\u003eTransformationEstimationPointToPoint\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 将点云依照输出的变换矩阵进行变换\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003esource\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"nf\"\u003eTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ereg_p2p\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etransformation_\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"点云相加\"\u003e点云相加\u003c/h2\u003e\u003cp\u003e这一步很简单，使用重载运算符 \u003ccode\u003e+=\u003c/code\u003e 将两份点云数据相加：\u003c/p\u003e","title":"基于 Open3D C++ 版实现点云数据的配准、相加和显示"},{"content":"\n此文章旨在帮助解决 C++ 版 Open3D 编译时找不到 AzureKinect 相关函数的问题。\n问题描述在尝试构建官方Azure Kinect示例时（AzureKinectViewer.cpp、AzureKinectMKVReader.cpp和AzureKinectRecord.cpp）报错：\n[1/1] Linking CXX executable AzureKinectViewer FAILED: AzureKinectViewer : \u0026amp;\u0026amp; /usr/bin/c++ CMakeFiles/AzureKinectViewer.dir/AzureKinectViewer.cpp.o -o AzureKinectViewer -L/usr/local/lib -L/usr/local/cuda/lib64 -Wl,-rpath,/usr/local/lib:/usr/local/cuda/lib64 /usr/lib/aarch64-linux-gnu/libk4a.so.1.4.1 /usr/local/lib/libOpen3D.so \u0026amp;\u0026amp; : CMakeFiles/AzureKinectViewer.dir/AzureKinectViewer.cpp.o: In function `main\u0026#39;: AzureKinectViewer.cpp:(.text+0x4fc): undefined reference to `open3d::io::AzureKinectSensor::ListDevices()\u0026#39; AzureKinectViewer.cpp:(.text+0x50c): undefined reference to `open3d::io::AzureKinectSensorConfig::AzureKinectSensorConfig()\u0026#39; AzureKinectViewer.cpp:(.text+0x75c): undefined reference to `open3d::io::AzureKinectSensor::AzureKinectSensor(open3d::io::AzureKinectSensorConfig const\u0026amp;)\u0026#39; AzureKinectViewer.cpp:(.text+0x76c): undefined reference to `open3d::io::AzureKinectSensor::Connect(unsigned long)\u0026#39; AzureKinectViewer.cpp:(.text+0x84c): undefined reference to `open3d::io::AzureKinectSensor::CaptureFrame(bool) const\u0026#39; AzureKinectViewer.cpp:(.text+0x93c): undefined reference to `open3d::io::AzureKinectSensor::~AzureKinectSensor()\u0026#39; AzureKinectViewer.cpp:(.text+0xb2c): undefined reference to `open3d::io::AzureKinectSensor::~AzureKinectSensor()\u0026#39; CMakeFiles/AzureKinectViewer.dir/AzureKinectViewer.cpp.o: In function `open3d::io::AzureKinectSensorConfig::~AzureKinectSensorConfig()\u0026#39;: AzureKinectViewer.cpp:(.text._ZN6open3d2io23AzureKinectSensorConfigD2Ev[_ZN6open3d2io23AzureKinectSensorConfigD5Ev]+0xc): undefined reference to `vtable for open3d::io::AzureKinectSensorConfig\u0026#39; AzureKinectViewer.cpp:(.text._ZN6open3d2io23AzureKinectSensorConfigD2Ev[_ZN6open3d2io23AzureKinectSensorConfigD5Ev]+0x10): undefined reference to `vtable for open3d::io::AzureKinectSensorConfig\u0026#39; collect2: error: ld returned 1 exit status ninja: build stopped: subcommand failed. 这是因为安装Open3D时未开启Azure Kinect的支持选项。\n解决方法重新安装Open3D。找到Open3D源码文件夹，执行以下命令：\ncd build 开启Azure Kinect支持的构建选项：\nsudo cmake -DBUILD_AZURE_KINECT=ON .. 编译安装：\nsudo make sudo make install ","permalink":"https://blog.cassdev.com/posts/%E6%9E%84%E5%BB%BA-open3d-%E5%AE%98%E6%96%B9-azure-kinect-%E7%A4%BA%E4%BE%8B%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0-azurekinect-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","summary":"\u003cp\u003e\u003cimg alt=\"Azure Kinect with Open3D\" loading=\"lazy\" src=\"https://s2.loli.net/2023/04/08/Urlin4NQLEc3kyV.png\"\u003e\u003c/p\u003e\n\u003cp\u003e此文章旨在帮助解决 C++ 版 Open3D 编译时找不到 AzureKinect 相关函数的问题。\u003c/p\u003e\n\u003ch2 id=\"问题描述\"\u003e问题描述\u003c/h2\u003e\u003cp\u003e在尝试构建官方Azure Kinect示例时（\u003ccode\u003eAzureKinectViewer.cpp\u003c/code\u003e、\u003ccode\u003eAzureKinectMKVReader.cpp\u003c/code\u003e和\u003ccode\u003eAzureKinectRecord.cpp\u003c/code\u003e）报错：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e1/1\u003cspan class=\"o\"\u003e]\u003c/span\u003e Linking CXX executable AzureKinectViewer\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eFAILED: AzureKinectViewer \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e: \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e /usr/bin/c++   CMakeFiles/AzureKinectViewer.dir/AzureKinectViewer.cpp.o -o AzureKinectViewer -L/usr/local/lib   -L/usr/local/cuda/lib64 -Wl,-rpath,/usr/local/lib:/usr/local/cuda/lib64  /usr/lib/aarch64-linux-gnu/libk4a.so.1.4.1  /usr/local/lib/libOpen3D.so \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e :\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eCMakeFiles/AzureKinectViewer.dir/AzureKinectViewer.cpp.o: In \u003cspan class=\"k\"\u003efunction\u003c/span\u003e \u003cspan class=\"sb\"\u003e`\u003c/span\u003emain\u003cspan class=\"s1\"\u003e\u0026#39;:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003eAzureKinectViewer.cpp:(.text+0x4fc): undefined reference to `open3d::io::AzureKinectSensor::ListDevices()\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eAzureKinectViewer.cpp:\u003cspan class=\"o\"\u003e(\u003c/span\u003e.text+0x50c\u003cspan class=\"o\"\u003e)\u003c/span\u003e: undefined reference to \u003cspan class=\"sb\"\u003e`\u003c/span\u003eopen3d::io::AzureKinectSensorConfig::AzureKinectSensorConfig\u003cspan class=\"o\"\u003e()\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003eAzureKinectViewer.cpp:(.text+0x75c): undefined reference to `open3d::io::AzureKinectSensor::AzureKinectSensor(open3d::io::AzureKinectSensorConfig const\u0026amp;)\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eAzureKinectViewer.cpp:\u003cspan class=\"o\"\u003e(\u003c/span\u003e.text+0x76c\u003cspan class=\"o\"\u003e)\u003c/span\u003e: undefined reference to \u003cspan class=\"sb\"\u003e`\u003c/span\u003eopen3d::io::AzureKinectSensor::Connect\u003cspan class=\"o\"\u003e(\u003c/span\u003eunsigned long\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003eAzureKinectViewer.cpp:(.text+0x84c): undefined reference to `open3d::io::AzureKinectSensor::CaptureFrame(bool) const\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eAzureKinectViewer.cpp:\u003cspan class=\"o\"\u003e(\u003c/span\u003e.text+0x93c\u003cspan class=\"o\"\u003e)\u003c/span\u003e: undefined reference to \u003cspan class=\"sb\"\u003e`\u003c/span\u003eopen3d::io::AzureKinectSensor::~AzureKinectSensor\u003cspan class=\"o\"\u003e()\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003eAzureKinectViewer.cpp:(.text+0xb2c): undefined reference to `open3d::io::AzureKinectSensor::~AzureKinectSensor()\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eCMakeFiles/AzureKinectViewer.dir/AzureKinectViewer.cpp.o: In \u003cspan class=\"k\"\u003efunction\u003c/span\u003e \u003cspan class=\"sb\"\u003e`\u003c/span\u003eopen3d::io::AzureKinectSensorConfig::~AzureKinectSensorConfig\u003cspan class=\"o\"\u003e()\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003eAzureKinectViewer.cpp:(.text._ZN6open3d2io23AzureKinectSensorConfigD2Ev[_ZN6open3d2io23AzureKinectSensorConfigD5Ev]+0xc): undefined reference to `vtable for open3d::io::AzureKinectSensorConfig\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eAzureKinectViewer.cpp:\u003cspan class=\"o\"\u003e(\u003c/span\u003e.text._ZN6open3d2io23AzureKinectSensorConfigD2Ev\u003cspan class=\"o\"\u003e[\u003c/span\u003e_ZN6open3d2io23AzureKinectSensorConfigD5Ev\u003cspan class=\"o\"\u003e]\u003c/span\u003e+0x10\u003cspan class=\"o\"\u003e)\u003c/span\u003e: undefined reference to \u003cspan class=\"sb\"\u003e`\u003c/span\u003evtable \u003cspan class=\"k\"\u003efor\u003c/span\u003e open3d::io::AzureKinectSensorConfig\u003cspan class=\"err\"\u003e\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecollect2: error: ld returned \u003cspan class=\"m\"\u003e1\u003c/span\u003e \u003cspan class=\"nb\"\u003eexit\u003c/span\u003e status\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eninja: build stopped: subcommand failed.\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这是因为安装Open3D时未开启Azure Kinect的支持选项。\u003c/p\u003e","title":"构建 Open3D 官方 Azure Kinect 示例时找不到 AzureKinect*** 的解决方法"},{"content":"本文旨在帮助大家在 Chrome 中使用 New Bing（Bing AI）。\n前几周，New Bing 的申请已经全面开放，无需等待，直接即可通过申请。但微软限制了 New Bing 只能在自家的 Edge 浏览器使用，对于我这种万年 Chrome 玩家就很苦恼，不习惯 Edge。\n前提 你得能科学上网；\n你已经通过 New Bing 的申请。\n步骤没什么步骤，安装个 Chrome 插件即可。\n安装 Bing Unchained 插件安装插件 Unchained 。\n然后刷新一下Bing.com即可。\n","permalink":"https://blog.cassdev.com/posts/%E5%9C%A8-chrome-%E4%B8%AD%E8%A7%A3%E9%94%81-new-bingbing-ai/","summary":"\u003cp\u003e本文旨在帮助大家在 Chrome 中使用 New Bing（Bing AI）。\u003c/p\u003e\n\u003cp\u003e前几周，New Bing 的申请已经\u003cstrong\u003e全面开放\u003c/strong\u003e，无需等待，直接即可通过申请。但微软限制了 New Bing 只能在自家的 Edge 浏览器使用，对于我这种万年 Chrome 玩家就很苦恼，不习惯 Edge。\u003c/p\u003e\n\u003ch2 id=\"前提\"\u003e前提\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e你得能\u003cem\u003e\u003cstrong\u003e科学上网\u003c/strong\u003e\u003c/em\u003e；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e你已经通过 New Bing 的申请。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"步骤\"\u003e步骤\u003c/h2\u003e\u003cp\u003e\u003cdel\u003e没什么步骤\u003c/del\u003e，安装个 Chrome 插件即可。\u003c/p\u003e\n\u003ch3 id=\"安装-bing-unchained-插件\"\u003e安装 Bing Unchained 插件\u003c/h3\u003e\u003cp\u003e安装插件 \u003ca href=\"https://chrome.google.com/webstore/detail/bing-unchained-use-new-bi/laldfnbbeocphnilnofhedhcjcnchbld\"\u003eUnchained\u003c/a\u003e 。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Bing Unchained\" loading=\"lazy\" src=\"https://s2.loli.net/2023/04/03/MP2AORkbBzEYFp3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e然后刷新一下\u003ca href=\"https://www.bing.com\"\u003eBing.com\u003c/a\u003e即可。\u003c/p\u003e","title":"在 Chrome 中解锁 New Bing（Bing AI）"},{"content":"\nSSH（Secure Shell）是一种网络协议，可以在不安全的网络中提供一种安全的加密通信方式。SSH 免密登录是指用户在登录远程主机时，无需输入密码即可完成登录，免去每次登录时输入密码的烦恼。这种方式既提高了用户的操作便捷性，又避免了使用简单密码的风险，极大地提高了登录的安全性。本文旨在以简单易懂的方式解释SSH免密登录的原理。\nSSH免密登录原理非对称加密在了解SSH免密登录原理之前，我们需要先了解“非对称加密”。SSH 免密登录原理是基于非对称加密技术。\n非对称加密就是指加密数据和解密数据用的是不同密钥，密钥分为加密密钥和解密密钥，将这样的两个密钥称为密钥对。\n用户用加密密钥加密的数据只能用解密密钥才能解密，而且两个密钥相对独立，知道了其中的一个密钥，并不能计算出另一个密钥。因此我们可以公开其中的一个密钥，保密另一个密钥。公开的密钥称为公钥，不公开的密钥称为密钥。在 SSH 协议中加密密钥为公钥，解密密钥为私钥，这也被称为“公钥加密技术”。\n因此，私钥应该妥善保管，防止泄露。如果私钥安全，那么 SSH 免密登录将是一种非常安全的登录方式。\n除了提高操作便捷性和登录安全性之外，SSH 免密登录还可以减少用户输入密码的次数。这对于需要频繁登录远程主机的用户来说尤为重要。此外，SSH 免密登录还可以实现自动化脚本的编写和远程服务器的管理，从而提高工作效率。\n总之，了解 SSH 免密登录的原理可以帮助用户更好地使用该功能，保证登录的安全性和便捷性。同时，用户在使用 SSH 免密登录时，也应该注意保护自己的私钥，避免私钥泄露，以确保登录的安全性。\n不难猜到，与非对称加密相反的对称加密指的就是加密与解密用的是同一个密钥。此种加密方法安全性低。\n免密登录流程\nSSH免密登录原理基于公钥加密技术，具体步骤如下：\n用户在本地生成id_rsa.pub公钥和id_rsa私钥；\n命令：ssh-keygen\n并且私钥只用于解密数据，公钥只用于加密数据。私钥只保存在本地，公钥复制一份到远程服务器上；\n命令：ssh-copy-id\n当用户通过SSH协议连接远程服务器时，会发送包含username的数据用于请求连接，服务器在接下来的操作中会使用与username相对应的公钥；\n命令：ssh username@remote_host\n服务器会生成一个随机数，称之为 Challenge，并将 Challenge 使用公钥加密后发送给用户；\n用户使用私钥对 Challenge 进行解密；\n再将解密后的数据再用 MD5 加密一遍发送回服务器；\n服务器会对比原始 Chanllenge 的 MD5 值和用户发送过来的 MD5值，若一致则允许用户登录，否则拒绝登录。\n使用方法 首先在本地生成一对公私钥，可以使用以下命令： ssh-keygen -t rsa 这个命令会在用户目录~下生成一个 .ssh 文件夹，里面包含私钥和公钥。\n将公钥上传到远程服务器，可以使用以下命令： ssh-copy-id username@remote_host 其中，username为远程服务器的用户名，remote_host为远程服务器的IP地址或域名。\n登录远程服务器时，可以使用以下命令： ssh username@remote_host 写在最后除了提高操作便捷性和登录安全性之外，SSH 免密登录还可以减少用户输入密码的次数。这对于需要频繁登录远程主机的用户来说尤为重要。此外，SSH 免密登录还可以实现自动化脚本（例如GitHub Actions）的编写和远程服务器的管理，从而提高工作效率。\n总之，了解 SSH 免密登录的原理可以帮助用户更好地使用该功能，保证登录的安全性和便捷性。同时，用户在使用 SSH 免密登录时，也应该注意保护自己的私钥，避免私钥泄露，以确保登录的安全性。\n","permalink":"https://blog.cassdev.com/posts/%E6%B5%85%E6%9E%90-ssh-%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86/","summary":"\u003cp\u003e\u003cimg alt=\"GitHub Security\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/28/RZc1M34LgDpEolw.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSSH（Secure Shell）是一种网络协议，可以在不安全的网络中提供一种安全的加密通信方式。SSH 免密登录是指用户在登录远程主机时，无需输入密码即可完成登录，免去每次登录时输入密码的烦恼。这种方式既提高了用户的操作便捷性，又避免了使用简单密码的风险，极大地提高了登录的安全性。本文旨在以简单易懂的方式解释SSH免密登录的原理。\u003c/p\u003e\n\u003ch2 id=\"ssh免密登录原理\"\u003eSSH免密登录原理\u003c/h2\u003e\u003ch3 id=\"非对称加密\"\u003e非对称加密\u003c/h3\u003e\u003cp\u003e在了解SSH免密登录原理之前，我们需要先了解“非对称加密”。SSH 免密登录原理是基于非对称加密技术。\u003c/p\u003e\n\u003cp\u003e非对称加密就是指加密数据和解密数据用的是不同密钥，密钥分为加密密钥和解密密钥，将这样的两个密钥称为密钥对。\u003c/p\u003e\n\u003cp\u003e用户用\u003cstrong\u003e加密密钥\u003c/strong\u003e加密的数据只能用\u003cstrong\u003e解密密钥\u003c/strong\u003e才能解密，而且两个密钥相对独立，知道了其中的一个密钥，并不能计算出另一个密钥。因此我们可以公开其中的一个密钥，保密另一个密钥。公开的密钥称为公钥，不公开的密钥称为密钥。在 SSH 协议中\u003cstrong\u003e加密密钥为公钥，解密密钥为私钥\u003c/strong\u003e，这也被称为“公钥加密技术”。\u003c/p\u003e\n\u003cp\u003e因此，私钥应该妥善保管，防止泄露。如果私钥安全，那么 SSH 免密登录将是一种非常安全的登录方式。\u003c/p\u003e\n\u003cp\u003e除了提高操作便捷性和登录安全性之外，SSH 免密登录还可以减少用户输入密码的次数。这对于需要频繁登录远程主机的用户来说尤为重要。此外，SSH 免密登录还可以实现自动化脚本的编写和远程服务器的管理，从而提高工作效率。\u003c/p\u003e\n\u003cp\u003e总之，了解 SSH 免密登录的原理可以帮助用户更好地使用该功能，保证登录的安全性和便捷性。同时，用户在使用 SSH 免密登录时，也应该注意保护自己的私钥，避免私钥泄露，以确保登录的安全性。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e不难猜到，与非对称加密相反的\u003cstrong\u003e对称加密\u003c/strong\u003e指的就是加密与解密用的是\u003cstrong\u003e同一个密钥\u003c/strong\u003e。此种加密方法安全性低。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch3 id=\"免密登录流程\"\u003e免密登录流程\u003c/h3\u003e\u003cp\u003e\u003cimg alt=\"SSH免密登录流程\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/27/Sl6N7qFGcojrWQw.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSSH免密登录原理基于公钥加密技术，具体步骤如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e用户在本地生成\u003ccode\u003eid_rsa.pub\u003c/code\u003e公钥和\u003ccode\u003eid_rsa\u003c/code\u003e私钥；\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e命令：\u003ccode\u003essh-keygen\u003c/code\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e并且私钥只用于解密数据，公钥只用于加密数据。私钥\u003cstrong\u003e只保存在本地\u003c/strong\u003e，公钥复制一份到远程服务器上；\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e命令：\u003ccode\u003essh-copy-id\u003c/code\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e当用户通过SSH协议连接远程服务器时，会发送包含\u003ccode\u003eusername\u003c/code\u003e的数据用于请求连接，服务器在接下来的操作中会使用与\u003ccode\u003eusername\u003c/code\u003e\u003cstrong\u003e相对应的公钥\u003c/strong\u003e；\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e命令：\u003ccode\u003essh username@remote_host\u003c/code\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e服务器会生成一个随机数，称之为 Challenge，并将 Challenge 使用\u003cstrong\u003e公钥加密\u003c/strong\u003e后发送给用户；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e用户使用\u003cstrong\u003e私钥\u003c/strong\u003e对 Challenge 进行\u003cstrong\u003e解密\u003c/strong\u003e；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e再将解密后的数据再用 MD5 加密一遍发送回服务器；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e服务器会对比原始 Chanllenge 的 MD5 值和用户发送过来的 MD5值，若一致则允许用户登录，否则拒绝登录。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"使用方法\"\u003e使用方法\u003c/h2\u003e\u003col\u003e\n\u003cli\u003e首先在本地生成一对公私钥，可以使用以下命令：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003essh-keygen -t rsa\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个命令会在用户目录\u003ccode\u003e~\u003c/code\u003e下生成一个 \u003ccode\u003e.ssh\u003c/code\u003e 文件夹，里面包含私钥和公钥。\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e将公钥上传到远程服务器，可以使用以下命令：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003essh-copy-id username@remote_host\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e其中，\u003ccode\u003eusername\u003c/code\u003e为远程服务器的用户名，\u003ccode\u003eremote_host\u003c/code\u003e为远程服务器的IP地址或域名。\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e登录远程服务器时，可以使用以下命令：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003essh username@remote_host\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"写在最后\"\u003e写在最后\u003c/h2\u003e\u003cp\u003e除了提高操作便捷性和登录安全性之外，SSH 免密登录还可以减少用户输入密码的次数。这对于需要频繁登录远程主机的用户来说尤为重要。此外，SSH 免密登录还可以实现自动化脚本（例如GitHub Actions）的编写和远程服务器的管理，从而提高工作效率。\u003c/p\u003e","title":"浅析 SSH 免密登录原理"},{"content":"#找不到 catkin_init_workspace 命令的解决方法\n本文提供了一个简单的解决方案，帮助你解决在ROS工作空间中使用catkin_init_workspace命令时出现的 command not found 的问题。\n问题描述在建立 ROS 工作空间的时候发现找不到初始化工作空间命令：\ncatkin_init_workspace 但是检查后发现明明已经安装了 ROS-melodic-catkin，应该可以用初始化命令才对：\n最后在 ROS 官网找到答案，问题出在环境配置上。\n解决方法我们只需要 source 一下环境配置脚本即可：\nsource /opt/ros/melodic/setup.sh 注意：不同版本 ROS 的 setup.sh 脚本的文件路径不同。Noetic 版 ROS 的 setup.sh 脚本在 /opt/ros/noetic下。\n执行以下命令可以在每次启动新的 Shell 窗口时自动的 source 这个脚本：\necho \u0026#34;source /opt/ros/melodic/setup.sh\u0026#34; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 如果你用的是 Zsh，则执行以下命令：\necho \u0026#34;source /opt/ros/melodic/setup.sh\u0026#34; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc ","permalink":"https://blog.cassdev.com/posts/%E6%89%BE%E4%B8%8D%E5%88%B0%E5%91%BD%E4%BB%A4-catkin_init_workspace-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","summary":"\u003cp\u003e#找不到 catkin_init_workspace 命令的解决方法\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"ROS Logo\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/28/TPrkdjpvx2bwXMn.png\"\u003e\u003c/p\u003e\n\u003cp\u003e本文提供了一个简单的解决方案，帮助你解决在ROS工作空间中使用\u003ccode\u003ecatkin_init_workspace\u003c/code\u003e命令时出现的 command not found 的问题。\u003c/p\u003e\n\u003ch2 id=\"问题描述\"\u003e问题描述\u003c/h2\u003e\u003cp\u003e在建立 ROS 工作空间的时候发现找不到初始化工作空间命令：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecatkin_init_workspace\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg alt=\"catkin_init_workspace\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/28/ln4ZiGTIFgDCVRo.png\"\u003e\u003c/p\u003e\n\u003cp\u003e但是检查后发现明明已经安装了 ROS-melodic-catkin，应该可以用初始化命令才对：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"dpkg\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/28/RBjeTduYykgtXUE.png\"\u003e\u003c/p\u003e\n\u003cp\u003e最后在 ROS 官网找到答案，问题出在\u003cstrong\u003e环境配置\u003c/strong\u003e上。\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\u003cp\u003e我们只需要 source 一下环境配置脚本即可：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esource\u003c/span\u003e /opt/ros/melodic/setup.sh\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e注意：不同版本 ROS 的 setup.sh 脚本的文件路径不同。Noetic 版 ROS 的 setup.sh 脚本在 \u003ccode\u003e/opt/ros/noetic\u003c/code\u003e下。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e执行以下命令可以在每次启动新的 Shell 窗口时自动的 source 这个脚本：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;source /opt/ros/melodic/setup.sh\u0026#34;\u003c/span\u003e \u0026gt;\u0026gt; ~/.bashrc\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esource\u003c/span\u003e ~/.bashrc\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果你用的是 Zsh，则执行以下命令：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;source /opt/ros/melodic/setup.sh\u0026#34;\u003c/span\u003e \u0026gt;\u0026gt; ~/.zshrc\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esource\u003c/span\u003e ~/.zshrc\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"找不到 catkin_init_workspace 命令的解决方法"},{"content":"tags: [\u0026ldquo;Linux\u0026rdquo;, \u0026ldquo;Docker\u0026rdquo;, \u0026ldquo;Nginx\u0026rdquo;, \u0026ldquo;Server\u0026rdquo;, \u0026ldquo;Blog\u0026rdquo;]本文是一个使用 Docker 和 Nginx 部署个人静态博客的指南。通过本指南，您可以快速了解如何使用 Docker 和 Nginx 部署自己的静态博客网站。\n前提在开始使用本指南之前，请具备以下前提：\n首先你得有个服务器 服务器已经安装好Git、Vim等工具 一份静态博客源码，本文以 Astro Air Blog 为例 步骤第一步：安装 Dockersudo apt install docker 第二步：拉取 Nginx 镜像docker pull nginx 镜像名后不加版本号表示拉取最新版，若希望拉取指定版本则需在镜像名后加上tag，例如docker pull nginx:1.16。\n第三步：获取 Nginx 的配置文件 先运行一个不挂载的 Nginx 容器\ndocker run -d --name my-nginx -p 80:80 nginx -d：使容器在后台以守护进程模式运行。\n--name：为容器指定一个名称。\n-p 80:80：将Docker容器的80端口映射到主机的80端口，让你可以通过浏览器访问运行在容器内的 Nginx 服务器。80端口是HTTP服务，443端口是HTTPS服务。\n进入这个 Nginx 容器内部\ndocker exec -it my-nginx bash -i：表示以交互式模式运行容器。\n-t：表示为容器分配一个伪终端。 因此-it表示使用交互式终端，允许在容器内交互式地运行命令。\nbash：表示使用Bash shell。\n了解 Nginx 的目录结构\nNginx 容器的部分目录结构如下图：\n/ ├── etc/ │ └── nginx/ │ ├── nginx.conf │ └── conf.d/ │ ├── default.conf │ └── other.conf ├── var/ │ └── log/ │ └── nginx/ │\t├── access.log │\t└── error.log └── usr/ └── share/ └── nginx/ ├── html/ └── conf/ nginx.conf是 Nginx 主配置文件，用于设置全局的 Nginx 配置。\ndefault.conf是 Nginx 的 server 的配置文件。这个文件中通常包含了 HTTP 或 HTTPS 服务器的基本配置信息，如监听端口、虚拟主机等。\naccess.log是 Nginx 的访问日志。\nerror.log是 Nginx 的错误日志。\n/usr/share/nginx/ 目录用于存放 Nginx 的一些静态文件，我们通常把打包后的网站代码挂载到此处。\n退出容器\n按下ctrl + D或者输入exit 即可退出容器。\n复制容器内部的配置文件到服务器\ndocker cp my-nginx:/etc/nginx/nginx.conf ~/nginx/nginx.conf docker cp my-nginx:/etc/nginx/conf.d ~/nginx/ 这样就不怕自己写的配置文件不标准而导致容器运行失败啦。\n简单分析一下这两个配置文件：\ncd ~ vim nginx/nginx.conf 先看nginx.conf：\nuser nginx; worker_processes auto;\t# 指定 Nginx 使用的工作进程数，auto 表示 Nginx 会自动根据 CPU 核数设置合适的进程数 error_log /var/log/nginx/error.log notice;\t# Nginx 错误日志文件的路径和日志级别，这里的日志级别为 notice，表示只记录警告级别及以上的日志 pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; # 定义访问日志的格式 log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main;\t# 指定访问日志文件的路径和日志格式，日志格式为上面定义的 main 格式 sendfile on;\t# 启用 sendfile 指令，加快文件传输速度 #tcp_nopush on; keepalive_timeout 65;\t# 指定客户端连接保持时间的最大值。 #gzip on; include /etc/nginx/conf.d/*.conf;\t# 加载 /etc/nginx/conf.d/ 目录下的所有以 .conf 结尾的配置文件 } 接着是default.conf：\nserver { listen 80;\t# 监听 IPV4 的80端口 listen [::]:80;\t# 监听 IPV6 的80端口 server_name 111.222.111.222;\t# 这里填入你的服务器地址 #access_log /var/log/nginx/host.access.log main; # location 指令用于匹配请求的 URL 路径，并设置对应的处理方式 # 简单的说就是当有客户端访问 http://111.222.111.222/ 时，Nginx 将会尝试在 # /usr/share/nginx/html 路径下查找 index.html 返回给客户端 location / { root /usr/share/nginx/html;\tindex index.html index.htm; } # error_page 指令定义了当服务器出现 500、502、503、504 错误时的处理方式 error_page 500 502 503 504 /50x.html;\t# 统一请求 /50x.html location = /50x.html {\t# \u0026#39;=\u0026#39;表示精确匹配，后面不可带参数。 root /usr/share/nginx/html; } } 暂停并删除容器\n暂停容器：\ndocker stop my-nginx 删除容器：\ndocker rm my-nginx 第四步：克隆静态博客源码 克隆源码：\ngit clone git@github.com:austin2035/astro-air-blog.git 给你的博客源码改个名：\nmv astro-air-blog ~/blog 进入项目目录：\ncd ~/blog 第五步：打包博客源码 打包项目： npm run build 一定要打包后才再挂载，Nginx 只能解析 html 文件。\n查看打包后的文件：\ncd dist ls 确保目录内存在 index.html 文件。\n第六步：部署网站 先创建一个日志目录：\ncd ~ mkdir nginx/logs 挂载目录并运行容器：\ndocker run \\ -p 80:80 \\ --name my-nginx \\ -v ~/blog/dist:/usr/share/nginx/html \\ -v ~/nginx/nginx.conf:/etc/nginx/nginx.conf \\ -v ~/nginx/conf.d:/etc/nginx/conf.d \\ -v ~/nginx/logs:/var/log/nginx \\ -d nginx 查看容器是否运行成功：\ndocker ps 若有my-nginx 这个镜像表示运行成功，若没有则表示 Docker 运行出错了，检查nginx.conf和default.conf文件语法是否存在错误。\n第七步：测试网站试在浏览器直接访问你的服务器IP，若部署成功你将看到你的网站。\n","permalink":"https://blog.cassdev.com/posts/docker-+-nginx%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/","summary":"\u003ch2 id=\"tags-linux-docker-nginx-server-blog\"\u003etags: [\u0026ldquo;Linux\u0026rdquo;, \u0026ldquo;Docker\u0026rdquo;, \u0026ldquo;Nginx\u0026rdquo;, \u0026ldquo;Server\u0026rdquo;, \u0026ldquo;Blog\u0026rdquo;]\u003c/h2\u003e\u003cp\u003e本文是一个使用 Docker 和 Nginx 部署个人静态博客的指南。通过本指南，您可以快速了解如何使用 Docker 和 Nginx 部署自己的静态博客网站。\u003c/p\u003e\n\u003ch2 id=\"前提\"\u003e前提\u003c/h2\u003e\u003cp\u003e在开始使用本指南之前，请具备以下前提：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e首先你得有个服务器\u003c/li\u003e\n\u003cli\u003e服务器已经安装好Git、Vim等工具\u003c/li\u003e\n\u003cli\u003e一份静态博客源码，本文以 \u003ca href=\"https://github.com/austin2035/astro-air-blog\"\u003eAstro Air Blog\u003c/a\u003e 为例\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"步骤\"\u003e步骤\u003c/h2\u003e\u003ch3 id=\"第一步安装-docker\"\u003e第一步：安装 Docker\u003c/h3\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install docker\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"第二步拉取-nginx-镜像\"\u003e第二步：拉取 Nginx 镜像\u003c/h3\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker pull nginx\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e镜像名后不加版本号表示拉取最新版，若希望拉取指定版本则需在镜像名后加上tag，例如\u003ccode\u003edocker pull nginx:1.16\u003c/code\u003e。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch3 id=\"第三步获取-nginx-的配置文件\"\u003e第三步：获取 Nginx 的配置文件\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e先运行一个不挂载的 Nginx 容器\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker run -d --name my-nginx -p 80:80 nginx\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e-d\u003c/code\u003e：使容器在后台以守护进程模式运行。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e--name\u003c/code\u003e：为容器指定一个名称。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e-p 80:80\u003c/code\u003e：将Docker容器的80端口映射到主机的80端口，让你可以通过浏览器访问运行在容器内的 Nginx 服务器。80端口是HTTP服务，443端口是HTTPS服务。\u003c/p\u003e\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e进入这个 Nginx 容器内部\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker \u003cspan class=\"nb\"\u003eexec\u003c/span\u003e -it my-nginx bash\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e-i\u003c/code\u003e：表示以交互式模式运行容器。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e-t\u003c/code\u003e：表示为容器分配一个伪终端。 因此\u003ccode\u003e-it\u003c/code\u003e表示使用交互式终端，允许在容器内交互式地运行命令。\u003c/p\u003e","title":"Docker + Nginx 部署个人静态博客指南"},{"content":" 是谁还不会Git SSH免密配置？哦，是你🤪\n这是一个简单教程，旨在帮助大家实现免密SSH登录，省去每次输入用户名和密码的烦恼。（是真的烦呐！）\n本教程旨在帮助初学者了解Git免密登录的配置方法，以及介绍HTTPS和SSH协议之间的区别。同时提供具体操作步骤。\nHTTPS和SSH的区别Git支持两种协议：HTTPS和SSH。两种协议各有优缺点：\nHTTPS协议：使用简单，不需要配置SSH密钥，但相对较慢，且不支持Push操作。 SSH协议：速度快，支持Push操作，但需要配置SSH密钥。 2021年8月13日起，Github不再支持密码身份验证。“Support for password authentication was removed on August 13, 2021.“\n因此，如果只是从远程仓库拉取代码，建议使用HTTPS协议；如果需要Push代码到远程仓库，则需要配置SSH密钥，使用SSH协议。\nSSH免密登录配置步骤 由于SSH协议更安全和优雅且支持Push操作，因此推荐大家使用SSH免密登录，以下是配置教程。\n前提先确保你添加远程 Git 远程仓库时使用的是SSH链接，即git remote add时应该使用远程仓库的SSH链接。检查方法：\ngit remote -v 若显示git@github.com:...即为SSH链接，若显示https://...则为HTTPS链接，使用一下命令进行修改：\ngit remote set-url \u0026lt;repo_name\u0026gt; \u0026lt;ssh_url\u0026gt; 当然，也可以用git remote rm命令先删除远程仓库，再用git remote add重新添加。\n步骤 打开终端，输入以下命令生成SSH密钥：\nssh-keygen -t rsa -C \u0026#34;your_email@example.com\u0026#34; 别直接粘贴上去啊喂！改改后面的邮箱。\n按照提示输入密钥保存路径和密码，建议直接回车使用默认值：\nGenerating public/private rsa key pair. Enter file in which to save the key (~/.ssh/id_rsa): Enter passphrase (empty for no passphrase): 也别设置密码啊，不然Push时又要输入你设定的密码，那就不叫免密啦……\n其中~/.ssh/即为你的SSH密钥文件夹的路径。\n找到SSH密钥文件夹，打开刚刚生成的公钥文件id_rsa.pub，复制其全部内容；\n注意：要找公钥文件，公钥文件有.pub后缀。id_rsa.pub为公钥文件，id_rsa为私钥文件。\n在Github上的Settings页面中，点击SSH and GPG keys，然后点击New SSH key；\n输入一个标题，将复制的公钥内容粘贴到Key文本框中，然后点击Add SSH key；\n注意这个配置是全局配置，配置一次就行，不需要每个项目都配置一遍。\n务必记住git clone和git remote add时候都需要使用SSH链接。\n写在最后 虽然网上已经很多比这更优秀的教程了，但因为我总忘记具体操作流程，所以想写下来强化记忆。\n是谁还不会Git SSH免密配置？好吧，不是你👀\n","permalink":"https://blog.cassdev.com/posts/git%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","summary":"\u003cblockquote\u003e\n\u003cp\u003e是谁还不会Git SSH免密配置？哦，是你🤪\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e这是一个简单教程，旨在帮助大家实现免密SSH登录，省去每次输入用户名和密码的烦恼。\u003cdel\u003e（是真的烦呐！）\u003c/del\u003e\u003c/p\u003e\n\u003cp\u003e本教程旨在帮助初学者了解Git免密登录的配置方法，以及介绍HTTPS和SSH协议之间的区别。同时提供具体操作步骤。\u003c/p\u003e\n\u003ch2 id=\"https和ssh的区别\"\u003eHTTPS和SSH的区别\u003c/h2\u003e\u003cp\u003eGit支持两种协议：HTTPS和SSH。两种协议各有优缺点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHTTPS协议：使用简单，不需要配置SSH密钥，但相对较慢，且不支持Push操作。\u003c/li\u003e\n\u003cli\u003eSSH协议：速度快，支持Push操作，但需要配置SSH密钥。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e2021年8月13日起，Github不再支持密码身份验证。“Support for password authentication was removed on August 13, 2021.“\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e因此，如果只是从远程仓库拉取代码，建议使用HTTPS协议；如果需要Push代码到远程仓库，则需要配置SSH密钥，使用SSH协议。\u003c/p\u003e\n\u003ch2 id=\"ssh免密登录配置步骤\"\u003eSSH免密登录配置步骤\u003c/h2\u003e\u003cblockquote\u003e\n\u003cp\u003e由于SSH协议更安全和优雅且支持Push操作，因此推荐大家使用SSH免密登录，以下是配置教程。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch3 id=\"前提\"\u003e前提\u003c/h3\u003e\u003cp\u003e先确保你添加远程 Git 远程仓库时使用的是SSH链接，即\u003ccode\u003egit remote add\u003c/code\u003e时应该使用远程仓库的SSH链接。检查方法：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit remote -v\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e若显示\u003ccode\u003egit@github.com:...\u003c/code\u003e即为SSH链接，若显示\u003ccode\u003ehttps://...\u003c/code\u003e则为HTTPS链接，使用一下命令进行修改：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit remote set-url \u0026lt;repo_name\u0026gt; \u0026lt;ssh_url\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e当然，也可以用\u003ccode\u003egit remote rm\u003c/code\u003e命令先删除远程仓库，再用\u003ccode\u003egit remote add\u003c/code\u003e重新添加。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch3 id=\"步骤\"\u003e步骤\u003c/h3\u003e\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e打开终端，输入以下命令生成SSH密钥：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003essh-keygen -t rsa -C \u003cspan class=\"s2\"\u003e\u0026#34;your_email@example.com\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e别直接粘贴上去啊喂！改改后面的邮箱。\u003c/p\u003e\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e按照提示输入密钥保存路径和密码，建议直接回车使用默认值：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eGenerating public/private rsa key pair.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eEnter file in which to save the key \u003cspan class=\"o\"\u003e(\u003c/span\u003e~/.ssh/id_rsa\u003cspan class=\"o\"\u003e)\u003c/span\u003e: \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eEnter passphrase \u003cspan class=\"o\"\u003e(\u003c/span\u003eempty \u003cspan class=\"k\"\u003efor\u003c/span\u003e no passphrase\u003cspan class=\"o\"\u003e)\u003c/span\u003e: \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e也别设置密码啊，不然Push时又要输入你设定的密码，那就不叫免密啦……\u003c/p\u003e","title":"Git 免密登录配置指南"},{"content":"1. “ ”——准确搜索给关键词加上英文双引号\u0026quot;\u0026quot; 实现准确搜索。\n例如：\u0026ldquo;人工智能算法\u0026rdquo;\n2. 空格+减号——排除关键词在搜索内容后面加上空格和减号排除的指定的关键词。\n例如：Apple -iPhone -iPad\n3. OR——逻辑搜索用大写的OR和空格隔开关键词，使关键词互不干扰。\n例如：百度 OR 谷歌\n4. *——模糊搜索用*代替关键词。\n例如：Study * home\n5. filetype:——搜索指定文件类型在关键词后加上filetype:\u0026lt;文件类型\u0026gt;。\n例如：高等数学 filetype:pdf\n6. site——搜索指定网站内容在关键词后加上site:\u0026lt;指定的网站\u0026gt;。\n例如：后浪 site:bilibili.com\n7. inurl——搜索指定URL内容在关键词后加上inurl:\u0026lt;指定的网站\u0026gt;。\n例如：民法典 inurl:gov.cn\n##8. intitle——搜索指定Tilte内容\n在关键词后加上intitle:\u0026lt;需要筛选的title关键字\u0026gt;。\n例如：machine learning intitle:stanford\n9. define——搜索定义通过define:关键词得到准确定义 eg: define:internet\n例如：define:internet\n","permalink":"https://blog.cassdev.com/posts/google-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","summary":"\u003ch2 id=\"1--准确搜索\"\u003e1. “ ”——准确搜索\u003c/h2\u003e\u003cp\u003e给关键词加上英文双引号\u0026quot;\u0026quot; 实现准确搜索。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e例如：\u0026ldquo;人工智能算法\u0026rdquo;\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"2-空格减号排除关键词\"\u003e2. 空格+减号——排除关键词\u003c/h2\u003e\u003cp\u003e在搜索内容后面加上空格和减号排除的指定的关键词。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e例如：Apple -iPhone -iPad\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"3-or逻辑搜索\"\u003e3. OR——逻辑搜索\u003c/h2\u003e\u003cp\u003e用大写的OR和空格隔开关键词，使关键词互不干扰。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e例如：百度 OR 谷歌\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"4-模糊搜索\"\u003e4. *——模糊搜索\u003c/h2\u003e\u003cp\u003e用*代替关键词。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e例如：Study * home\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"5-filetype搜索指定文件类型\"\u003e5. filetype:——搜索指定文件类型\u003c/h2\u003e\u003cp\u003e在关键词后加上filetype:\u0026lt;文件类型\u0026gt;。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e例如：高等数学 filetype:pdf\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"6-site搜索指定网站内容\"\u003e6. site——搜索指定网站内容\u003c/h2\u003e\u003cp\u003e在关键词后加上site:\u0026lt;指定的网站\u0026gt;。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e例如：后浪 site:bilibili.com\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"7-inurl搜索指定url内容\"\u003e7. inurl——搜索指定URL内容\u003c/h2\u003e\u003cp\u003e在关键词后加上inurl:\u0026lt;指定的网站\u0026gt;。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e例如：民法典 inurl:gov.cn\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e##8. intitle——搜索指定Tilte内容\u003c/p\u003e\n\u003cp\u003e在关键词后加上intitle:\u0026lt;需要筛选的title关键字\u0026gt;。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e例如：machine learning intitle:stanford\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"9-define搜索定义\"\u003e9. define——搜索定义\u003c/h2\u003e\u003cp\u003e通过define:关键词得到准确定义 eg: define:internet\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e例如：define:internet\u003c/p\u003e\u003c/blockquote\u003e","title":"Google 搜索引擎使用技巧"},{"content":"\n该项目提供了一个简单的指南，帮助用户在 NVIDIA Jetson Nano 上正确安装 Azure Kinect DK。\nJetson nano是ARM64架构，而非AMD64架构。所以环境配置起来会和AMD64架构的有所不同。\n前提在开始安装 Azure Kinect DK 之前，请确保您的 Jetson Nano 满足以下要求：\n版本为Ubuntu 18.04 LTS 已安装cURL 不再费文笔说明如何安装上述工具。\n安装步骤第一步：配置微软软件包储存库 系统版本必须为Ubuntu 18.04，其他版本参考Microsoft 产品的 Linux 软件存储库。\n依次运行下列命令：\n添加微软GPG公钥：\ncurl -sSL https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add - 添加微软软件包源：\nsudo apt-add-repository https://packages.microsoft.com/ubuntu/18.04/prod 下载最新软件包列表：\nsudo apt-get update 第二步：安装依赖项 依赖项需要手动安装ARM64版本的。\n安装libk4a\ncurl -O https://packages.microsoft.com/ubuntu/18.04/multiarch/prod/pool/main/libk/libk4a1.4/libk4a1.4_1.4.1_arm64.deb \u0026amp;\u0026amp; sudo dpkg -i libk4a1.4_1.4.1_arm64.deb 安装libk4a-dev\ncurl -O https://packages.microsoft.com/ubuntu/18.04/multiarch/prod/pool/main/libk/libk4a1.4-dev/libk4a1.4-dev_1.4.1_arm64.deb \u0026amp;\u0026amp; sudo dpkg -i libk4a1.4-dev_1.4.1_arm64.deb 第三步：安装 k4a-tools k4a-tools也需要手动安装ARM64版本的。\ncurl -O https://packages.microsoft.com/ubuntu/18.04/multiarch/prod/pool/main/k/k4a-tools/k4a-tools_1.4.1_arm64.deb \u0026amp;\u0026amp; sudo dpkg -i k4a-tools_1.4.1_arm64.deb 第四步：插上 Azure Kinect 设备将 Azure Kinect 插到 Jetson nano 上，注意必须使用支持 USB3.0 的数据线并插到 USB 3.0 的接口上，否则程序会报错。\n第五步：运行 k4a_viewer必须使用sudo运行，否则程序找不到设备。\nsudo k4aviewer ","permalink":"https://blog.cassdev.com/posts/jetson-nano%E5%AE%89%E8%A3%85azure-kinect-dk%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e\u003cimg alt=\"Azure Kinect\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/24/IwUxHR56CdVWjOZ.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e该项目提供了一个简单的指南，帮助用户在 NVIDIA Jetson Nano 上正确安装 Azure Kinect DK。\u003c/p\u003e\n\u003cp\u003eJetson nano是ARM64架构，而非AMD64架构。所以环境配置起来会和AMD64架构的有所不同。\u003c/p\u003e\n\u003ch2 id=\"前提\"\u003e前提\u003c/h2\u003e\u003cp\u003e在开始安装 Azure Kinect DK 之前，请确保您的 Jetson Nano 满足以下要求：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e版本为Ubuntu 18.04 LTS\u003c/li\u003e\n\u003cli\u003e已安装cURL\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e不再费文笔说明如何安装上述工具。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"安装步骤\"\u003e安装步骤\u003c/h2\u003e\u003ch3 id=\"第一步配置微软软件包储存库\"\u003e第一步：配置微软软件包储存库\u003c/h3\u003e\u003cblockquote\u003e\n\u003cp\u003e系统版本必须为Ubuntu 18.04，其他版本参考\u003ca href=\"https://learn.microsoft.com/zh-cn/windows-server/administration/linux-package-repository-for-microsoft-software\"\u003eMicrosoft 产品的 Linux 软件存储库\u003c/a\u003e。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e依次运行下列命令：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e添加微软GPG公钥：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecurl -sSL https://packages.microsoft.com/keys/microsoft.asc \u003cspan class=\"p\"\u003e|\u003c/span\u003e sudo apt-key add -\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e添加微软软件包源：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-add-repository https://packages.microsoft.com/ubuntu/18.04/prod\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e下载最新软件包列表：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get update\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"第二步安装依赖项\"\u003e第二步：安装依赖项\u003c/h3\u003e\u003cblockquote\u003e\n\u003cp\u003e依赖项需要手动安装ARM64版本的。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e安装libk4a\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecurl -O https://packages.microsoft.com/ubuntu/18.04/multiarch/prod/pool/main/libk/libk4a1.4/libk4a1.4_1.4.1_arm64.deb \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e sudo dpkg -i libk4a1.4_1.4.1_arm64.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e安装libk4a-dev\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecurl -O https://packages.microsoft.com/ubuntu/18.04/multiarch/prod/pool/main/libk/libk4a1.4-dev/libk4a1.4-dev_1.4.1_arm64.deb \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e sudo dpkg -i libk4a1.4-dev_1.4.1_arm64.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"第三步安装-k4a-tools\"\u003e第三步：安装 k4a-tools\u003c/h3\u003e\u003cblockquote\u003e\n\u003cp\u003ek4a-tools也需要手动安装ARM64版本的。\u003c/p\u003e","title":"Jetson nano 安装 Azure Kinect DK 指南"},{"content":"Mermaid 是一个可以让你通过代码来绘制流程图、序列图、甘特图等各种图表的工具。\nMermaid 的优势相比于传统的绘图软件，Mermaid 的优势在于：\n代码可复用：你可以将代码保存下来，方便以后进行修改和维护。 易于协作：你可以将代码分享给其他人，让他们也可以轻松地修改和维护图表。 方便集成：你可以将 Mermaid 集成到自己的项目中，方便自己和其他人使用。 Typora 启用 Mermaid不同系统配置方法有些许不同。\nMacOS如果你是MacOS系统，那么只需要简单几步操作就可以在文章中使用 Mermaid 了。具体步骤如下：\n打开 Typora，点击菜单栏中的「偏好设置」按钮。 在「偏好设置」窗口中，点击「Markdown」标签页。 在「Markdown」标签页中，勾选「图标」复选框。 WindowsWindows系统，\nMermaid 语法Mermaid 的语法非常简单，以下是一些常用的语法示例：\n流程图flowchart TD start([开始]) --\u0026gt; input[/输入形参线性表 L/] input --\u0026gt; op1{判断L.list的大小是否为0}; op1 -- 是 --\u0026gt; op2[返回true]; op1 -- 否 --\u0026gt; op3[返回false]; op2 --\u0026gt; Stop([结束]); op3 --\u0026gt; Stop([结束]); flowchart TD start([开始]) --\u0026gt; input[/\u0026#34;输入形参线性表 L\u0026#34;/] input --\u0026gt; op1{\u0026#34;判断 L.list 的\\n大小是否为0\u0026#34;}; op1 -- 是 --\u0026gt; op2[\u0026#34;返回true\u0026#34;]; op1 -- 否 --\u0026gt; op3[\u0026#34;返回false\u0026#34;]; op2 --\u0026gt; Stop([结束]); op3 --\u0026gt; Stop; 序列图sequenceDiagram participant 你 participant 朋友 你-\u0026gt;\u0026gt;朋友: 拨打电话 朋友-\u0026gt;\u0026gt;你: 接听电话 你-\u0026gt;\u0026gt;朋友: 自我介绍 朋友-\u0026gt;\u0026gt;你: 回答并自我介绍 你-\u0026gt;\u0026gt;朋友: 确认收到信息 sequenceDiagram participant 你 participant 朋友 你-\u0026gt;\u0026gt;朋友: 拨打电话 朋友-\u0026gt;\u0026gt;你: 接听电话 你-\u0026gt;\u0026gt;朋友: 自我介绍 朋友-\u0026gt;\u0026gt;你: 回答并自我介绍 你-\u0026gt;\u0026gt;朋友: 确认收到信息 甘特图gantt title 项目计划 dateFormat YYYY-MM-DD section 设计 项目设计 :done, des, 2023-01-14,2023-01-16 section 开发 编码 :active, dev, 2023-01-16, 10d 测试 : test, 2023-01-24, 5d 代码审查 : review, after test, 2d section 发布 部署 : deploy, after review, 2d 发布 : release, after deploy, 1d gantt title 项目计划 dateFormat YYYY-MM-DD section 设计 项目设计 :done, des, 2023-01-14,2023-01-16 section 开发 编码 :active, dev, 2023-01-16, 10d 测试 : test, 2023-01-24, 5d 代码审查 : review, after test, 2d section 发布 部署 : deploy, after review, 2d 发布 : release, after deploy, 1d 更多语法示例可以参考 Mermaid 的官方文档.\nMermaid 在线编辑用这个官方在线编辑器在线解释你的 Mermaid 语法，并提供强大的导出功能，并完全免费。它甚至自带图床！这不香死。\n官网还提供了另一个在线编辑器，相比于上一个编辑器，这个编辑器可以保存的你图表项目。并且即将推出多人协作功能，不过需要收费。具体支持功能以及价格见下图：\n","permalink":"https://blog.cassdev.com/posts/mermaid%E6%8A%9B%E5%BC%83%E7%94%BB%E5%9B%BE%E6%8B%A5%E6%8A%B1%E7%A0%81%E5%9B%BE/","summary":"\u003cp\u003eMermaid 是一个可以让你通过代码来绘制流程图、序列图、甘特图等各种图表的工具。\u003c/p\u003e\n\u003ch2 id=\"mermaid-的优势\"\u003eMermaid 的优势\u003c/h2\u003e\u003cp\u003e相比于传统的绘图软件，Mermaid 的优势在于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e代码可复用：你可以将代码保存下来，方便以后进行修改和维护。\u003c/li\u003e\n\u003cli\u003e易于协作：你可以将代码分享给其他人，让他们也可以轻松地修改和维护图表。\u003c/li\u003e\n\u003cli\u003e方便集成：你可以将 Mermaid 集成到自己的项目中，方便自己和其他人使用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"typora-启用-mermaid\"\u003eTypora 启用 Mermaid\u003c/h2\u003e\u003cp\u003e不同系统配置方法有些许不同。\u003c/p\u003e\n\u003ch3 id=\"macos\"\u003eMacOS\u003c/h3\u003e\u003cp\u003e如果你是MacOS系统，那么只需要简单几步操作就可以在文章中使用 Mermaid 了。具体步骤如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e打开 Typora，点击菜单栏中的「偏好设置」按钮。\u003c/li\u003e\n\u003cli\u003e在「偏好设置」窗口中，点击「Markdown」标签页。\u003c/li\u003e\n\u003cli\u003e在「Markdown」标签页中，勾选「图标」复选框。\n\u003cimg alt=\"Typroa Mermaid\" loading=\"lazy\" src=\"https://s2.loli.net/2023/04/07/FKcixunLrZSYVa4.png\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"windows\"\u003eWindows\u003c/h3\u003e\u003cp\u003eWindows系统，\u003c/p\u003e\n\u003ch2 id=\"mermaid-语法\"\u003eMermaid 语法\u003c/h2\u003e\u003cp\u003eMermaid 的语法非常简单，以下是一些常用的语法示例：\u003c/p\u003e\n\u003ch3 id=\"流程图\"\u003e流程图\u003c/h3\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eflowchart TD\n    start([开始]) --\u0026gt; input[/输入形参线性表 L/]\n    input --\u0026gt; op1{判断L.list的大小是否为0};\n    op1 -- 是 --\u0026gt; op2[返回true];\n    op1 -- 否 --\u0026gt; op3[返回false];\n    op2 --\u0026gt; Stop([结束]);\n    op3 --\u0026gt; Stop([结束]);\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003eflowchart TD\n    start([开始]) --\u0026gt; input[/\u0026#34;输入形参线性表 L\u0026#34;/]\n    input --\u0026gt; op1{\u0026#34;判断 L.list 的\\n大小是否为0\u0026#34;};\n    op1 -- 是 --\u0026gt; op2[\u0026#34;返回true\u0026#34;];\n    op1 -- 否 --\u0026gt; op3[\u0026#34;返回false\u0026#34;];\n    op2 --\u0026gt; Stop([结束]);\n    op3 --\u0026gt; Stop;\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"序列图\"\u003e序列图\u003c/h3\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esequenceDiagram\n  participant 你\n  participant 朋友\n\n  你-\u0026gt;\u0026gt;朋友: 拨打电话\n  朋友-\u0026gt;\u0026gt;你: 接听电话\n  你-\u0026gt;\u0026gt;朋友: 自我介绍\n  朋友-\u0026gt;\u0026gt;你: 回答并自我介绍\n  你-\u0026gt;\u0026gt;朋友: 确认收到信息\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003esequenceDiagram\n  participant 你\n  participant 朋友\n\n  你-\u0026gt;\u0026gt;朋友: 拨打电话\n  朋友-\u0026gt;\u0026gt;你: 接听电话\n  你-\u0026gt;\u0026gt;朋友: 自我介绍\n  朋友-\u0026gt;\u0026gt;你: 回答并自我介绍\n  你-\u0026gt;\u0026gt;朋友: 确认收到信息\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"甘特图\"\u003e甘特图\u003c/h3\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egantt\n    title 项目计划\n    dateFormat  YYYY-MM-DD\n    section 设计\n    项目设计     :done,    des, 2023-01-14,2023-01-16\n    section 开发\n    编码         :active,  dev, 2023-01-16, 10d\n    测试         :         test, 2023-01-24, 5d\n    代码审查     :         review, after test, 2d\n    section 发布\n    部署         :         deploy, after review, 2d\n    发布         :         release, after deploy, 1d\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003egantt\n    title 项目计划\n    dateFormat  YYYY-MM-DD\n    section 设计\n    项目设计     :done,    des, 2023-01-14,2023-01-16\n    section 开发\n    编码         :active,  dev, 2023-01-16, 10d\n    测试         :         test, 2023-01-24, 5d\n    代码审查     :         review, after test, 2d\n    section 发布\n    部署         :         deploy, after review, 2d\n    发布         :         release, after deploy, 1d\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e更多语法示例可以参考 Mermaid 的\u003ca href=\"https://mermaid-js.github.io/mermaid/#/\"\u003e官方文档\u003c/a\u003e.\u003c/p\u003e","title":"Jetson nano 安装 Azure Kinect DK 指南"},{"content":"本指南帮助 ARM64 架构的 Jetson Nano 安装 PCL（点云库）。\n安装步骤第一步：安装依赖在终端中运行以下命令，安装 PCL 所需的依赖：\nsudo apt-get update sudo apt-get install git build-essential linux-libc-dev sudo apt-get install cmake cmake-gui sudo apt-get install libusb-1.0-0-dev libusb-dev libudev-dev sudo apt-get install mpi-default-dev openmpi-bin openmpi-common sudo apt-get install libpcap-dev sudo apt-get install libflann1.9 libflann-dev sudo apt-get install libeigen3-dev sudo apt-get install libboost-all-dev sudo apt-get install vtk6 libvtk6.3 libvtk6-dev libvtk6.3-qt libvtk6-qt-dev sudo apt-get install libqhull-dev libgtest-dev sudo apt-get install freeglut3-dev pkg-config sudo apt-get install libxmu-dev libxi-dev sudo apt-get install mono-complete sudo apt-get install libopenni-dev libopenni2-dev sudo apt install build-essential libssl-dev 第二步：安装Eigen库先卸载Eigen库\nsudo updatedb locate eigen3 sudo rm -rf /usr/include/eigen3 /usr/lib/cmake/eigen3 /usr/share/doc/libeigen3- dev /usr/share/pkgconfig/eigen3.pc /var/lib/dpkg/info/libeigen3-dev.list /var/lib/dpkg/info/libeigen3-dev.md5sums 安装：\nwget https://gitlab.com/libeigen/eigen/-/archive/3.3.7/eigen-3.3.7.tar.gz sudo tar -xvf eigen-3.3.7.tar.gz cd eigen-3.3.7 mkdir build \u0026amp;\u0026amp; cd build sudo cmake .. sudo make install sudo cp -r /usr/local/include/eigen3/Eigen /usr/local/include 第三步：下载 PCL 源码在终端中运行以下命令，下载 PCL 源码：\ngit clone https://github.com/PointCloudLibrary/pcl.git 第四步：编译 PCL 源码进入 PCL 源码目录，先切换到1.9.1版本：\ncd pcl git checkout pcl-1.9.1 创建build文件夹：\nmkdir build \u0026amp;\u0026amp; cd build 开始编译：\ncmake -DCMAKE_BUILD_TYPE=None \\ -DCMAKE_INSTALL_PREFIX=/usr/local \\ -DBUILD_GPU=ON \\ -DBUILD_CUDA=ON \\ -DBUILD_apps=ON \\ -DBUILD_examples=ON .. make 编译过程可能需要较长时间，请耐心等待。\nJetson Nano 编译 PCL 真的很慢。\n过程中可能遇到一些错误，解决方法见报错解决 。\n第五步：安装 PCLsudo make install 第六步：测试 PCL 安装是否成功在终端中运行以下命令，测试 PCL 是否安装成功：\ncd ../test ./all_tests 如果所有测试都通过，说明 PCL 安装成功。\n报错解决internal compiler error: Segmentation fault (program cc1plus)\n此错误是 stack size 太小导致的。\n使用ulimit -a查看系统的限制参数。\n解决方法：增加 stack size 的大小即可。\nulimit -s 102400 namespace “thrust” has no member “device_malloc” 完蛋，报错图片没保存 :( 大家自行脑补。\n此错误是point_cloud.h文件缺少头文件导致的。\n解决方法：找到namespace “thrust” has no member “device_malloc”这句话前面的文件，使用vi或vim打开编辑，在顶部添加一句#include \u0026lt;thrust/device_malloc.h\u0026gt;即可。\nPax assembly aborted due to errors\n此错误是由于PTX ISA版本6.4不支持sm_70及更高版本的目标。需要将CUDA_ARCH_BIN cmake变量限制为低于7.0的架构。\nvim ../CMakeList.txt 添加上set(CUDA_ARCH_BIN \u0026quot;6.1\u0026quot;)即可。\n这个错误在网上找了一圈没找到解决方法，最后还是 New Bing 救了我。\n","permalink":"https://blog.cassdev.com/posts/jetson-nano-%E5%AE%89%E8%A3%85-pcl-%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e本指南帮助 ARM64 架构的 Jetson Nano 安装 PCL（点云库）。\u003c/p\u003e\n\u003ch2 id=\"安装步骤\"\u003e安装步骤\u003c/h2\u003e\u003ch3 id=\"第一步安装依赖\"\u003e第一步：安装依赖\u003c/h3\u003e\u003cp\u003e在终端中运行以下命令，安装 PCL 所需的依赖：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get update\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install git build-essential linux-libc-dev\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install cmake cmake-gui\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libusb-1.0-0-dev libusb-dev libudev-dev\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install mpi-default-dev openmpi-bin openmpi-common\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libpcap-dev\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libflann1.9 libflann-dev\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libeigen3-dev\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libboost-all-dev\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install vtk6 libvtk6.3 libvtk6-dev libvtk6.3-qt libvtk6-qt-dev\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libqhull-dev libgtest-dev\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install freeglut3-dev pkg-config\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libxmu-dev libxi-dev\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install mono-complete\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libopenni-dev libopenni2-dev\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install build-essential libssl-dev\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"第二步安装eigen库\"\u003e第二步：安装Eigen库\u003c/h3\u003e\u003cp\u003e先卸载Eigen库\u003c/p\u003e","title":"Jetson nano 安装 PCL 指南"},{"content":"\n本文是一个简单易用的Ubuntu安装OpenCV的指南，帮助用户轻松完成OpenCV的安装和配置。\n安装步骤第一步：安装依赖项sudo apt-get install cmake git build-essential libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 一口气全安装。\n###第二步：下载OpenCV源代码\nGitHub下载：\n切换到用户目录（也可以选择其他文件夹，本文以用户目录~/为例）： cd ~ 下载源码： git clone https://github.com/opencv/opencv.git cd opencv 可以根据需要替换为其他版本号，建议使用最新版： git checkout 4.7.0 OpenCV官网下载：\n若Git速度慢，也可以选择在OpenCV官网下载源码压缩包： 下载完成后将压缩包移到用户目录~/文件夹下，解压文件：\nunzip -q opencv-4.7.0.zip cd opencv-4.7.0 注意，不同版本的文件名不同。\n第三步：编译和安装OpenCV 新建并进入build文件夹：\nmkdir build \u0026amp;\u0026amp; cd build 编译OpenCV：\ncmake .. make -j8 安装OpenCV：\nsudo make install 第四步：配置OpenCV 获取lib文件夹路径：\ncd lib \u0026amp;\u0026amp; pwd 复制输出的路径 。\n修改配置文件：\n将刚刚复制的路径粘贴在引号之间。\nsudo echo \u0026#39;include lib文件夹路径\u0026#39; \u0026gt;\u0026gt; /etc/ld.so.conf 更新配置文件：\nsudo ldconfig 第五步：验证OpenCV 查看版本号：\npkg-config --modversion opencv4 查看libs库：\npkg-config --libs opencv4 如果能够输出OpenCV版本号和libs库，则表明安装成功。\n测试程序 进入测试样例文件夹：\ncd ~/opencv-4.7.0/samples/cpp/example_cmake 依次执行以下命令：\nmkdir build \u0026amp;\u0026amp; cd build cmake .. make 运行程序：\n./opencv_example 正常运行时显示摄像头画面，窗口左上角显示Hello OpenCV。\n","permalink":"https://blog.cassdev.com/posts/ubuntu%E5%AE%89%E8%A3%85opencv%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e\u003cimg alt=\"OpenCV\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/16/HsmExtPf2vRegYG.png\"\u003e\u003c/p\u003e\n\u003cp\u003e本文是一个简单易用的Ubuntu安装OpenCV的指南，帮助用户轻松完成OpenCV的安装和配置。\u003c/p\u003e\n\u003ch2 id=\"安装步骤\"\u003e安装步骤\u003c/h2\u003e\u003ch3 id=\"第一步安装依赖项\"\u003e第一步：安装依赖项\u003c/h3\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install cmake git build-essential libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e一口气全安装。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e###第二步：下载OpenCV源代码\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGitHub下载：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e切换到用户目录（也可以选择其他文件夹，本文以用户目录\u003ccode\u003e~/\u003c/code\u003e为例）：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e下载源码：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit clone https://github.com/opencv/opencv.git\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e opencv\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e可以根据需要替换为其他版本号，建议使用最新版：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit checkout 4.7.0\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOpenCV官网下载：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e若Git速度慢，也可以选择在\u003ca href=\"https://opencv.org/releases/\"\u003eOpenCV官网\u003c/a\u003e下载源码压缩包：\n\u003cimg alt=\"OpenCV Releases\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/16/xP4Ve5OW63w2DsU.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e下载完成后将压缩包移到用户目录\u003ccode\u003e~/\u003c/code\u003e文件夹下，解压文件：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eunzip -q opencv-4.7.0.zip\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e opencv-4.7.0\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e注意，不同版本的文件名不同。\u003c/p\u003e\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"第三步编译和安装opencv\"\u003e第三步：编译和安装OpenCV\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e新建并进入\u003ccode\u003ebuild\u003c/code\u003e文件夹：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emkdir build \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e build\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e编译OpenCV：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecmake ..\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emake -j8\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e安装OpenCV：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo make install\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"第四步配置opencv\"\u003e第四步：配置OpenCV\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e获取\u003ccode\u003elib\u003c/code\u003e文件夹路径：\u003c/p\u003e","title":"Ubuntu 安装 OpenCV 指南"},{"content":"在 Ubuntu 中安装软件包时，有时会遇到 “The following packages have unmet dependencies” 的错误，这通常是由于缺少软件包的依赖项和软件包冲突引起的。\n解决方法逐个安装缺少的依赖包，直到提示删除冲突的软件包并继续安装。\n示例例如在安装libvtk7.1-qt时提示如下图所示：\n执行命令：\nsudo apt-get install libvtk7.1:amd64 注意：包名要完整，libvtk7.1:amd64不能少了:amd64\n再次报错：\n继续安装：\nsudo apt-get install libhdf5-openmpi-100:amd64 再次报错：\n继续安装：\nsudo apt-get install libopenmpi2:amd64 又双叒叕报错：\n继续安装：\nsudo apt-get install libhwloc-plugins:amd64 直到提示The following packages will be REMOVED：\n直接回车删除冲突软件包并继续安装即可。\n最后重新安装libvtk7.1：\nsudo apt-get install libvtk7.1-qt ","permalink":"https://blog.cassdev.com/posts/ubuntu%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%97%B6%E9%81%87%E5%88%B0unmet-dependencies%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","summary":"\u003cp\u003e在 Ubuntu 中安装软件包时，有时会遇到 “The following packages have unmet dependencies” 的错误，这通常是由于缺少软件包的依赖项和软件包冲突引起的。\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\u003cp\u003e逐个安装缺少的依赖包，直到提示删除冲突的软件包并继续安装。\u003c/p\u003e\n\u003ch3 id=\"示例\"\u003e示例\u003c/h3\u003e\u003cp\u003e例如在安装\u003ccode\u003elibvtk7.1-qt\u003c/code\u003e时提示如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"install libvtk7.1-qt\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/18/EyZJSiPqD1G39tb.png\"\u003e\u003c/p\u003e\n\u003cp\u003e执行命令：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libvtk7.1:amd64\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e注意：包名要完整，libvtk7.1:amd64不能少了:amd64\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e再次报错：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"install libvtk7.1:amd64\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/18/YxH2EDdRI9vSM61.png\"\u003e\u003c/p\u003e\n\u003cp\u003e继续安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libhdf5-openmpi-100:amd64\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e再次报错：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"install libhdf5-openmpi-100:amd64\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/18/eFDxj1bpiwK4JTG.png\"\u003e\u003c/p\u003e\n\u003cp\u003e继续安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libopenmpi2:amd64\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e又双叒叕报错：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"install libopenmpi2:amd64\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/18/95FMZPXOfKVmS3N.png\"\u003e\u003c/p\u003e\n\u003cp\u003e继续安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libhwloc-plugins:amd64\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e直到提示The following packages will be REMOVED：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"install libhwloc-plugins:amd64\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/18/ZPAuxI5JHWQyLq7.png\"\u003e\u003c/p\u003e\n\u003cp\u003e直接回车删除冲突软件包并继续安装即可。\u003c/p\u003e\n\u003cp\u003e最后重新安装libvtk7.1：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libvtk7.1-qt\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Ubuntu 安装软件包时遇到 unmet dependencies 的解决方法"},{"content":"\n在使用 Ubuntu 系统的过程中，我们常常需要使用 apt 命令来安装、升级和删除软件包。其中，apt autoremove 命令可以自动删除无用的依赖包，以释放硬盘空间。然而，有时候我们会不小心误删了一些必要的依赖包，导致某些程序无法正常运行。\n方法一：手动查看历史记录（推荐） 查看APT历史日志\nsudo vim /var/log/apt/history.log 直接输入大写G，跳转到最后一行，找到相应时间的Remove内容。\n若删除的包较少可以逐个apt install。若包较多可以使用正则表达式，具体操作如下。\n复制所有被删除的包名\n如果你的VIM开启了行号显示，请先临时禁用行号，目的是避免复制到多余的空格。\n禁用行号，在命令模式下输入以下命令：\n:set nonumber 先复制你所有的删除的包，即Remove后的内容。\n开启行号：\n:set number 输入:q退出VIM。\n利用正则表达式处理包名\n执行以下命令，用正则表达式删去版本信息和逗号：\necho \u0026#34;粘贴在这\u0026#34; | sed \u0026#39;s/([^()]*)[,]*//g\u0026#39; 复制输出的内容。\n执行安装命令\n一口气全安装即可：\nsudo apt install \u0026#34;粘贴在这\u0026#34; 方法二：使用 aptitude 进行恢复aptitude 是一款强大的包管理器，它可以自动解决依赖关系，并且可以清晰地显示出哪些包被删除、哪些包被保留。因此，我们可以使用 aptitude 来恢复误删的依赖包。\n首先，我们需要安装 aptitude：\nsudo apt-get install aptitude 然后，使用以下命令来查看被删除的软件包：\nsudo aptitude search \u0026#39;~c\u0026#39; 接下来，使用以下命令来恢复被删除的软件包：\nsudo aptitude install \u0026lt;package-name\u0026gt; ","permalink":"https://blog.cassdev.com/posts/apt-autoremove-%E8%AF%AF%E5%88%A0%E4%BE%9D%E8%B5%96%E5%8C%85%E5%90%8E%E8%87%AA%E6%95%91%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e\u003cimg alt=\"Linux APT\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/24/SnH3LoVEqXbgalP.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e在使用 Ubuntu 系统的过程中，我们常常需要使用 apt 命令来安装、升级和删除软件包。其中，apt autoremove 命令可以自动删除无用的依赖包，以释放硬盘空间。然而，有时候我们会不小心误删了一些必要的依赖包，导致某些程序无法正常运行。\u003c/p\u003e\n\u003ch2 id=\"方法一手动查看历史记录推荐\"\u003e方法一：手动查看历史记录（推荐）\u003c/h2\u003e\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e查看APT历史日志\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo vim /var/log/apt/history.log\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e直接输入大写\u003ccode\u003eG\u003c/code\u003e，跳转到最后一行，找到相应时间的Remove内容。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"APT histroy log\" loading=\"lazy\" src=\"https://s2.loli.net/2023/03/23/5tGMYikenKFyHhr.png\"\u003e\u003c/p\u003e\n\u003cp\u003e若删除的包较少可以逐个\u003ccode\u003eapt install\u003c/code\u003e。若包较多可以使用正则表达式，具体操作如下。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e复制所有被删除的包名\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果你的VIM开启了行号显示，请先临时禁用行号，目的是避免复制到多余的空格。\u003c/p\u003e\n\u003cp\u003e禁用行号，在命令模式下输入以下命令：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:set nonumber\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e先复制你所有的删除的包，即Remove后的内容。\u003c/p\u003e\n\u003cp\u003e开启行号：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:set number\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e输入\u003ccode\u003e:q\u003c/code\u003e退出VIM。\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e\n\u003cp\u003e利用正则表达式处理包名\u003c/p\u003e\n\u003cp\u003e执行以下命令，用正则表达式删去版本信息和逗号：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;粘贴在这\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e sed \u003cspan class=\"s1\"\u003e\u0026#39;s/([^()]*)[,]*//g\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e复制输出的内容。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e执行安装命令\u003c/p\u003e\n\u003cp\u003e一口气全安装即可：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install \u003cspan class=\"s2\"\u003e\u0026#34;粘贴在这\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"方法二使用-aptitude-进行恢复\"\u003e方法二：使用 aptitude 进行恢复\u003c/h2\u003e\u003cp\u003eaptitude 是一款强大的包管理器，它可以自动解决依赖关系，并且可以清晰地显示出哪些包被删除、哪些包被保留。因此，我们可以使用 aptitude 来恢复误删的依赖包。\u003c/p\u003e\n\u003cp\u003e首先，我们需要安装 aptitude：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo apt-get install aptitude\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e然后，使用以下命令来查看被删除的软件包：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo aptitude search \u0026#39;~c\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e接下来，使用以下命令来恢复被删除的软件包：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo aptitude install \u0026lt;package-name\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e","title":"apt autoremove 误删依赖包后自救指南"},{"content":"tags: [\u0026ldquo;Homepage\u0026rdquo;, \u0026ldquo;Blog\u0026rdquo;, \u0026ldquo;Open Source\u0026rdquo;, \u0026ldquo;Go\u0026rdquo;, \u0026ldquo;WeChat\u0026rdquo;, \u0026ldquo;GitHub\u0026rdquo;]\n","permalink":"https://blog.cassdev.com/posts/%E4%B8%BB%E9%A1%B5/","summary":"\u003cp\u003etags: [\u0026ldquo;Homepage\u0026rdquo;, \u0026ldquo;Blog\u0026rdquo;, \u0026ldquo;Open Source\u0026rdquo;, \u0026ldquo;Go\u0026rdquo;, \u0026ldquo;WeChat\u0026rdquo;, \u0026ldquo;GitHub\u0026rdquo;]\u003c/p\u003e","title":""},{"content":"技术相关Golang 代码耦合与内聚分析这篇文章是我让Gemini Deep Research生成的，前面写的有些啰嗦，整体看完后依然有些收获。一个工程代码做到“高内聚低耦合”其实只要做好“高内聚”，“低耦合”是其自然结果。想做到“高内聚”的最简单方法，就是坚持遵循“单一职责”原则。\n如何判断代码的耦合程度？可以从函数是否方便进行单元测试的方向进行思考判断。要充分利用Go的Interface，鸭子类型的特性让Go语言天生就能很好的做到“低耦合”。\n依赖注入原则，一句话概述就是：让函数的依赖都通过参数传入，而不是在函数内部创建。了解到了 Google Wire 这个自动 DI（Dependency Injection）的工具。\n上面都是从代码层面，也就是偏微观的视角看这个问题。除此之外，也要考虑项目宏观上看待问题，其中之一就是包结构，应该按功能（领域）划分包，才能使得不同功能之间的耦合被最小化。\n文章最后提及了终极解耦方式：事件驱动架构。此方面仍有待进一步学习。\nTo myself： 未来还得加强对 Interface 的了解和学习。\nIncreasing Cohesion in Go with Generic Decorators读完了这篇标题名为《使用通用装饰器增强 Go 语言的内聚力》文章，也仔细看了一下仓库里的示例代码，确实是一层比一层内聚度更高了，函数职责更明确，复用性也高了。其实这里说的装饰器（@decorator）和Python中的一个原理，使用外层函数包裹内层函数，外层函数的代码执行完后就会立即执行内层函数的代码，不过这在Go语言中实现起来确实很难绷，有种写Java的代码的既视感 （又臭又长） 。而且阅读起来跳跃很大，需要在多个装饰器文件直接反复横跳，所以这种设计模式在生产环境的被接受度还是毁誉参半。\n话又说回来，对于业务上那些通用的代码块，例如前置校验、后置Trace、耗时记录等等情况，都是可以被类似装饰器这种设计模式优雅处理的。可以考虑使用中间件模式、AOP等阅读更友好的设计方法。\n","permalink":"https://blog.cassdev.com/mind-space/","summary":"\u003ch2 id=\"技术相关\"\u003e技术相关\u003c/h2\u003e\u003ch3 id=\"golang-代码耦合与内聚分析\"\u003e\u003ca href=\"https://docs.google.com/document/d/15Zc0XVxfYVRQ8aAAu4-50mANor1booFaqT5SZykJSv4/edit?tab=t.0\"\u003eGolang 代码耦合与内聚分析\u003c/a\u003e\u003c/h3\u003e\u003cp\u003e这篇文章是我让Gemini Deep Research生成的，前面写的有些啰嗦，整体看完后依然有些收获。一个工程代码做到“高内聚低耦合”其实\u003cstrong\u003e只要做好“高\u003cstrong\u003e\u003cstrong\u003e内聚\u003c/strong\u003e\u003c/strong\u003e”，“低\u003cstrong\u003e\u003cstrong\u003e耦合\u003c/strong\u003e\u003c/strong\u003e”是其自然结果\u003c/strong\u003e。想做到“高内聚”的最简单方法，就是坚持遵循“单一职责”原则。\u003c/p\u003e\n\u003cp\u003e如何判断代码的耦合程度？可以从函数是否方便进行单元测试的方向进行思考判断。要充分利用Go的Interface，鸭子类型的特性让Go语言天生就能很好的做到“低耦合”。\u003c/p\u003e\n\u003cp\u003e依赖注入原则，一句话概述就是：让函数的依赖都通过参数传入，而不是在函数内部创建。了解到了 Google Wire 这个自动 DI（Dependency Injection）的工具。\u003c/p\u003e\n\u003cp\u003e上面都是从代码层面，也就是偏微观的视角看这个问题。除此之外，也要考虑项目宏观上看待问题，其中之一就是包结构，应该\u003cstrong\u003e按功能（领域）划分包\u003c/strong\u003e，才能使得不同功能之间的耦合被最小化。\u003c/p\u003e\n\u003cp\u003e文章最后提及了\u003cstrong\u003e终极\u003cstrong\u003e\u003cstrong\u003e解耦\u003c/strong\u003e\u003c/strong\u003e方式：事件驱动架构\u003c/strong\u003e。此方面仍有待进一步学习。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eTo myself：\u003c/strong\u003e 未来还得加强对 Interface 的了解和学习。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch3 id=\"increasing-cohesion-in-go-with-generic-decorators\"\u003e\u003ca href=\"https://threedots.tech/post/increasing-cohesion-in-go-with-generic-decorators/\"\u003eIncreasing Cohesion in Go with Generic Decorators\u003c/a\u003e\u003c/h3\u003e\u003cp\u003e读完了这篇标题名为《使用通用装饰器增强 Go 语言的内聚力》文章，也仔细看了一下仓库里的示例代码，确实是一层比一层内聚度更高了，函数职责更明确，复用性也高了。其实这里说的装饰器（@decorator）和Python中的一个原理，使用外层函数包裹内层函数，外层函数的代码执行完后就会立即执行内层函数的代码，不过这在Go语言中实现起来确实很难绷，有种写Java的代码的既视感 \u003cdel\u003e（又臭又长）\u003c/del\u003e 。而且阅读起来跳跃很大，需要在多个装饰器文件直接反复横跳，所以这种设计模式在生产环境的被接受度还是毁誉参半。\u003c/p\u003e\n\u003cp\u003e话又说回来，对于业务上那些通用的代码块，例如前置校验、后置Trace、耗时记录等等情况，都是可以被类似装饰器这种设计模式优雅处理的。可以考虑使用中间件模式、AOP等阅读更友好的设计方法。\u003c/p\u003e","title":"Mind Space"},{"content":"","permalink":"https://blog.cassdev.com/friends/","summary":"","title":"友情链接"}]