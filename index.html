<!doctype html><html lang=zh dir=auto><head><meta name=generator content="Hugo 0.148.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cassius0924 的博客</title><meta name=description content><meta name=author content><link rel=canonical href=https://blog.cassdev.com/><link crossorigin=anonymous href=/assets/css/stylesheet.4f5249ac184c033613d94c5267209e90161d3a93365c2feb0ad3960a4bbb6393.css integrity="sha256-T1JJrBhMAzYT2UxSZyCekBYdOpM2XC/rCtOWCku7Y5M=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cassdev.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cassdev.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cassdev.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cassdev.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.cassdev.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.cassdev.com/index.xml><link rel=alternate type=application/json href=https://blog.cassdev.com/index.json><link rel=alternate hreflang=zh href=https://blog.cassdev.com/><link rel=alternate hreflang=en href=https://blog.cassdev.com/en/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.cassdev.com/"><meta property="og:site_name" content="Cassius0924 的博客"><meta property="og:title" content="Cassius0924 的博客"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cassius0924 的博客"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Cassius0924 的博客","url":"https://blog.cassdev.com/","description":"","logo":"https://blog.cassdev.com/favicon.ico","sameAs":["https://github.com/Cassius0924","https://space.bilibili.com/12873865","mailto:cassius0924@qq.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cassdev.com/ accesskey=h title="Cassius0924 的博客 (Alt + H)">Cassius0924 的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.cassdev.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://blog.cassdev.com/ title="Cassius0924 的博客"><span class=active>首页</span></a></li><li><a href=https://blog.cassdev.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.cassdev.com/mind-space/ title=思维空间><span>思维空间</span></a></li><li><a href=https://blog.cassdev.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cassdev.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cassdev.com/friends/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>欢迎 ：）</h1></header><div class=entry-content>👋 欢迎来到我的技术博客！<br>我是 Cassius0924，目前在字节跳动担任 Golang 开发工程师。<br>我热衷于开源项目和新技术的探索。<br>在这里我分享关于编程、技术趋势和开发经验的思考。</div><footer class=entry-footer><div class=social-icons><a href=https://github.com/Cassius0924 target=_blank rel="noopener noreferrer me" title="Follow Me on GitHub"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://space.bilibili.com/12873865 target=_blank rel="noopener noreferrer me" title="Watch My Videos on Bilibili"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><rect x="1.3333" y="6" width="21.333" height="15.333" rx="4" ry="4"/><path d="m8 12.4v1.2"/><path d="m16 12.4v1.2"/><path d="m5.8853 2.6667L8.552 5.3334"/><path d="m18.115 2.6667-2.6667 2.6667"/></svg>
</a><a href=mailto:cassius0924@qq.com target=_blank rel="noopener noreferrer me" title="Contact Me via Email"><svg viewBox="0 0 24 21" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div></footer></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LLM 参数之 Response Format</h2></header><div class=entry-content><p>如果想让 LLM 输出 JSON 格式的内容，大家第一反应会是什么？可能大多数人和我一样，直接在提示词中写上"请输出 JSON 格式的内容，格式为 { “key”: “value” }"。但其实，这种方式并不是最优的。
从之前我们也了解到了，LLM 的输出是一个概率性的文本补全器。单纯依靠提示词工程来控制 LLM 的输出格式并不可靠。用自然语言去描述一个复杂的 JSON 结构本就不易，再加上当提示词很长时，LLM 的注意力可能会分散，这些因素都容易导致它输出不符合预期的格式，甚至根本不输出 JSON。
具体来说，这种方式可能会遇到以下三个主要问题：
混入无关文本：模型可能在 JSON 对象前后添加对话式的"口水话"，如"好的，这是您要的 JSON：…"，这给后续的程序化解析带来了困难。
结构性错误：生成的 JSON 可能存在语法错误，例如缺少逗号、括号不匹配或引号使用不当，导致解析失败。
内容幻觉：模型可能"幻觉"出指令中未要求的字段，或遗漏必要的字段，破坏了数据模式的一致性。
让 LLM 生成符合预期的 JSON 格式内容的最佳实践是使用 response_format 参数。这个参数允许我们直接指定输出的格式，确保 LLM 生成的内容符合预期的结构和语法。
Response Format 参数response_format 参数在绝大多数现代 LLM API 中都可用，允许开发者指定模型输出的格式。
DeepSeek API Response Format
OpenAI API Response Format
DouBao API Response Format
通过这个参数，我们可以明确要求 LLM 生成特定格式的内容，如 JSON 对象、纯文本或符合 JSON Schema 的数据结构。
response_format 参数支持以下三个模式：
模式 描述 备注 text 生成纯文本内容。适用于需要自然语言回复的场景。 默认模式，不会对输出格式进行约束。 json_object 生成 JSON 对象。适用于需要结构化数据的场景。 早期的 JSON 模式，只能保证输出为 JSON 格式，但不能 JSON 结构符合预期 json_schema 生成符合指定 JSON Schema 的 JSON 对象。适用于需要严格数据格式的场景。 结构化输出模式，这是官方推荐的模式，可以确保输出的 JSON 符合预定义的结构和类型约束。 使用 json_schema 模式时，需编写符合 JSON Schema 规范的模式定义，点击即刻学习 JSON Schema :)
...</p></div><footer class=entry-footer><span title='2025-07-29 00:00:00 +0000 UTC'>2025年07月29日</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to LLM 参数之 Response Format" href=https://blog.cassdev.com/posts/llm-param-response-format/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://s2.loli.net/2025/03/16/mQydfgXDYCuKPLo.png alt="Textmate 语法高亮规则运行机制"></figure><header class=entry-header><h2 class=entry-hint-parent>浅析 Textmate 语法高亮规则运行机制</h2></header><div class=entry-content><p>1. 语法高亮简介语法高亮是指在IDE或编辑器中，对文本进行分词，即将文本拆解为 Token（标记），每个 Token 都有对应的名称（作用域）进行标记。再配合主题样式规则，对不同名称的 Token 的进行主题化，以提高代码的可读性。
程序员离不开语法高亮，就像作家离不开标点符号一样。（你可以代入一下使用 txt 文本编辑器写代码的场景）
语法高亮由两个部分组成：
分词（Tokenization）：将文本拆解为一系列 Token。 主题化（Theming）：对 Token 进行样式渲染，如字体颜色、背景色、加粗等。 我们以 JSON 的语法为例，简单介绍一下语法高亮的过程。
首先分词引擎会对 JSON 文本进行分词，下图是将 JSON 文本进行分词后的结果，其中每个矩形所包括的文本都是一个 Token，每个 Token 都有一个作用域名称，例如 null 对应的是 constant.language.json 作用域。
然后主题化引擎会根据 Token 的作用域名称，对 Token 进行样式渲染，例如将 constant.language.json 作用域映射为蓝色不加粗字体。那么 null 就会被渲染为蓝色不加粗字体。
2. 分词的实现方式目前主流的分词实现方式大致有有以下三种：
基于正则表达式的分词：Textmate 基于词法分析的分词：Highlight.js 基于语法树的分词：Tree-sitter (如果有其他，欢迎补充) 本文只讨论 Textmate 的语法高亮规则编写。
Textmate 原是 MacOS 下的一款文本编辑器，其语法高亮规则是基于正则表达式的，但由于其规则简单易懂，且支持多种语言，因此被广泛应用于各种编辑器和IDE中，如 VSCode、Sublime Text 等。JetBrains 的 IDE 也集成了 Textmate Bundle 插件，可以直接导入 Textmate 的语法高亮规则。
...</p></div><footer class=entry-footer><span title='2025-07-20 15:47:58 +0800 +0800'>2025年07月20日</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 浅析 Textmate 语法高亮规则运行机制" href=https://blog.cassdev.com/posts/%E6%B5%85%E6%9E%90-textmate-%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E8%A7%84%E5%88%99%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Vim 技能补全计划</h2></header><div class=entry-content><p>适合已经熟悉 Vim 基础操作，希望提高编辑技能的开发者的实用技巧集合</p></div><footer class=entry-footer><span title='2025-07-19 00:00:00 +0000 UTC'>2025年07月19日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Vim 技能补全计划" href=https://blog.cassdev.com/posts/vim-skill-completion-plan/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Socket 编程之 epoll 源码分析学习笔记</h2></header><div class=entry-content><p>本文基于 Linux 6.9 内核源码进行分析。
几个数据结构
eventpoll这是 epoll 的主要数据结构，它用于存储 epoll 的相关信息，包括等待队列、就绪队列、红黑树等。
struct eventpoll { wait_queue_head_t wq; // epoll 的等待队列：用于存储等待的进程/线程，指向等待队列头 wait_queue_head_t poll_wait;// 这个 poll_wait 等待队列只有在 epoll 嵌套的情况下才会用到 struct list_head rdllist; // 就绪队列：用于存储就绪的 fd，指向就绪队列头 struct rb_root_cached rbr; // 红黑树：用于存储所有的 fd，指向红黑树根节点 struct wakeup_source *ws; // 一个唤醒源，用于唤醒进程 }; epitemepitem 的作用是将 fd、就绪队列、红黑树节点等信息封装在一起。
struct epitem { union { struct rb_node rbn; // 红黑树节点，用于存储 fd，指向红黑树节点 struct rcu_head rcu; // 用于释放 epitem }; struct list_head rdllink; // 就绪队列节点，用于存储就绪的 fd，指向就绪队列节点 struct eventpoll *ep; // 指向 eventpoll struct epoll_filefd ffd; // epoll 文件描述符 struct wakeup_source *ws; // 一个唤醒源，用于唤醒进程 struct epoll_event event; // 监听的事件 }; ep_pqueue给 poll 队列封装的结构体，用于存储 poll_table 和 epitem。
...</p></div><footer class=entry-footer><span title='2024-06-30 15:31:40 +0800 +0800'>2024年06月30日</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to Socket 编程之 epoll 源码分析学习笔记" href=https://blog.cassdev.com/posts/socket-%E7%BC%96%E7%A8%8B%E4%B9%8B-epoll-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ 内存模型学习笔记</h2></header><div class=entry-content><p>C++ 内存模型从上（高地址）到下（低地址）可以分为以下几个部分：
栈区：由编译器自动分配释放，存放函数的参数值、局部变量的值等。
堆区：由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收。
全局/静态区：分为 .data 段（全局初始化区）和 .bss 段（全局未初始化区），.data 段存放 已初始化 了的全局变量和静态变量，.bss 段存放 未初始化 的变量。
常量区：就是 .rodata 段，存放常量。
代码区：存放函数体的代码。</p></div><footer class=entry-footer><span title='2024-06-29 16:44:14 +0800 +0800'>2024年06月29日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to C++ 内存模型学习笔记" href=https://blog.cassdev.com/posts/c++-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ delete ptr 和 ptr = nullptr 的区别</h2></header><div class=entry-content><p>delete ptrdelete ptr 是释放 ptr 所指向的对象资源，而 ptr 依然存在，且依然指向那片内存地址。
ptr = nullptrptr = nullptr 是将 ptr 指向空指针，和其所指向的对象没关系。
试着实现一个 unique_ptrtemplate &lt;typename T> class UniquePtr { private: T *_ptr; public: // 默认构造 UniquePtr() : _ptr(nullptr) { } explicit UniquePtr(T *ptr) : _ptr(ptr) { } ~UniquePtr() { delete _ptr; // 无需置 nullptr，因为析构函数会被调用，_ptr 会被销毁 // 置空无意义 } // 拷贝构造 删除 UniquePtr(const UniquePtr &) = delete; UniquePtr &amp;operator=(const UniquePtr &) = delete; // 移动构造 UniquePtr(UniquePtr &&amp;p) noexcept : _ptr(p._ptr) { // 至于这里为什么不需要 delete _ptr // 是因为这是移动构造函数，是个构造函数！_ptr 本来就没有资源 p._ptr = nullptr; } UniquePtr &amp;operator=(UniquePtr &&amp;p) noexcept { if (p != *this) { delete _ptr; // 第一步，释放当前资源 _ptr = p._ptr; // 第二步，将当前指针指向新的资源 p._ptr = nullptr; // 第三步，将原来的指针置空 } return *this; } T *get() const { // 返回指针 return _ptr; } T *operator->() const { // 返回指针 return _ptr; } T &amp;operator*() const { // 解引用 return *_ptr; } T *release() { // 这里不能 delete _ptr // 因为 release 只是解除 UniquePtr 对资源的所有权，但资源还是存在的 T *tmp = _ptr; _ptr = nullptr; return tmp; } void reset(T *newptr = nullptr) { if (_ptr != newptr) { delete _ptr; // 释放当前资源 _ptr = newptr; // 指向新资源 // 这里不需要置空 newptr // 是否置空 new ptr 由用户决定 } } }; UniquePtr &amp;operator=(UniquePtr &&amp;p) 移动赋值运算符的原理如下图：
...</p></div><footer class=entry-footer><span title='2024-06-29 14:42:02 +0800 +0800'>2024年06月29日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to C++ delete ptr 和 ptr = nullptr 的区别" href=https://blog.cassdev.com/posts/c++-delete-ptr-%E5%92%8C-ptr--nullptr-%E7%9A%84%E5%8C%BA%E5%88%AB/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>哈希冲突解决方法学习笔记</h2></header><div class=entry-content><p>链地址法链地址法也叫做拉链法，它的基本思想是，将哈希表中的每个槽位都指向一个链表，当发生哈希冲突时，将数据插入到链表中。
很好理解，如图所示：
开放定址法开放定址法是一种解决哈希冲突的方法，它的基本思想是，当发生哈希冲突时，不是将数据直接插入到哈希表中，而是寻找哈希表中的空槽位，将数据插入到空槽位中。
线性探测线性探测采用固定步长的线性搜索来进行探测。
插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 1），直至找到空桶，将元素插入其中。 查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 value 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 None 。 注意，我们不能在开放寻址哈希表中直接删除元素。因为删除元素会在数组内产生一个空桶 None ，当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在。
为了解决该问题，我们可以采用懒删除（ lazy deletion ）机制，不直接从哈希表中移除元素，而是利用一个常量 TOMBSTONE 来标记这个桶。
None 和 TOMBSTONE 都代表空桶，都可以放置键值对。线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。在线性探测中记录遇到的首个 TOMBSTONE 的索引，并将搜索到的目标元素与该 TOMBSTONE 交换位置，这样可以优化效率。
线性探测容易产生 聚集现象，为了缓解这个问题，就有了平方探测和双重散列。
平方探测平方探测思想与线性探测类似，不同之处在于探测的步长是平方级别的。即当发生哈希冲突时，探测的步长为 1，4，9，…步。
平方探测可以缓解线性探测的聚集现象，但不能彻底解决。
多次哈希多次哈希的基本思想是，当发生哈希冲突时，尝试其他的哈希函数，直到找到空槽位。
与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。
警告 以上三种方法，线性探测、平方探测和多次哈希哈希表都存在 不能直接删除元素 的问题。
...</p></div><footer class=entry-footer><span title='2024-06-29 10:16:12 +0800 +0800'>2024年06月29日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to 哈希冲突解决方法学习笔记" href=https://blog.cassdev.com/posts/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ STL 常用容器和迭代器学习笔记</h2></header><div class=entry-content><p>常用容器 序列容器
vector: 动态数组，随机插入/删除 O(n)，随机访问 O(1)，尾插 O(1)
array: 静态数组，不支持插入/删除，随机访问 O(1)
deque: 双端队列，头尾插入/删除 O(1)，随机访问 O(1)，中间插入/删除 O(n)
list: 双向链表，插入/删除 O(1)，不支持随机访问
forward_list: 单向链表，插入/删除 O(1)，不支持随机访问
关联容器（底层实现为 红黑树 ）
set: 有序集合，插入/删除/查找 O(logn)
map: 有序映射，插入/删除/查找 O(logn)
multiset: 有序多重集合，插入/删除/查找 O(logn)
multimap: 有序多重映射，插入/删除/查找 O(logn)
无序容器（底层实现为 哈希表 ）
unordered_set: 无序集合，插入/删除/查找 O(1)
unordered_map: 无序映射，插入/删除/查找 O(1)
unordered_multiset: 无序多重集合，插入/删除/查找 O(1)
unordered_multimap: 无序多重映射，插入/删除/查找 O(1)
容器适配器
stack: 栈，后进先出，只能在栈顶插入/删除元素
queue: 队列，先进先出，只能在队尾插入，在队头删除元素
priority_queue: 优先队列，元素按照一定规则排序，每次取出的是最大/最小元素，底层实现为堆
vector#include &lt;iostream> #include &lt;vector> using namespace std; // vector使用示例 int main() { vector&lt;int> vec = {1, 2, 3, 4, 5}; // 尾部插入元素：复杂度为O(1) vec.push_back(6); // 尾部删除元素：复杂度为O(1) vec.pop_back(); // 随机插入和删除元素：复杂度为O(n) vec.insert(vec.begin() + 1, 3); vec.erase(vec.begin() + 1); // vector的大小 cout &lt;&lt; vec.size() &lt;&lt; endl; // 获取vector的容量 cout &lt;&lt; vec.capacity() &lt;&lt; endl; // 判断vector是否为空 cout &lt;&lt; vec.empty() &lt;&lt; endl; // 获取vector的第一个元素和最后一个元素 cout &lt;&lt; vec.front() &lt;&lt; endl; cout &lt;&lt; vec.back() &lt;&lt; endl; // 访问指定位置的元素 cout &lt;&lt; vec[2] &lt;&lt; endl; cout &lt;&lt; vec.at(2) &lt;&lt; endl; // at函数会检查索引是否越界，更安全 vector&lt;int> vec2 = {7, 8, 9, 10}; vec.swap(vec2); // 交换两个vector的元素 // 清空vector vec.clear(); } vector 常用的成员函数：
...</p></div><footer class=entry-footer><span title='2024-06-28 19:50:50 +0800 +0800'>2024年06月28日</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to C++ STL 常用容器和迭代器学习笔记" href=https://blog.cassdev.com/posts/c++-stl-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ 对象和指针的区别学习笔记</h2></header><div class=entry-content><p>对象MyClass obj; obj.fun(); obj.count = 10; 对象是类的实例，占据实际的内存空间，可以调用类的成员函数和访问类的成员变量。
对象大小 = 成员变量大小 + 对齐填充
指针MyClass *p = new MyClass; p->fun(); p->count = 10; 指针是一个变量，存储对象的地址，可以通过指针访问对象的成员函数和成员变量。
指针大小 = 4 字节（32 位系统）或 8 字节（64 位系统）
对象和指针的区别 内存管理 对象：内存分配和释放通常是自动的（除非使用动态分配）。 指针：指向的内存需要手动管理，尤其是动态分配的内存。 访问方式： 对象：直接访问成员。 指针：通过解引用访问成员（使用 -> 操作符）。 生命周期： 对象：由作用域决定，局部对象在离开作用域时自动销毁。 指针：生命周期由程序员控制，指针可以指向任何作用域的变量。</p></div><footer class=entry-footer><span title='2024-06-28 10:26:35 +0800 +0800'>2024年06月28日</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to C++ 对象和指针的区别学习笔记" href=https://blog.cassdev.com/posts/c++-%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ 多态学习笔记</h2></header><div class=entry-content><p>C++ 的多态性是面向对象程序设计的三大特性之一（封装、继承、多态），它允许将子类对象赋值给父类对象，从而实现基类指针指向子类对象，实现基类指针调用子类对象的成员函数。
C++ 的多态性主要有两种实现方式：静态多态和动态多态。
静态多态：通过函数重载和模板实现。
动态多态：通过虚函数实现。
静态多态函数重载函数重载是指在同一个作用域内，可以定义 多个名称相同 但 参数列表不同 的函数。注意，不能用 返回值类型 来区分重载函数。
int add(int a, int b) { return a + b; } double add(double a, double b) { return a + b; } double add(double a, double b, double c) { return a + b + c; } 笔记 编译过程
...</p></div><footer class=entry-footer><span title='2024-06-27 22:52:10 +0800 +0800'>2024年06月27日</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;Cassius0924</footer><a class=entry-link aria-label="post link to C++ 多态学习笔记" href=https://blog.cassdev.com/posts/c++-%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://blog.cassdev.com/page/2/>下一页&nbsp;2/8&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2025-2025 Cassius0924. All rights reserved.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>